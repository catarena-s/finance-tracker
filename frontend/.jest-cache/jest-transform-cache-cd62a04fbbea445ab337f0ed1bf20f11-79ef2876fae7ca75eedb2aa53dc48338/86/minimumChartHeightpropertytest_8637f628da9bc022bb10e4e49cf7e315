ef095d81234d3dbee1e6443c0a555051
/**
 * Property-Based Test — Minimum Chart Height
 * 
 * **Свойство 8: Минимальная высота графиков**
 * **Валидирует: Требования 3.2**
 * 
 * For any chart (Chart.js), when displayed on a mobile device (viewport < 640px),
 * the chart container height should be at least 256px.
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _jsxruntime = require("react/jsx-runtime");
const _react = /*#__PURE__*/ _interop_require_default(require("react"));
const _react1 = require("@testing-library/react");
const _fastcheck = /*#__PURE__*/ _interop_require_default(require("fast-check"));
const _TrendChart = require("../../src/components/dashboard/TrendChart");
const _TopCategoriesWidget = require("../../src/components/dashboard/TopCategoriesWidget");
const _responsiveConfig = require("../../src/lib/responsiveConfig");
const _propertytestconfig = require("./property-test-config");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
// Minimum chart height for mobile devices (from requirements 3.2)
const MIN_CHART_HEIGHT_MOBILE = 256;
// Helper function to get computed height of an element
const getElementHeight = (element)=>{
    const rect = element.getBoundingClientRect();
    return rect.height;
};
// Helper function to find chart containers
const findChartContainers = (container)=>{
    // Chart containers have specific height classes: h-64, sm:h-80, lg:h-96
    const selectors = [
        ".h-64",
        "[class*='h-64']"
    ];
    const elements = [];
    selectors.forEach((selector)=>{
        const found = container.querySelectorAll(selector);
        elements.push(...Array.from(found));
    });
    return elements;
};
// Generator for trend chart data
const trendDataArbitrary = _fastcheck.default.record({
    incomeData: _fastcheck.default.array(_fastcheck.default.record({
        date: _fastcheck.default.date().map((d)=>d.toISOString().split("T")[0]),
        amount: _fastcheck.default.float({
            min: 0,
            max: 100000,
            noNaN: true
        })
    }), {
        minLength: 1,
        maxLength: 30
    }),
    expenseData: _fastcheck.default.array(_fastcheck.default.record({
        date: _fastcheck.default.date().map((d)=>d.toISOString().split("T")[0]),
        amount: _fastcheck.default.float({
            min: 0,
            max: 100000,
            noNaN: true
        })
    }), {
        minLength: 1,
        maxLength: 30
    })
});
// Generator for top categories data
const topCategoriesArbitrary = _fastcheck.default.array(_fastcheck.default.record({
    categoryName: _fastcheck.default.string({
        minLength: 3,
        maxLength: 20
    }),
    categoryIcon: _fastcheck.default.constantFrom("shopping-cart", "home", "car", "food", "entertainment"),
    totalAmount: _fastcheck.default.float({
        min: 0,
        max: 50000,
        noNaN: true
    }),
    percentage: _fastcheck.default.float({
        min: 0,
        max: 100,
        noNaN: true
    })
}), {
    minLength: 1,
    maxLength: 10
});
describe("Property: Minimum Chart Height", ()=>{
    describe("TrendChart component", ()=>{
        it("should have minimum 256px height on mobile viewports (< 640px)", ()=>{
            _fastcheck.default.assert(_fastcheck.default.property(_fastcheck.default.integer({
                min: 320,
                max: 639
            }), trendDataArbitrary, (viewportWidth, chartData)=>{
                // Mock window.innerWidth for mobile
                Object.defineProperty(window, "innerWidth", {
                    writable: true,
                    configurable: true,
                    value: viewportWidth
                });
                // Mock matchMedia for Tailwind's sm breakpoint (640px)
                Object.defineProperty(window, "matchMedia", {
                    writable: true,
                    value: jest.fn().mockImplementation((query)=>({
                            matches: query.includes("640px") ? false : true,
                            media: query,
                            onchange: null,
                            addListener: jest.fn(),
                            removeListener: jest.fn(),
                            addEventListener: jest.fn(),
                            removeEventListener: jest.fn(),
                            dispatchEvent: jest.fn()
                        }))
                });
                const { container } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_TrendChart.TrendChart, {
                    incomeData: chartData.incomeData,
                    expenseData: chartData.expenseData
                }));
                // Find chart containers
                const chartContainers = findChartContainers(container);
                expect(chartContainers.length).toBeGreaterThan(0);
                chartContainers.forEach((chartContainer)=>{
                    // Verify the container has the h-64 class (256px)
                    expect(chartContainer).toHaveClass("h-64");
                // Note: In JSDOM, Tailwind classes don't apply actual styles,
                // but we can verify the class is present which ensures 256px height
                // when rendered in a real browser
                });
            }), {
                numRuns: (0, _propertytestconfig.getNumRuns)("FAST")
            });
        });
        it("should verify chart height increases on tablet viewports (>= 640px)", ()=>{
            _fastcheck.default.assert(_fastcheck.default.property(_fastcheck.default.integer({
                min: 640,
                max: 1023
            }), trendDataArbitrary, (viewportWidth, chartData)=>{
                Object.defineProperty(window, "innerWidth", {
                    writable: true,
                    configurable: true,
                    value: viewportWidth
                });
                Object.defineProperty(window, "matchMedia", {
                    writable: true,
                    value: jest.fn().mockImplementation((query)=>({
                            matches: query.includes("640px") ? true : false,
                            media: query,
                            onchange: null,
                            addListener: jest.fn(),
                            removeListener: jest.fn(),
                            addEventListener: jest.fn(),
                            removeEventListener: jest.fn(),
                            dispatchEvent: jest.fn()
                        }))
                });
                const { container } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_TrendChart.TrendChart, {
                    incomeData: chartData.incomeData,
                    expenseData: chartData.expenseData
                }));
                const chartContainers = findChartContainers(container);
                expect(chartContainers.length).toBeGreaterThan(0);
                chartContainers.forEach((chartContainer)=>{
                    // Should have responsive height classes
                    expect(chartContainer).toHaveClass("h-64");
                    expect(chartContainer).toHaveClass("sm:h-80");
                });
            }), {
                numRuns: (0, _propertytestconfig.getNumRuns)("FAST")
            });
        });
        it("should verify chart height increases on desktop viewports (>= 1024px)", ()=>{
            _fastcheck.default.assert(_fastcheck.default.property(_fastcheck.default.integer({
                min: 1024,
                max: 1440
            }), trendDataArbitrary, (viewportWidth, chartData)=>{
                Object.defineProperty(window, "innerWidth", {
                    writable: true,
                    configurable: true,
                    value: viewportWidth
                });
                const { container } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_TrendChart.TrendChart, {
                    incomeData: chartData.incomeData,
                    expenseData: chartData.expenseData
                }));
                const chartContainers = findChartContainers(container);
                expect(chartContainers.length).toBeGreaterThan(0);
                chartContainers.forEach((chartContainer)=>{
                    // Should have all responsive height classes
                    expect(chartContainer).toHaveClass("h-64");
                    expect(chartContainer).toHaveClass("sm:h-80");
                    expect(chartContainer).toHaveClass("lg:h-96");
                });
            }), {
                numRuns: (0, _propertytestconfig.getNumRuns)("FAST")
            });
        });
    });
    describe("TopCategoriesWidget component", ()=>{
        it("should have minimum 256px height on mobile viewports (< 640px)", ()=>{
            _fastcheck.default.assert(_fastcheck.default.property(_fastcheck.default.integer({
                min: 320,
                max: 639
            }), topCategoriesArbitrary.filter((cats)=>cats.length >= 2 && cats.every((c)=>c.categoryName.trim().length > 0)), (viewportWidth, categories)=>{
                Object.defineProperty(window, "innerWidth", {
                    writable: true,
                    configurable: true,
                    value: viewportWidth
                });
                Object.defineProperty(window, "matchMedia", {
                    writable: true,
                    value: jest.fn().mockImplementation((query)=>({
                            matches: query.includes("640px") ? false : true,
                            media: query,
                            onchange: null,
                            addListener: jest.fn(),
                            removeListener: jest.fn(),
                            addEventListener: jest.fn(),
                            removeEventListener: jest.fn(),
                            dispatchEvent: jest.fn()
                        }))
                });
                try {
                    const { container } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_TopCategoriesWidget.TopCategoriesWidget, {
                        categories: categories
                    }));
                    const chartContainers = findChartContainers(container);
                    if (chartContainers.length > 0) {
                        chartContainers.forEach((chartContainer)=>{
                            // Verify the container has the h-64 class (256px)
                            expect(chartContainer).toHaveClass("h-64");
                        });
                    }
                } catch (error) {
                    // Chart.js may fail to render in JSDOM for some edge cases
                    // This is acceptable as we're testing CSS classes, not canvas rendering
                    if (error instanceof TypeError && error.message.includes("ownerDocument")) {
                        // Skip this iteration - canvas rendering issue in test environment
                        return;
                    }
                    throw error;
                }
            }), {
                numRuns: (0, _propertytestconfig.getNumRuns)("FAST")
            });
        });
        it("should verify chart height increases on tablet and desktop", ()=>{
            _fastcheck.default.assert(_fastcheck.default.property(_fastcheck.default.integer({
                min: 640,
                max: 1440
            }), topCategoriesArbitrary.filter((cats)=>cats.length >= 2 && cats.every((c)=>c.categoryName.trim().length > 0)), (viewportWidth, categories)=>{
                Object.defineProperty(window, "innerWidth", {
                    writable: true,
                    configurable: true,
                    value: viewportWidth
                });
                try {
                    const { container } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_TopCategoriesWidget.TopCategoriesWidget, {
                        categories: categories
                    }));
                    const chartContainers = findChartContainers(container);
                    if (chartContainers.length > 0) {
                        chartContainers.forEach((chartContainer)=>{
                            // Should have responsive height classes
                            expect(chartContainer).toHaveClass("h-64");
                            expect(chartContainer).toHaveClass("sm:h-80");
                            expect(chartContainer).toHaveClass("lg:h-96");
                        });
                    }
                } catch (error) {
                    // Chart.js may fail to render in JSDOM for some edge cases
                    if (error instanceof TypeError && error.message.includes("ownerDocument")) {
                        return;
                    }
                    throw error;
                }
            }), {
                numRuns: (0, _propertytestconfig.getNumRuns)("FAST")
            });
        });
    });
    describe("Chart configuration validation", ()=>{
        it("should verify chartResponsiveConfig has correct minimum mobile height", ()=>{
            // Validate that the configuration matches the requirement
            expect(_responsiveConfig.chartResponsiveConfig.height.mobile).toBe(MIN_CHART_HEIGHT_MOBILE);
            expect(_responsiveConfig.chartResponsiveConfig.height.mobile).toBeGreaterThanOrEqual(256);
        });
        it("should verify chart heights increase progressively", ()=>{
            // Mobile < Tablet < Desktop
            expect(_responsiveConfig.chartResponsiveConfig.height.mobile).toBeLessThan(_responsiveConfig.chartResponsiveConfig.height.tablet);
            expect(_responsiveConfig.chartResponsiveConfig.height.tablet).toBeLessThan(_responsiveConfig.chartResponsiveConfig.height.desktop);
        });
        it("should verify all chart heights meet minimum requirements", ()=>{
            // All heights should be at least the mobile minimum
            expect(_responsiveConfig.chartResponsiveConfig.height.mobile).toBeGreaterThanOrEqual(MIN_CHART_HEIGHT_MOBILE);
            expect(_responsiveConfig.chartResponsiveConfig.height.tablet).toBeGreaterThanOrEqual(MIN_CHART_HEIGHT_MOBILE);
            expect(_responsiveConfig.chartResponsiveConfig.height.desktop).toBeGreaterThanOrEqual(MIN_CHART_HEIGHT_MOBILE);
        });
    });
    describe("Edge cases", ()=>{
        it("should maintain minimum height at exactly 320px (minimum supported width)", ()=>{
            const viewportWidth = 320;
            Object.defineProperty(window, "innerWidth", {
                writable: true,
                configurable: true,
                value: viewportWidth
            });
            _fastcheck.default.assert(_fastcheck.default.property(trendDataArbitrary, (chartData)=>{
                const { container } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_TrendChart.TrendChart, {
                    incomeData: chartData.incomeData,
                    expenseData: chartData.expenseData
                }));
                const chartContainers = findChartContainers(container);
                expect(chartContainers.length).toBeGreaterThan(0);
                chartContainers.forEach((chartContainer)=>{
                    expect(chartContainer).toHaveClass("h-64");
                });
            }), {
                numRuns: (0, _propertytestconfig.getNumRuns)("SLOW")
            });
        });
        it("should switch to tablet height at exactly 640px (sm breakpoint)", ()=>{
            const viewportWidth = 640;
            Object.defineProperty(window, "innerWidth", {
                writable: true,
                configurable: true,
                value: viewportWidth
            });
            _fastcheck.default.assert(_fastcheck.default.property(trendDataArbitrary, (chartData)=>{
                const { container } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_TrendChart.TrendChart, {
                    incomeData: chartData.incomeData,
                    expenseData: chartData.expenseData
                }));
                const chartContainers = findChartContainers(container);
                expect(chartContainers.length).toBeGreaterThan(0);
                chartContainers.forEach((chartContainer)=>{
                    // Should have both mobile and tablet classes
                    expect(chartContainer).toHaveClass("h-64");
                    expect(chartContainer).toHaveClass("sm:h-80");
                });
            }), {
                numRuns: (0, _propertytestconfig.getNumRuns)("SLOW")
            });
        });
        it("should maintain minimum height at 639px (just below sm breakpoint)", ()=>{
            const viewportWidth = 639;
            Object.defineProperty(window, "innerWidth", {
                writable: true,
                configurable: true,
                value: viewportWidth
            });
            _fastcheck.default.assert(_fastcheck.default.property(topCategoriesArbitrary.filter((cats)=>cats.length >= 2 && cats.every((c)=>c.categoryName.trim().length > 0)), (categories)=>{
                try {
                    const { container } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_TopCategoriesWidget.TopCategoriesWidget, {
                        categories: categories
                    }));
                    const chartContainers = findChartContainers(container);
                    if (chartContainers.length > 0) {
                        chartContainers.forEach((chartContainer)=>{
                            expect(chartContainer).toHaveClass("h-64");
                        });
                    }
                } catch (error) {
                    // Chart.js may fail to render in JSDOM for some edge cases
                    if (error instanceof TypeError && error.message.includes("ownerDocument")) {
                        return;
                    }
                    throw error;
                }
            }), {
                numRuns: (0, _propertytestconfig.getNumRuns)("SLOW")
            });
        });
        it("should handle empty data gracefully while maintaining height classes", ()=>{
            _fastcheck.default.assert(_fastcheck.default.property(_fastcheck.default.integer({
                min: 320,
                max: 639
            }), (viewportWidth)=>{
                Object.defineProperty(window, "innerWidth", {
                    writable: true,
                    configurable: true,
                    value: viewportWidth
                });
                const { container } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_TrendChart.TrendChart, {
                    incomeData: [],
                    expenseData: []
                }));
                // Even with empty data, the component should render with proper structure
                // The "no data" message container should still respect height constraints
                const emptyStateContainer = container.querySelector(".h-64");
                if (emptyStateContainer) {
                    expect(emptyStateContainer).toHaveClass("h-64");
                }
            }), {
                numRuns: (0, _propertytestconfig.getNumRuns)("SLOW")
            });
        });
        it("should handle loading state while maintaining height classes", ()=>{
            _fastcheck.default.assert(_fastcheck.default.property(_fastcheck.default.integer({
                min: 320,
                max: 639
            }), (viewportWidth)=>{
                Object.defineProperty(window, "innerWidth", {
                    writable: true,
                    configurable: true,
                    value: viewportWidth
                });
                const { container } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_TopCategoriesWidget.TopCategoriesWidget, {
                    categories: [],
                    loading: true
                }));
                // Loading skeleton should also respect height constraints
                const loadingContainer = container.querySelector(".h-64");
                if (loadingContainer) {
                    expect(loadingContainer).toHaveClass("h-64");
                }
            }), {
                numRuns: (0, _propertytestconfig.getNumRuns)("SLOW")
            });
        });
    });
    describe("Requirement validation", ()=>{
        it("validates Requirement 3.2: Minimum 256px chart height on mobile", ()=>{
            _fastcheck.default.assert(_fastcheck.default.property(_fastcheck.default.integer({
                min: 320,
                max: 639
            }), trendDataArbitrary, (viewportWidth, chartData)=>{
                Object.defineProperty(window, "innerWidth", {
                    writable: true,
                    configurable: true,
                    value: viewportWidth
                });
                Object.defineProperty(window, "matchMedia", {
                    writable: true,
                    value: jest.fn().mockImplementation((query)=>({
                            matches: query.includes("640px") ? false : true,
                            media: query,
                            onchange: null,
                            addListener: jest.fn(),
                            removeListener: jest.fn(),
                            addEventListener: jest.fn(),
                            removeEventListener: jest.fn(),
                            dispatchEvent: jest.fn()
                        }))
                });
                // Requirement 3.2: WHEN График отображается на мобильном устройстве,
                // THE Система SHALL устанавливать высоту графика минимум 256px
                const { container } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_TrendChart.TrendChart, {
                    incomeData: chartData.incomeData,
                    expenseData: chartData.expenseData
                }));
                const chartContainers = findChartContainers(container);
                expect(chartContainers.length).toBeGreaterThan(0);
                chartContainers.forEach((chartContainer)=>{
                    // h-64 class ensures 256px height (16rem * 16px = 256px)
                    expect(chartContainer).toHaveClass("h-64");
                });
            }), {
                numRuns: (0, _propertytestconfig.getNumRuns)("MEDIUM")
            });
        });
        it("validates that chart height is consistent across different data sizes", ()=>{
            _fastcheck.default.assert(_fastcheck.default.property(_fastcheck.default.integer({
                min: 320,
                max: 639
            }), _fastcheck.default.integer({
                min: 1,
                max: 100
            }), (viewportWidth, dataPoints)=>{
                Object.defineProperty(window, "innerWidth", {
                    writable: true,
                    configurable: true,
                    value: viewportWidth
                });
                // Generate data with specified number of points
                const incomeData = Array.from({
                    length: dataPoints
                }, (_, i)=>({
                        date: `2024-01-${String(i + 1).padStart(2, "0")}`,
                        amount: Math.random() * 10000
                    }));
                const expenseData = Array.from({
                    length: dataPoints
                }, (_, i)=>({
                        date: `2024-01-${String(i + 1).padStart(2, "0")}`,
                        amount: Math.random() * 10000
                    }));
                const { container } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_TrendChart.TrendChart, {
                    incomeData: incomeData,
                    expenseData: expenseData
                }));
                const chartContainers = findChartContainers(container);
                expect(chartContainers.length).toBeGreaterThan(0);
                // Height should be consistent regardless of data size
                chartContainers.forEach((chartContainer)=>{
                    expect(chartContainer).toHaveClass("h-64");
                });
            }), {
                numRuns: (0, _propertytestconfig.getNumRuns)("FAST")
            });
        });
    });
    describe("General property validation", ()=>{
        it("should verify all chart components use responsive height classes", ()=>{
            _fastcheck.default.assert(_fastcheck.default.property(_fastcheck.default.integer({
                min: 320,
                max: 1440
            }), trendDataArbitrary, topCategoriesArbitrary.filter((cats)=>cats.length >= 2 && cats.every((c)=>c.categoryName.trim().length > 0)), (viewportWidth, trendData, categories)=>{
                Object.defineProperty(window, "innerWidth", {
                    writable: true,
                    configurable: true,
                    value: viewportWidth
                });
                // Test both chart components
                const { container: trendContainer } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_TrendChart.TrendChart, {
                    incomeData: trendData.incomeData,
                    expenseData: trendData.expenseData
                }));
                try {
                    const { container: categoriesContainer } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_TopCategoriesWidget.TopCategoriesWidget, {
                        categories: categories
                    }));
                    // Both should have responsive height classes
                    const trendCharts = findChartContainers(trendContainer);
                    const categoryCharts = findChartContainers(categoriesContainer);
                    expect(trendCharts.length).toBeGreaterThan(0);
                    [
                        ...trendCharts,
                        ...categoryCharts
                    ].forEach((chart)=>{
                        // All charts must have base mobile height
                        expect(chart).toHaveClass("h-64");
                        // All charts must have responsive classes
                        expect(chart).toHaveClass("sm:h-80");
                        expect(chart).toHaveClass("lg:h-96");
                    });
                } catch (error) {
                    // Chart.js may fail to render in JSDOM for some edge cases
                    if (error instanceof TypeError && error.message.includes("ownerDocument")) {
                        // At least verify TrendChart works
                        const trendCharts = findChartContainers(trendContainer);
                        expect(trendCharts.length).toBeGreaterThan(0);
                        trendCharts.forEach((chart)=>{
                            expect(chart).toHaveClass("h-64");
                            expect(chart).toHaveClass("sm:h-80");
                            expect(chart).toHaveClass("lg:h-96");
                        });
                        return;
                    }
                    throw error;
                }
            }), {
                numRuns: (0, _propertytestconfig.getNumRuns)("FAST")
            });
        });
        it("should ensure chart height classes follow mobile-first approach", ()=>{
            _fastcheck.default.assert(_fastcheck.default.property(trendDataArbitrary, (chartData)=>{
                const { container } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_TrendChart.TrendChart, {
                    incomeData: chartData.incomeData,
                    expenseData: chartData.expenseData
                }));
                const chartContainers = findChartContainers(container);
                expect(chartContainers.length).toBeGreaterThan(0);
                chartContainers.forEach((chartContainer)=>{
                    // Mobile-first: base class (h-64) should always be present
                    expect(chartContainer).toHaveClass("h-64");
                    // Responsive classes should be prefixed (sm:, lg:)
                    const classes = chartContainer.className;
                    expect(classes).toMatch(/\bh-64\b/);
                    expect(classes).toMatch(/\bsm:h-80\b/);
                    expect(classes).toMatch(/\blg:h-96\b/);
                });
            }), {
                numRuns: (0, _propertytestconfig.getNumRuns)("FAST")
            });
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkU6XFxteVxcb3R1c1xcZmluYW5jZV90cmFja2VyXFxmcm9udGVuZFxcX190ZXN0c19fXFxwcm9wZXJ0aWVzXFxtaW5pbXVtQ2hhcnRIZWlnaHQucHJvcGVydHkudGVzdC50c3giXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIFByb3BlcnR5LUJhc2VkIFRlc3Qg4oCUIE1pbmltdW0gQ2hhcnQgSGVpZ2h0XHJcbiAqIFxyXG4gKiAqKtCh0LLQvtC50YHRgtCy0L4gODog0JzQuNC90LjQvNCw0LvRjNC90LDRjyDQstGL0YHQvtGC0LAg0LPRgNCw0YTQuNC60L7QsioqXHJcbiAqICoq0JLQsNC70LjQtNC40YDRg9C10YI6INCi0YDQtdCx0L7QstCw0L3QuNGPIDMuMioqXHJcbiAqIFxyXG4gKiBGb3IgYW55IGNoYXJ0IChDaGFydC5qcyksIHdoZW4gZGlzcGxheWVkIG9uIGEgbW9iaWxlIGRldmljZSAodmlld3BvcnQgPCA2NDBweCksXHJcbiAqIHRoZSBjaGFydCBjb250YWluZXIgaGVpZ2h0IHNob3VsZCBiZSBhdCBsZWFzdCAyNTZweC5cclxuICovXHJcblxyXG5pbXBvcnQgUmVhY3QgZnJvbSBcInJlYWN0XCI7XHJcbmltcG9ydCB7IHJlbmRlciB9IGZyb20gXCJAdGVzdGluZy1saWJyYXJ5L3JlYWN0XCI7XHJcbmltcG9ydCBmYyBmcm9tIFwiZmFzdC1jaGVja1wiO1xyXG5pbXBvcnQgeyBUcmVuZENoYXJ0IH0gZnJvbSBcIkAvY29tcG9uZW50cy9kYXNoYm9hcmQvVHJlbmRDaGFydFwiO1xyXG5pbXBvcnQgeyBUb3BDYXRlZ29yaWVzV2lkZ2V0IH0gZnJvbSBcIkAvY29tcG9uZW50cy9kYXNoYm9hcmQvVG9wQ2F0ZWdvcmllc1dpZGdldFwiO1xyXG5pbXBvcnQgeyBjaGFydFJlc3BvbnNpdmVDb25maWcgfSBmcm9tIFwiQC9saWIvcmVzcG9uc2l2ZUNvbmZpZ1wiO1xyXG5pbXBvcnQgeyBnZXROdW1SdW5zLCBnZXRUaW1lb3V0IH0gZnJvbSBcIi4vcHJvcGVydHktdGVzdC1jb25maWdcIjtcclxuXHJcbi8vIE1pbmltdW0gY2hhcnQgaGVpZ2h0IGZvciBtb2JpbGUgZGV2aWNlcyAoZnJvbSByZXF1aXJlbWVudHMgMy4yKVxyXG5jb25zdCBNSU5fQ0hBUlRfSEVJR0hUX01PQklMRSA9IDI1NjtcclxuXHJcbi8vIEhlbHBlciBmdW5jdGlvbiB0byBnZXQgY29tcHV0ZWQgaGVpZ2h0IG9mIGFuIGVsZW1lbnRcclxuY29uc3QgZ2V0RWxlbWVudEhlaWdodCA9IChlbGVtZW50OiBFbGVtZW50KTogbnVtYmVyID0+IHtcclxuICBjb25zdCByZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuICByZXR1cm4gcmVjdC5oZWlnaHQ7XHJcbn07XHJcblxyXG4vLyBIZWxwZXIgZnVuY3Rpb24gdG8gZmluZCBjaGFydCBjb250YWluZXJzXHJcbmNvbnN0IGZpbmRDaGFydENvbnRhaW5lcnMgPSAoY29udGFpbmVyOiBIVE1MRWxlbWVudCk6IEVsZW1lbnRbXSA9PiB7XHJcbiAgLy8gQ2hhcnQgY29udGFpbmVycyBoYXZlIHNwZWNpZmljIGhlaWdodCBjbGFzc2VzOiBoLTY0LCBzbTpoLTgwLCBsZzpoLTk2XHJcbiAgY29uc3Qgc2VsZWN0b3JzID0gW1xyXG4gICAgXCIuaC02NFwiLFxyXG4gICAgXCJbY2xhc3MqPSdoLTY0J11cIixcclxuICBdO1xyXG4gIFxyXG4gIGNvbnN0IGVsZW1lbnRzOiBFbGVtZW50W10gPSBbXTtcclxuICBzZWxlY3RvcnMuZm9yRWFjaCgoc2VsZWN0b3IpID0+IHtcclxuICAgIGNvbnN0IGZvdW5kID0gY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpO1xyXG4gICAgZWxlbWVudHMucHVzaCguLi5BcnJheS5mcm9tKGZvdW5kKSk7XHJcbiAgfSk7XHJcbiAgXHJcbiAgcmV0dXJuIGVsZW1lbnRzO1xyXG59O1xyXG5cclxuLy8gR2VuZXJhdG9yIGZvciB0cmVuZCBjaGFydCBkYXRhXHJcbmNvbnN0IHRyZW5kRGF0YUFyYml0cmFyeSA9IGZjLnJlY29yZCh7XHJcbiAgaW5jb21lRGF0YTogZmMuYXJyYXkoXHJcbiAgICBmYy5yZWNvcmQoe1xyXG4gICAgICBkYXRlOiBmYy5kYXRlKCkubWFwKGQgPT4gZC50b0lTT1N0cmluZygpLnNwbGl0KCdUJylbMF0pLFxyXG4gICAgICBhbW91bnQ6IGZjLmZsb2F0KHsgbWluOiAwLCBtYXg6IDEwMDAwMCwgbm9OYU46IHRydWUgfSksXHJcbiAgICB9KSxcclxuICAgIHsgbWluTGVuZ3RoOiAxLCBtYXhMZW5ndGg6IDMwIH1cclxuICApLFxyXG4gIGV4cGVuc2VEYXRhOiBmYy5hcnJheShcclxuICAgIGZjLnJlY29yZCh7XHJcbiAgICAgIGRhdGU6IGZjLmRhdGUoKS5tYXAoZCA9PiBkLnRvSVNPU3RyaW5nKCkuc3BsaXQoJ1QnKVswXSksXHJcbiAgICAgIGFtb3VudDogZmMuZmxvYXQoeyBtaW46IDAsIG1heDogMTAwMDAwLCBub05hTjogdHJ1ZSB9KSxcclxuICAgIH0pLFxyXG4gICAgeyBtaW5MZW5ndGg6IDEsIG1heExlbmd0aDogMzAgfVxyXG4gICksXHJcbn0pO1xyXG5cclxuLy8gR2VuZXJhdG9yIGZvciB0b3AgY2F0ZWdvcmllcyBkYXRhXHJcbmNvbnN0IHRvcENhdGVnb3JpZXNBcmJpdHJhcnkgPSBmYy5hcnJheShcclxuICBmYy5yZWNvcmQoe1xyXG4gICAgY2F0ZWdvcnlOYW1lOiBmYy5zdHJpbmcoeyBtaW5MZW5ndGg6IDMsIG1heExlbmd0aDogMjAgfSksXHJcbiAgICBjYXRlZ29yeUljb246IGZjLmNvbnN0YW50RnJvbShcInNob3BwaW5nLWNhcnRcIiwgXCJob21lXCIsIFwiY2FyXCIsIFwiZm9vZFwiLCBcImVudGVydGFpbm1lbnRcIiksXHJcbiAgICB0b3RhbEFtb3VudDogZmMuZmxvYXQoeyBtaW46IDAsIG1heDogNTAwMDAsIG5vTmFOOiB0cnVlIH0pLFxyXG4gICAgcGVyY2VudGFnZTogZmMuZmxvYXQoeyBtaW46IDAsIG1heDogMTAwLCBub05hTjogdHJ1ZSB9KSxcclxuICB9KSxcclxuICB7IG1pbkxlbmd0aDogMSwgbWF4TGVuZ3RoOiAxMCB9XHJcbik7XHJcblxyXG5kZXNjcmliZShcIlByb3BlcnR5OiBNaW5pbXVtIENoYXJ0IEhlaWdodFwiLCAoKSA9PiB7XHJcbiAgZGVzY3JpYmUoXCJUcmVuZENoYXJ0IGNvbXBvbmVudFwiLCAoKSA9PiB7XHJcbiAgICBpdChcInNob3VsZCBoYXZlIG1pbmltdW0gMjU2cHggaGVpZ2h0IG9uIG1vYmlsZSB2aWV3cG9ydHMgKDwgNjQwcHgpXCIsICgpID0+IHtcclxuICAgICAgZmMuYXNzZXJ0KFxyXG4gICAgICAgIGZjLnByb3BlcnR5KFxyXG4gICAgICAgICAgZmMuaW50ZWdlcih7IG1pbjogMzIwLCBtYXg6IDYzOSB9KSwgLy8gTW9iaWxlIHZpZXdwb3J0IHJhbmdlXHJcbiAgICAgICAgICB0cmVuZERhdGFBcmJpdHJhcnksXHJcbiAgICAgICAgICAodmlld3BvcnRXaWR0aCwgY2hhcnREYXRhKSA9PiB7XHJcbiAgICAgICAgICAgIC8vIE1vY2sgd2luZG93LmlubmVyV2lkdGggZm9yIG1vYmlsZVxyXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkod2luZG93LCBcImlubmVyV2lkdGhcIiwge1xyXG4gICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgICB2YWx1ZTogdmlld3BvcnRXaWR0aCxcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAvLyBNb2NrIG1hdGNoTWVkaWEgZm9yIFRhaWx3aW5kJ3Mgc20gYnJlYWtwb2ludCAoNjQwcHgpXHJcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3aW5kb3csIFwibWF0Y2hNZWRpYVwiLCB7XHJcbiAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgdmFsdWU6IGplc3QuZm4oKS5tb2NrSW1wbGVtZW50YXRpb24oKHF1ZXJ5KSA9PiAoe1xyXG4gICAgICAgICAgICAgICAgbWF0Y2hlczogcXVlcnkuaW5jbHVkZXMoXCI2NDBweFwiKSA/IGZhbHNlIDogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIG1lZGlhOiBxdWVyeSxcclxuICAgICAgICAgICAgICAgIG9uY2hhbmdlOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgYWRkTGlzdGVuZXI6IGplc3QuZm4oKSxcclxuICAgICAgICAgICAgICAgIHJlbW92ZUxpc3RlbmVyOiBqZXN0LmZuKCksXHJcbiAgICAgICAgICAgICAgICBhZGRFdmVudExpc3RlbmVyOiBqZXN0LmZuKCksXHJcbiAgICAgICAgICAgICAgICByZW1vdmVFdmVudExpc3RlbmVyOiBqZXN0LmZuKCksXHJcbiAgICAgICAgICAgICAgICBkaXNwYXRjaEV2ZW50OiBqZXN0LmZuKCksXHJcbiAgICAgICAgICAgICAgfSkpLFxyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IHsgY29udGFpbmVyIH0gPSByZW5kZXIoXHJcbiAgICAgICAgICAgICAgPFRyZW5kQ2hhcnRcclxuICAgICAgICAgICAgICAgIGluY29tZURhdGE9e2NoYXJ0RGF0YS5pbmNvbWVEYXRhfVxyXG4gICAgICAgICAgICAgICAgZXhwZW5zZURhdGE9e2NoYXJ0RGF0YS5leHBlbnNlRGF0YX1cclxuICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgLy8gRmluZCBjaGFydCBjb250YWluZXJzXHJcbiAgICAgICAgICAgIGNvbnN0IGNoYXJ0Q29udGFpbmVycyA9IGZpbmRDaGFydENvbnRhaW5lcnMoY29udGFpbmVyKTtcclxuXHJcbiAgICAgICAgICAgIGV4cGVjdChjaGFydENvbnRhaW5lcnMubGVuZ3RoKS50b0JlR3JlYXRlclRoYW4oMCk7XHJcblxyXG4gICAgICAgICAgICBjaGFydENvbnRhaW5lcnMuZm9yRWFjaCgoY2hhcnRDb250YWluZXIpID0+IHtcclxuICAgICAgICAgICAgICAvLyBWZXJpZnkgdGhlIGNvbnRhaW5lciBoYXMgdGhlIGgtNjQgY2xhc3MgKDI1NnB4KVxyXG4gICAgICAgICAgICAgIGV4cGVjdChjaGFydENvbnRhaW5lcikudG9IYXZlQ2xhc3MoXCJoLTY0XCIpO1xyXG4gICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgIC8vIE5vdGU6IEluIEpTRE9NLCBUYWlsd2luZCBjbGFzc2VzIGRvbid0IGFwcGx5IGFjdHVhbCBzdHlsZXMsXHJcbiAgICAgICAgICAgICAgLy8gYnV0IHdlIGNhbiB2ZXJpZnkgdGhlIGNsYXNzIGlzIHByZXNlbnQgd2hpY2ggZW5zdXJlcyAyNTZweCBoZWlnaHRcclxuICAgICAgICAgICAgICAvLyB3aGVuIHJlbmRlcmVkIGluIGEgcmVhbCBicm93c2VyXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICksXHJcbiAgICAgICAgeyBudW1SdW5zOiBnZXROdW1SdW5zKFwiRkFTVFwiKSB9XHJcbiAgICAgICk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBpdChcInNob3VsZCB2ZXJpZnkgY2hhcnQgaGVpZ2h0IGluY3JlYXNlcyBvbiB0YWJsZXQgdmlld3BvcnRzICg+PSA2NDBweClcIiwgKCkgPT4ge1xyXG4gICAgICBmYy5hc3NlcnQoXHJcbiAgICAgICAgZmMucHJvcGVydHkoXHJcbiAgICAgICAgICBmYy5pbnRlZ2VyKHsgbWluOiA2NDAsIG1heDogMTAyMyB9KSwgLy8gVGFibGV0IHZpZXdwb3J0IHJhbmdlXHJcbiAgICAgICAgICB0cmVuZERhdGFBcmJpdHJhcnksXHJcbiAgICAgICAgICAodmlld3BvcnRXaWR0aCwgY2hhcnREYXRhKSA9PiB7XHJcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3aW5kb3csIFwiaW5uZXJXaWR0aFwiLCB7XHJcbiAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICAgIHZhbHVlOiB2aWV3cG9ydFdpZHRoLFxyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3aW5kb3csIFwibWF0Y2hNZWRpYVwiLCB7XHJcbiAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgdmFsdWU6IGplc3QuZm4oKS5tb2NrSW1wbGVtZW50YXRpb24oKHF1ZXJ5KSA9PiAoe1xyXG4gICAgICAgICAgICAgICAgbWF0Y2hlczogcXVlcnkuaW5jbHVkZXMoXCI2NDBweFwiKSA/IHRydWUgOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIG1lZGlhOiBxdWVyeSxcclxuICAgICAgICAgICAgICAgIG9uY2hhbmdlOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgYWRkTGlzdGVuZXI6IGplc3QuZm4oKSxcclxuICAgICAgICAgICAgICAgIHJlbW92ZUxpc3RlbmVyOiBqZXN0LmZuKCksXHJcbiAgICAgICAgICAgICAgICBhZGRFdmVudExpc3RlbmVyOiBqZXN0LmZuKCksXHJcbiAgICAgICAgICAgICAgICByZW1vdmVFdmVudExpc3RlbmVyOiBqZXN0LmZuKCksXHJcbiAgICAgICAgICAgICAgICBkaXNwYXRjaEV2ZW50OiBqZXN0LmZuKCksXHJcbiAgICAgICAgICAgICAgfSkpLFxyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IHsgY29udGFpbmVyIH0gPSByZW5kZXIoXHJcbiAgICAgICAgICAgICAgPFRyZW5kQ2hhcnRcclxuICAgICAgICAgICAgICAgIGluY29tZURhdGE9e2NoYXJ0RGF0YS5pbmNvbWVEYXRhfVxyXG4gICAgICAgICAgICAgICAgZXhwZW5zZURhdGE9e2NoYXJ0RGF0YS5leHBlbnNlRGF0YX1cclxuICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgY2hhcnRDb250YWluZXJzID0gZmluZENoYXJ0Q29udGFpbmVycyhjb250YWluZXIpO1xyXG5cclxuICAgICAgICAgICAgZXhwZWN0KGNoYXJ0Q29udGFpbmVycy5sZW5ndGgpLnRvQmVHcmVhdGVyVGhhbigwKTtcclxuXHJcbiAgICAgICAgICAgIGNoYXJ0Q29udGFpbmVycy5mb3JFYWNoKChjaGFydENvbnRhaW5lcikgPT4ge1xyXG4gICAgICAgICAgICAgIC8vIFNob3VsZCBoYXZlIHJlc3BvbnNpdmUgaGVpZ2h0IGNsYXNzZXNcclxuICAgICAgICAgICAgICBleHBlY3QoY2hhcnRDb250YWluZXIpLnRvSGF2ZUNsYXNzKFwiaC02NFwiKTtcclxuICAgICAgICAgICAgICBleHBlY3QoY2hhcnRDb250YWluZXIpLnRvSGF2ZUNsYXNzKFwic206aC04MFwiKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgKSxcclxuICAgICAgICB7IG51bVJ1bnM6IGdldE51bVJ1bnMoXCJGQVNUXCIpIH1cclxuICAgICAgKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGl0KFwic2hvdWxkIHZlcmlmeSBjaGFydCBoZWlnaHQgaW5jcmVhc2VzIG9uIGRlc2t0b3Agdmlld3BvcnRzICg+PSAxMDI0cHgpXCIsICgpID0+IHtcclxuICAgICAgZmMuYXNzZXJ0KFxyXG4gICAgICAgIGZjLnByb3BlcnR5KFxyXG4gICAgICAgICAgZmMuaW50ZWdlcih7IG1pbjogMTAyNCwgbWF4OiAxNDQwIH0pLCAvLyBEZXNrdG9wIHZpZXdwb3J0IHJhbmdlXHJcbiAgICAgICAgICB0cmVuZERhdGFBcmJpdHJhcnksXHJcbiAgICAgICAgICAodmlld3BvcnRXaWR0aCwgY2hhcnREYXRhKSA9PiB7XHJcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3aW5kb3csIFwiaW5uZXJXaWR0aFwiLCB7XHJcbiAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICAgIHZhbHVlOiB2aWV3cG9ydFdpZHRoLFxyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IHsgY29udGFpbmVyIH0gPSByZW5kZXIoXHJcbiAgICAgICAgICAgICAgPFRyZW5kQ2hhcnRcclxuICAgICAgICAgICAgICAgIGluY29tZURhdGE9e2NoYXJ0RGF0YS5pbmNvbWVEYXRhfVxyXG4gICAgICAgICAgICAgICAgZXhwZW5zZURhdGE9e2NoYXJ0RGF0YS5leHBlbnNlRGF0YX1cclxuICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgY2hhcnRDb250YWluZXJzID0gZmluZENoYXJ0Q29udGFpbmVycyhjb250YWluZXIpO1xyXG5cclxuICAgICAgICAgICAgZXhwZWN0KGNoYXJ0Q29udGFpbmVycy5sZW5ndGgpLnRvQmVHcmVhdGVyVGhhbigwKTtcclxuXHJcbiAgICAgICAgICAgIGNoYXJ0Q29udGFpbmVycy5mb3JFYWNoKChjaGFydENvbnRhaW5lcikgPT4ge1xyXG4gICAgICAgICAgICAgIC8vIFNob3VsZCBoYXZlIGFsbCByZXNwb25zaXZlIGhlaWdodCBjbGFzc2VzXHJcbiAgICAgICAgICAgICAgZXhwZWN0KGNoYXJ0Q29udGFpbmVyKS50b0hhdmVDbGFzcyhcImgtNjRcIik7XHJcbiAgICAgICAgICAgICAgZXhwZWN0KGNoYXJ0Q29udGFpbmVyKS50b0hhdmVDbGFzcyhcInNtOmgtODBcIik7XHJcbiAgICAgICAgICAgICAgZXhwZWN0KGNoYXJ0Q29udGFpbmVyKS50b0hhdmVDbGFzcyhcImxnOmgtOTZcIik7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICksXHJcbiAgICAgICAgeyBudW1SdW5zOiBnZXROdW1SdW5zKFwiRkFTVFwiKSB9XHJcbiAgICAgICk7XHJcbiAgICB9KTtcclxuICB9KTtcclxuXHJcbiAgZGVzY3JpYmUoXCJUb3BDYXRlZ29yaWVzV2lkZ2V0IGNvbXBvbmVudFwiLCAoKSA9PiB7XHJcbiAgICBpdChcInNob3VsZCBoYXZlIG1pbmltdW0gMjU2cHggaGVpZ2h0IG9uIG1vYmlsZSB2aWV3cG9ydHMgKDwgNjQwcHgpXCIsICgpID0+IHtcclxuICAgICAgZmMuYXNzZXJ0KFxyXG4gICAgICAgIGZjLnByb3BlcnR5KFxyXG4gICAgICAgICAgZmMuaW50ZWdlcih7IG1pbjogMzIwLCBtYXg6IDYzOSB9KSxcclxuICAgICAgICAgIHRvcENhdGVnb3JpZXNBcmJpdHJhcnkuZmlsdGVyKGNhdHMgPT4gY2F0cy5sZW5ndGggPj0gMiAmJiBjYXRzLmV2ZXJ5KGMgPT4gYy5jYXRlZ29yeU5hbWUudHJpbSgpLmxlbmd0aCA+IDApKSxcclxuICAgICAgICAgICh2aWV3cG9ydFdpZHRoLCBjYXRlZ29yaWVzKSA9PiB7XHJcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3aW5kb3csIFwiaW5uZXJXaWR0aFwiLCB7XHJcbiAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICAgIHZhbHVlOiB2aWV3cG9ydFdpZHRoLFxyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3aW5kb3csIFwibWF0Y2hNZWRpYVwiLCB7XHJcbiAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgdmFsdWU6IGplc3QuZm4oKS5tb2NrSW1wbGVtZW50YXRpb24oKHF1ZXJ5KSA9PiAoe1xyXG4gICAgICAgICAgICAgICAgbWF0Y2hlczogcXVlcnkuaW5jbHVkZXMoXCI2NDBweFwiKSA/IGZhbHNlIDogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIG1lZGlhOiBxdWVyeSxcclxuICAgICAgICAgICAgICAgIG9uY2hhbmdlOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgYWRkTGlzdGVuZXI6IGplc3QuZm4oKSxcclxuICAgICAgICAgICAgICAgIHJlbW92ZUxpc3RlbmVyOiBqZXN0LmZuKCksXHJcbiAgICAgICAgICAgICAgICBhZGRFdmVudExpc3RlbmVyOiBqZXN0LmZuKCksXHJcbiAgICAgICAgICAgICAgICByZW1vdmVFdmVudExpc3RlbmVyOiBqZXN0LmZuKCksXHJcbiAgICAgICAgICAgICAgICBkaXNwYXRjaEV2ZW50OiBqZXN0LmZuKCksXHJcbiAgICAgICAgICAgICAgfSkpLFxyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgY29uc3QgeyBjb250YWluZXIgfSA9IHJlbmRlcihcclxuICAgICAgICAgICAgICAgIDxUb3BDYXRlZ29yaWVzV2lkZ2V0IGNhdGVnb3JpZXM9e2NhdGVnb3JpZXN9IC8+XHJcbiAgICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgICAgY29uc3QgY2hhcnRDb250YWluZXJzID0gZmluZENoYXJ0Q29udGFpbmVycyhjb250YWluZXIpO1xyXG5cclxuICAgICAgICAgICAgICBpZiAoY2hhcnRDb250YWluZXJzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgIGNoYXJ0Q29udGFpbmVycy5mb3JFYWNoKChjaGFydENvbnRhaW5lcikgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAvLyBWZXJpZnkgdGhlIGNvbnRhaW5lciBoYXMgdGhlIGgtNjQgY2xhc3MgKDI1NnB4KVxyXG4gICAgICAgICAgICAgICAgICBleHBlY3QoY2hhcnRDb250YWluZXIpLnRvSGF2ZUNsYXNzKFwiaC02NFwiKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAvLyBDaGFydC5qcyBtYXkgZmFpbCB0byByZW5kZXIgaW4gSlNET00gZm9yIHNvbWUgZWRnZSBjYXNlc1xyXG4gICAgICAgICAgICAgIC8vIFRoaXMgaXMgYWNjZXB0YWJsZSBhcyB3ZSdyZSB0ZXN0aW5nIENTUyBjbGFzc2VzLCBub3QgY2FudmFzIHJlbmRlcmluZ1xyXG4gICAgICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIFR5cGVFcnJvciAmJiBlcnJvci5tZXNzYWdlLmluY2x1ZGVzKCdvd25lckRvY3VtZW50JykpIHtcclxuICAgICAgICAgICAgICAgIC8vIFNraXAgdGhpcyBpdGVyYXRpb24gLSBjYW52YXMgcmVuZGVyaW5nIGlzc3VlIGluIHRlc3QgZW52aXJvbm1lbnRcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICApLFxyXG4gICAgICAgIHsgbnVtUnVuczogZ2V0TnVtUnVucyhcIkZBU1RcIikgfVxyXG4gICAgICApO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaXQoXCJzaG91bGQgdmVyaWZ5IGNoYXJ0IGhlaWdodCBpbmNyZWFzZXMgb24gdGFibGV0IGFuZCBkZXNrdG9wXCIsICgpID0+IHtcclxuICAgICAgZmMuYXNzZXJ0KFxyXG4gICAgICAgIGZjLnByb3BlcnR5KFxyXG4gICAgICAgICAgZmMuaW50ZWdlcih7IG1pbjogNjQwLCBtYXg6IDE0NDAgfSksXHJcbiAgICAgICAgICB0b3BDYXRlZ29yaWVzQXJiaXRyYXJ5LmZpbHRlcihjYXRzID0+IGNhdHMubGVuZ3RoID49IDIgJiYgY2F0cy5ldmVyeShjID0+IGMuY2F0ZWdvcnlOYW1lLnRyaW0oKS5sZW5ndGggPiAwKSksXHJcbiAgICAgICAgICAodmlld3BvcnRXaWR0aCwgY2F0ZWdvcmllcykgPT4ge1xyXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkod2luZG93LCBcImlubmVyV2lkdGhcIiwge1xyXG4gICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgICB2YWx1ZTogdmlld3BvcnRXaWR0aCxcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgIGNvbnN0IHsgY29udGFpbmVyIH0gPSByZW5kZXIoXHJcbiAgICAgICAgICAgICAgICA8VG9wQ2F0ZWdvcmllc1dpZGdldCBjYXRlZ29yaWVzPXtjYXRlZ29yaWVzfSAvPlxyXG4gICAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICAgIGNvbnN0IGNoYXJ0Q29udGFpbmVycyA9IGZpbmRDaGFydENvbnRhaW5lcnMoY29udGFpbmVyKTtcclxuXHJcbiAgICAgICAgICAgICAgaWYgKGNoYXJ0Q29udGFpbmVycy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBjaGFydENvbnRhaW5lcnMuZm9yRWFjaCgoY2hhcnRDb250YWluZXIpID0+IHtcclxuICAgICAgICAgICAgICAgICAgLy8gU2hvdWxkIGhhdmUgcmVzcG9uc2l2ZSBoZWlnaHQgY2xhc3Nlc1xyXG4gICAgICAgICAgICAgICAgICBleHBlY3QoY2hhcnRDb250YWluZXIpLnRvSGF2ZUNsYXNzKFwiaC02NFwiKTtcclxuICAgICAgICAgICAgICAgICAgZXhwZWN0KGNoYXJ0Q29udGFpbmVyKS50b0hhdmVDbGFzcyhcInNtOmgtODBcIik7XHJcbiAgICAgICAgICAgICAgICAgIGV4cGVjdChjaGFydENvbnRhaW5lcikudG9IYXZlQ2xhc3MoXCJsZzpoLTk2XCIpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICAgIC8vIENoYXJ0LmpzIG1heSBmYWlsIHRvIHJlbmRlciBpbiBKU0RPTSBmb3Igc29tZSBlZGdlIGNhc2VzXHJcbiAgICAgICAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgVHlwZUVycm9yICYmIGVycm9yLm1lc3NhZ2UuaW5jbHVkZXMoJ293bmVyRG9jdW1lbnQnKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICksXHJcbiAgICAgICAgeyBudW1SdW5zOiBnZXROdW1SdW5zKFwiRkFTVFwiKSB9XHJcbiAgICAgICk7XHJcbiAgICB9KTtcclxuICB9KTtcclxuXHJcbiAgZGVzY3JpYmUoXCJDaGFydCBjb25maWd1cmF0aW9uIHZhbGlkYXRpb25cIiwgKCkgPT4ge1xyXG4gICAgaXQoXCJzaG91bGQgdmVyaWZ5IGNoYXJ0UmVzcG9uc2l2ZUNvbmZpZyBoYXMgY29ycmVjdCBtaW5pbXVtIG1vYmlsZSBoZWlnaHRcIiwgKCkgPT4ge1xyXG4gICAgICAvLyBWYWxpZGF0ZSB0aGF0IHRoZSBjb25maWd1cmF0aW9uIG1hdGNoZXMgdGhlIHJlcXVpcmVtZW50XHJcbiAgICAgIGV4cGVjdChjaGFydFJlc3BvbnNpdmVDb25maWcuaGVpZ2h0Lm1vYmlsZSkudG9CZShNSU5fQ0hBUlRfSEVJR0hUX01PQklMRSk7XHJcbiAgICAgIGV4cGVjdChjaGFydFJlc3BvbnNpdmVDb25maWcuaGVpZ2h0Lm1vYmlsZSkudG9CZUdyZWF0ZXJUaGFuT3JFcXVhbCgyNTYpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaXQoXCJzaG91bGQgdmVyaWZ5IGNoYXJ0IGhlaWdodHMgaW5jcmVhc2UgcHJvZ3Jlc3NpdmVseVwiLCAoKSA9PiB7XHJcbiAgICAgIC8vIE1vYmlsZSA8IFRhYmxldCA8IERlc2t0b3BcclxuICAgICAgZXhwZWN0KGNoYXJ0UmVzcG9uc2l2ZUNvbmZpZy5oZWlnaHQubW9iaWxlKS50b0JlTGVzc1RoYW4oXHJcbiAgICAgICAgY2hhcnRSZXNwb25zaXZlQ29uZmlnLmhlaWdodC50YWJsZXRcclxuICAgICAgKTtcclxuICAgICAgZXhwZWN0KGNoYXJ0UmVzcG9uc2l2ZUNvbmZpZy5oZWlnaHQudGFibGV0KS50b0JlTGVzc1RoYW4oXHJcbiAgICAgICAgY2hhcnRSZXNwb25zaXZlQ29uZmlnLmhlaWdodC5kZXNrdG9wXHJcbiAgICAgICk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBpdChcInNob3VsZCB2ZXJpZnkgYWxsIGNoYXJ0IGhlaWdodHMgbWVldCBtaW5pbXVtIHJlcXVpcmVtZW50c1wiLCAoKSA9PiB7XHJcbiAgICAgIC8vIEFsbCBoZWlnaHRzIHNob3VsZCBiZSBhdCBsZWFzdCB0aGUgbW9iaWxlIG1pbmltdW1cclxuICAgICAgZXhwZWN0KGNoYXJ0UmVzcG9uc2l2ZUNvbmZpZy5oZWlnaHQubW9iaWxlKS50b0JlR3JlYXRlclRoYW5PckVxdWFsKE1JTl9DSEFSVF9IRUlHSFRfTU9CSUxFKTtcclxuICAgICAgZXhwZWN0KGNoYXJ0UmVzcG9uc2l2ZUNvbmZpZy5oZWlnaHQudGFibGV0KS50b0JlR3JlYXRlclRoYW5PckVxdWFsKE1JTl9DSEFSVF9IRUlHSFRfTU9CSUxFKTtcclxuICAgICAgZXhwZWN0KGNoYXJ0UmVzcG9uc2l2ZUNvbmZpZy5oZWlnaHQuZGVza3RvcCkudG9CZUdyZWF0ZXJUaGFuT3JFcXVhbChNSU5fQ0hBUlRfSEVJR0hUX01PQklMRSk7XHJcbiAgICB9KTtcclxuICB9KTtcclxuXHJcbiAgZGVzY3JpYmUoXCJFZGdlIGNhc2VzXCIsICgpID0+IHtcclxuICAgIGl0KFwic2hvdWxkIG1haW50YWluIG1pbmltdW0gaGVpZ2h0IGF0IGV4YWN0bHkgMzIwcHggKG1pbmltdW0gc3VwcG9ydGVkIHdpZHRoKVwiLCAoKSA9PiB7XHJcbiAgICAgIGNvbnN0IHZpZXdwb3J0V2lkdGggPSAzMjA7XHJcblxyXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkod2luZG93LCBcImlubmVyV2lkdGhcIiwge1xyXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICB2YWx1ZTogdmlld3BvcnRXaWR0aCxcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBmYy5hc3NlcnQoXHJcbiAgICAgICAgZmMucHJvcGVydHkoXHJcbiAgICAgICAgICB0cmVuZERhdGFBcmJpdHJhcnksXHJcbiAgICAgICAgICAoY2hhcnREYXRhKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgY29udGFpbmVyIH0gPSByZW5kZXIoXHJcbiAgICAgICAgICAgICAgPFRyZW5kQ2hhcnRcclxuICAgICAgICAgICAgICAgIGluY29tZURhdGE9e2NoYXJ0RGF0YS5pbmNvbWVEYXRhfVxyXG4gICAgICAgICAgICAgICAgZXhwZW5zZURhdGE9e2NoYXJ0RGF0YS5leHBlbnNlRGF0YX1cclxuICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgY2hhcnRDb250YWluZXJzID0gZmluZENoYXJ0Q29udGFpbmVycyhjb250YWluZXIpO1xyXG4gICAgICAgICAgICBleHBlY3QoY2hhcnRDb250YWluZXJzLmxlbmd0aCkudG9CZUdyZWF0ZXJUaGFuKDApO1xyXG5cclxuICAgICAgICAgICAgY2hhcnRDb250YWluZXJzLmZvckVhY2goKGNoYXJ0Q29udGFpbmVyKSA9PiB7XHJcbiAgICAgICAgICAgICAgZXhwZWN0KGNoYXJ0Q29udGFpbmVyKS50b0hhdmVDbGFzcyhcImgtNjRcIik7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICksXHJcbiAgICAgICAgeyBudW1SdW5zOiBnZXROdW1SdW5zKFwiU0xPV1wiKSB9XHJcbiAgICAgICk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBpdChcInNob3VsZCBzd2l0Y2ggdG8gdGFibGV0IGhlaWdodCBhdCBleGFjdGx5IDY0MHB4IChzbSBicmVha3BvaW50KVwiLCAoKSA9PiB7XHJcbiAgICAgIGNvbnN0IHZpZXdwb3J0V2lkdGggPSA2NDA7XHJcblxyXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkod2luZG93LCBcImlubmVyV2lkdGhcIiwge1xyXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICB2YWx1ZTogdmlld3BvcnRXaWR0aCxcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBmYy5hc3NlcnQoXHJcbiAgICAgICAgZmMucHJvcGVydHkoXHJcbiAgICAgICAgICB0cmVuZERhdGFBcmJpdHJhcnksXHJcbiAgICAgICAgICAoY2hhcnREYXRhKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgY29udGFpbmVyIH0gPSByZW5kZXIoXHJcbiAgICAgICAgICAgICAgPFRyZW5kQ2hhcnRcclxuICAgICAgICAgICAgICAgIGluY29tZURhdGE9e2NoYXJ0RGF0YS5pbmNvbWVEYXRhfVxyXG4gICAgICAgICAgICAgICAgZXhwZW5zZURhdGE9e2NoYXJ0RGF0YS5leHBlbnNlRGF0YX1cclxuICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgY2hhcnRDb250YWluZXJzID0gZmluZENoYXJ0Q29udGFpbmVycyhjb250YWluZXIpO1xyXG4gICAgICAgICAgICBleHBlY3QoY2hhcnRDb250YWluZXJzLmxlbmd0aCkudG9CZUdyZWF0ZXJUaGFuKDApO1xyXG5cclxuICAgICAgICAgICAgY2hhcnRDb250YWluZXJzLmZvckVhY2goKGNoYXJ0Q29udGFpbmVyKSA9PiB7XHJcbiAgICAgICAgICAgICAgLy8gU2hvdWxkIGhhdmUgYm90aCBtb2JpbGUgYW5kIHRhYmxldCBjbGFzc2VzXHJcbiAgICAgICAgICAgICAgZXhwZWN0KGNoYXJ0Q29udGFpbmVyKS50b0hhdmVDbGFzcyhcImgtNjRcIik7XHJcbiAgICAgICAgICAgICAgZXhwZWN0KGNoYXJ0Q29udGFpbmVyKS50b0hhdmVDbGFzcyhcInNtOmgtODBcIik7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICksXHJcbiAgICAgICAgeyBudW1SdW5zOiBnZXROdW1SdW5zKFwiU0xPV1wiKSB9XHJcbiAgICAgICk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBpdChcInNob3VsZCBtYWludGFpbiBtaW5pbXVtIGhlaWdodCBhdCA2MzlweCAoanVzdCBiZWxvdyBzbSBicmVha3BvaW50KVwiLCAoKSA9PiB7XHJcbiAgICAgIGNvbnN0IHZpZXdwb3J0V2lkdGggPSA2Mzk7XHJcblxyXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkod2luZG93LCBcImlubmVyV2lkdGhcIiwge1xyXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICB2YWx1ZTogdmlld3BvcnRXaWR0aCxcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBmYy5hc3NlcnQoXHJcbiAgICAgICAgZmMucHJvcGVydHkoXHJcbiAgICAgICAgICB0b3BDYXRlZ29yaWVzQXJiaXRyYXJ5LmZpbHRlcihjYXRzID0+IGNhdHMubGVuZ3RoID49IDIgJiYgY2F0cy5ldmVyeShjID0+IGMuY2F0ZWdvcnlOYW1lLnRyaW0oKS5sZW5ndGggPiAwKSksXHJcbiAgICAgICAgICAoY2F0ZWdvcmllcykgPT4ge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgIGNvbnN0IHsgY29udGFpbmVyIH0gPSByZW5kZXIoXHJcbiAgICAgICAgICAgICAgICA8VG9wQ2F0ZWdvcmllc1dpZGdldCBjYXRlZ29yaWVzPXtjYXRlZ29yaWVzfSAvPlxyXG4gICAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICAgIGNvbnN0IGNoYXJ0Q29udGFpbmVycyA9IGZpbmRDaGFydENvbnRhaW5lcnMoY29udGFpbmVyKTtcclxuICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICBpZiAoY2hhcnRDb250YWluZXJzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgIGNoYXJ0Q29udGFpbmVycy5mb3JFYWNoKChjaGFydENvbnRhaW5lcikgPT4ge1xyXG4gICAgICAgICAgICAgICAgICBleHBlY3QoY2hhcnRDb250YWluZXIpLnRvSGF2ZUNsYXNzKFwiaC02NFwiKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAvLyBDaGFydC5qcyBtYXkgZmFpbCB0byByZW5kZXIgaW4gSlNET00gZm9yIHNvbWUgZWRnZSBjYXNlc1xyXG4gICAgICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIFR5cGVFcnJvciAmJiBlcnJvci5tZXNzYWdlLmluY2x1ZGVzKCdvd25lckRvY3VtZW50JykpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICApLFxyXG4gICAgICAgIHsgbnVtUnVuczogZ2V0TnVtUnVucyhcIlNMT1dcIikgfVxyXG4gICAgICApO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaXQoXCJzaG91bGQgaGFuZGxlIGVtcHR5IGRhdGEgZ3JhY2VmdWxseSB3aGlsZSBtYWludGFpbmluZyBoZWlnaHQgY2xhc3Nlc1wiLCAoKSA9PiB7XHJcbiAgICAgIGZjLmFzc2VydChcclxuICAgICAgICBmYy5wcm9wZXJ0eShcclxuICAgICAgICAgIGZjLmludGVnZXIoeyBtaW46IDMyMCwgbWF4OiA2MzkgfSksXHJcbiAgICAgICAgICAodmlld3BvcnRXaWR0aCkgPT4ge1xyXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkod2luZG93LCBcImlubmVyV2lkdGhcIiwge1xyXG4gICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgICB2YWx1ZTogdmlld3BvcnRXaWR0aCxcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBjb25zdCB7IGNvbnRhaW5lciB9ID0gcmVuZGVyKFxyXG4gICAgICAgICAgICAgIDxUcmVuZENoYXJ0IGluY29tZURhdGE9e1tdfSBleHBlbnNlRGF0YT17W119IC8+XHJcbiAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICAvLyBFdmVuIHdpdGggZW1wdHkgZGF0YSwgdGhlIGNvbXBvbmVudCBzaG91bGQgcmVuZGVyIHdpdGggcHJvcGVyIHN0cnVjdHVyZVxyXG4gICAgICAgICAgICAvLyBUaGUgXCJubyBkYXRhXCIgbWVzc2FnZSBjb250YWluZXIgc2hvdWxkIHN0aWxsIHJlc3BlY3QgaGVpZ2h0IGNvbnN0cmFpbnRzXHJcbiAgICAgICAgICAgIGNvbnN0IGVtcHR5U3RhdGVDb250YWluZXIgPSBjb250YWluZXIucXVlcnlTZWxlY3RvcihcIi5oLTY0XCIpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgaWYgKGVtcHR5U3RhdGVDb250YWluZXIpIHtcclxuICAgICAgICAgICAgICBleHBlY3QoZW1wdHlTdGF0ZUNvbnRhaW5lcikudG9IYXZlQ2xhc3MoXCJoLTY0XCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgKSxcclxuICAgICAgICB7IG51bVJ1bnM6IGdldE51bVJ1bnMoXCJTTE9XXCIpIH1cclxuICAgICAgKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGl0KFwic2hvdWxkIGhhbmRsZSBsb2FkaW5nIHN0YXRlIHdoaWxlIG1haW50YWluaW5nIGhlaWdodCBjbGFzc2VzXCIsICgpID0+IHtcclxuICAgICAgZmMuYXNzZXJ0KFxyXG4gICAgICAgIGZjLnByb3BlcnR5KFxyXG4gICAgICAgICAgZmMuaW50ZWdlcih7IG1pbjogMzIwLCBtYXg6IDYzOSB9KSxcclxuICAgICAgICAgICh2aWV3cG9ydFdpZHRoKSA9PiB7XHJcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3aW5kb3csIFwiaW5uZXJXaWR0aFwiLCB7XHJcbiAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICAgIHZhbHVlOiB2aWV3cG9ydFdpZHRoLFxyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IHsgY29udGFpbmVyIH0gPSByZW5kZXIoXHJcbiAgICAgICAgICAgICAgPFRvcENhdGVnb3JpZXNXaWRnZXQgY2F0ZWdvcmllcz17W119IGxvYWRpbmc9e3RydWV9IC8+XHJcbiAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICAvLyBMb2FkaW5nIHNrZWxldG9uIHNob3VsZCBhbHNvIHJlc3BlY3QgaGVpZ2h0IGNvbnN0cmFpbnRzXHJcbiAgICAgICAgICAgIGNvbnN0IGxvYWRpbmdDb250YWluZXIgPSBjb250YWluZXIucXVlcnlTZWxlY3RvcihcIi5oLTY0XCIpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgaWYgKGxvYWRpbmdDb250YWluZXIpIHtcclxuICAgICAgICAgICAgICBleHBlY3QobG9hZGluZ0NvbnRhaW5lcikudG9IYXZlQ2xhc3MoXCJoLTY0XCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgKSxcclxuICAgICAgICB7IG51bVJ1bnM6IGdldE51bVJ1bnMoXCJTTE9XXCIpIH1cclxuICAgICAgKTtcclxuICAgIH0pO1xyXG4gIH0pO1xyXG5cclxuICBkZXNjcmliZShcIlJlcXVpcmVtZW50IHZhbGlkYXRpb25cIiwgKCkgPT4ge1xyXG4gICAgaXQoXCJ2YWxpZGF0ZXMgUmVxdWlyZW1lbnQgMy4yOiBNaW5pbXVtIDI1NnB4IGNoYXJ0IGhlaWdodCBvbiBtb2JpbGVcIiwgKCkgPT4ge1xyXG4gICAgICBmYy5hc3NlcnQoXHJcbiAgICAgICAgZmMucHJvcGVydHkoXHJcbiAgICAgICAgICBmYy5pbnRlZ2VyKHsgbWluOiAzMjAsIG1heDogNjM5IH0pLFxyXG4gICAgICAgICAgdHJlbmREYXRhQXJiaXRyYXJ5LFxyXG4gICAgICAgICAgKHZpZXdwb3J0V2lkdGgsIGNoYXJ0RGF0YSkgPT4ge1xyXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkod2luZG93LCBcImlubmVyV2lkdGhcIiwge1xyXG4gICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgICB2YWx1ZTogdmlld3BvcnRXaWR0aCxcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkod2luZG93LCBcIm1hdGNoTWVkaWFcIiwge1xyXG4gICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICAgIHZhbHVlOiBqZXN0LmZuKCkubW9ja0ltcGxlbWVudGF0aW9uKChxdWVyeSkgPT4gKHtcclxuICAgICAgICAgICAgICAgIG1hdGNoZXM6IHF1ZXJ5LmluY2x1ZGVzKFwiNjQwcHhcIikgPyBmYWxzZSA6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBtZWRpYTogcXVlcnksXHJcbiAgICAgICAgICAgICAgICBvbmNoYW5nZTogbnVsbCxcclxuICAgICAgICAgICAgICAgIGFkZExpc3RlbmVyOiBqZXN0LmZuKCksXHJcbiAgICAgICAgICAgICAgICByZW1vdmVMaXN0ZW5lcjogamVzdC5mbigpLFxyXG4gICAgICAgICAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcjogamVzdC5mbigpLFxyXG4gICAgICAgICAgICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcjogamVzdC5mbigpLFxyXG4gICAgICAgICAgICAgICAgZGlzcGF0Y2hFdmVudDogamVzdC5mbigpLFxyXG4gICAgICAgICAgICAgIH0pKSxcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAvLyBSZXF1aXJlbWVudCAzLjI6IFdIRU4g0JPRgNCw0YTQuNC6INC+0YLQvtCx0YDQsNC20LDQtdGC0YHRjyDQvdCwINC80L7QsdC40LvRjNC90L7QvCDRg9GB0YLRgNC+0LnRgdGC0LLQtSxcclxuICAgICAgICAgICAgLy8gVEhFINCh0LjRgdGC0LXQvNCwIFNIQUxMINGD0YHRgtCw0L3QsNCy0LvQuNCy0LDRgtGMINCy0YvRgdC+0YLRgyDQs9GA0LDRhNC40LrQsCDQvNC40L3QuNC80YPQvCAyNTZweFxyXG4gICAgICAgICAgICBjb25zdCB7IGNvbnRhaW5lciB9ID0gcmVuZGVyKFxyXG4gICAgICAgICAgICAgIDxUcmVuZENoYXJ0XHJcbiAgICAgICAgICAgICAgICBpbmNvbWVEYXRhPXtjaGFydERhdGEuaW5jb21lRGF0YX1cclxuICAgICAgICAgICAgICAgIGV4cGVuc2VEYXRhPXtjaGFydERhdGEuZXhwZW5zZURhdGF9XHJcbiAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IGNoYXJ0Q29udGFpbmVycyA9IGZpbmRDaGFydENvbnRhaW5lcnMoY29udGFpbmVyKTtcclxuICAgICAgICAgICAgZXhwZWN0KGNoYXJ0Q29udGFpbmVycy5sZW5ndGgpLnRvQmVHcmVhdGVyVGhhbigwKTtcclxuXHJcbiAgICAgICAgICAgIGNoYXJ0Q29udGFpbmVycy5mb3JFYWNoKChjaGFydENvbnRhaW5lcikgPT4ge1xyXG4gICAgICAgICAgICAgIC8vIGgtNjQgY2xhc3MgZW5zdXJlcyAyNTZweCBoZWlnaHQgKDE2cmVtICogMTZweCA9IDI1NnB4KVxyXG4gICAgICAgICAgICAgIGV4cGVjdChjaGFydENvbnRhaW5lcikudG9IYXZlQ2xhc3MoXCJoLTY0XCIpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICApLFxyXG4gICAgICAgIHsgbnVtUnVuczogZ2V0TnVtUnVucyhcIk1FRElVTVwiKSB9XHJcbiAgICAgICk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBpdChcInZhbGlkYXRlcyB0aGF0IGNoYXJ0IGhlaWdodCBpcyBjb25zaXN0ZW50IGFjcm9zcyBkaWZmZXJlbnQgZGF0YSBzaXplc1wiLCAoKSA9PiB7XHJcbiAgICAgIGZjLmFzc2VydChcclxuICAgICAgICBmYy5wcm9wZXJ0eShcclxuICAgICAgICAgIGZjLmludGVnZXIoeyBtaW46IDMyMCwgbWF4OiA2MzkgfSksXHJcbiAgICAgICAgICBmYy5pbnRlZ2VyKHsgbWluOiAxLCBtYXg6IDEwMCB9KSwgLy8gTnVtYmVyIG9mIGRhdGEgcG9pbnRzXHJcbiAgICAgICAgICAodmlld3BvcnRXaWR0aCwgZGF0YVBvaW50cykgPT4ge1xyXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkod2luZG93LCBcImlubmVyV2lkdGhcIiwge1xyXG4gICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgICB2YWx1ZTogdmlld3BvcnRXaWR0aCxcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAvLyBHZW5lcmF0ZSBkYXRhIHdpdGggc3BlY2lmaWVkIG51bWJlciBvZiBwb2ludHNcclxuICAgICAgICAgICAgY29uc3QgaW5jb21lRGF0YSA9IEFycmF5LmZyb20oeyBsZW5ndGg6IGRhdGFQb2ludHMgfSwgKF8sIGkpID0+ICh7XHJcbiAgICAgICAgICAgICAgZGF0ZTogYDIwMjQtMDEtJHtTdHJpbmcoaSArIDEpLnBhZFN0YXJ0KDIsICcwJyl9YCxcclxuICAgICAgICAgICAgICBhbW91bnQ6IE1hdGgucmFuZG9tKCkgKiAxMDAwMCxcclxuICAgICAgICAgICAgfSkpO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgZXhwZW5zZURhdGEgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiBkYXRhUG9pbnRzIH0sIChfLCBpKSA9PiAoe1xyXG4gICAgICAgICAgICAgIGRhdGU6IGAyMDI0LTAxLSR7U3RyaW5nKGkgKyAxKS5wYWRTdGFydCgyLCAnMCcpfWAsXHJcbiAgICAgICAgICAgICAgYW1vdW50OiBNYXRoLnJhbmRvbSgpICogMTAwMDAsXHJcbiAgICAgICAgICAgIH0pKTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IHsgY29udGFpbmVyIH0gPSByZW5kZXIoXHJcbiAgICAgICAgICAgICAgPFRyZW5kQ2hhcnQgaW5jb21lRGF0YT17aW5jb21lRGF0YX0gZXhwZW5zZURhdGE9e2V4cGVuc2VEYXRhfSAvPlxyXG4gICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgY2hhcnRDb250YWluZXJzID0gZmluZENoYXJ0Q29udGFpbmVycyhjb250YWluZXIpO1xyXG4gICAgICAgICAgICBleHBlY3QoY2hhcnRDb250YWluZXJzLmxlbmd0aCkudG9CZUdyZWF0ZXJUaGFuKDApO1xyXG5cclxuICAgICAgICAgICAgLy8gSGVpZ2h0IHNob3VsZCBiZSBjb25zaXN0ZW50IHJlZ2FyZGxlc3Mgb2YgZGF0YSBzaXplXHJcbiAgICAgICAgICAgIGNoYXJ0Q29udGFpbmVycy5mb3JFYWNoKChjaGFydENvbnRhaW5lcikgPT4ge1xyXG4gICAgICAgICAgICAgIGV4cGVjdChjaGFydENvbnRhaW5lcikudG9IYXZlQ2xhc3MoXCJoLTY0XCIpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICApLFxyXG4gICAgICAgIHsgbnVtUnVuczogZ2V0TnVtUnVucyhcIkZBU1RcIikgfVxyXG4gICAgICApO1xyXG4gICAgfSk7XHJcbiAgfSk7XHJcblxyXG4gIGRlc2NyaWJlKFwiR2VuZXJhbCBwcm9wZXJ0eSB2YWxpZGF0aW9uXCIsICgpID0+IHtcclxuICAgIGl0KFwic2hvdWxkIHZlcmlmeSBhbGwgY2hhcnQgY29tcG9uZW50cyB1c2UgcmVzcG9uc2l2ZSBoZWlnaHQgY2xhc3Nlc1wiLCAoKSA9PiB7XHJcbiAgICAgIGZjLmFzc2VydChcclxuICAgICAgICBmYy5wcm9wZXJ0eShcclxuICAgICAgICAgIGZjLmludGVnZXIoeyBtaW46IDMyMCwgbWF4OiAxNDQwIH0pLFxyXG4gICAgICAgICAgdHJlbmREYXRhQXJiaXRyYXJ5LFxyXG4gICAgICAgICAgdG9wQ2F0ZWdvcmllc0FyYml0cmFyeS5maWx0ZXIoY2F0cyA9PiBjYXRzLmxlbmd0aCA+PSAyICYmIGNhdHMuZXZlcnkoYyA9PiBjLmNhdGVnb3J5TmFtZS50cmltKCkubGVuZ3RoID4gMCkpLFxyXG4gICAgICAgICAgKHZpZXdwb3J0V2lkdGgsIHRyZW5kRGF0YSwgY2F0ZWdvcmllcykgPT4ge1xyXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkod2luZG93LCBcImlubmVyV2lkdGhcIiwge1xyXG4gICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgICB2YWx1ZTogdmlld3BvcnRXaWR0aCxcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAvLyBUZXN0IGJvdGggY2hhcnQgY29tcG9uZW50c1xyXG4gICAgICAgICAgICBjb25zdCB7IGNvbnRhaW5lcjogdHJlbmRDb250YWluZXIgfSA9IHJlbmRlcihcclxuICAgICAgICAgICAgICA8VHJlbmRDaGFydFxyXG4gICAgICAgICAgICAgICAgaW5jb21lRGF0YT17dHJlbmREYXRhLmluY29tZURhdGF9XHJcbiAgICAgICAgICAgICAgICBleHBlbnNlRGF0YT17dHJlbmREYXRhLmV4cGVuc2VEYXRhfVxyXG4gICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgIGNvbnN0IHsgY29udGFpbmVyOiBjYXRlZ29yaWVzQ29udGFpbmVyIH0gPSByZW5kZXIoXHJcbiAgICAgICAgICAgICAgICA8VG9wQ2F0ZWdvcmllc1dpZGdldCBjYXRlZ29yaWVzPXtjYXRlZ29yaWVzfSAvPlxyXG4gICAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICAgIC8vIEJvdGggc2hvdWxkIGhhdmUgcmVzcG9uc2l2ZSBoZWlnaHQgY2xhc3Nlc1xyXG4gICAgICAgICAgICAgIGNvbnN0IHRyZW5kQ2hhcnRzID0gZmluZENoYXJ0Q29udGFpbmVycyh0cmVuZENvbnRhaW5lcik7XHJcbiAgICAgICAgICAgICAgY29uc3QgY2F0ZWdvcnlDaGFydHMgPSBmaW5kQ2hhcnRDb250YWluZXJzKGNhdGVnb3JpZXNDb250YWluZXIpO1xyXG5cclxuICAgICAgICAgICAgICBleHBlY3QodHJlbmRDaGFydHMubGVuZ3RoKS50b0JlR3JlYXRlclRoYW4oMCk7XHJcblxyXG4gICAgICAgICAgICAgIFsuLi50cmVuZENoYXJ0cywgLi4uY2F0ZWdvcnlDaGFydHNdLmZvckVhY2goKGNoYXJ0KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAvLyBBbGwgY2hhcnRzIG11c3QgaGF2ZSBiYXNlIG1vYmlsZSBoZWlnaHRcclxuICAgICAgICAgICAgICAgIGV4cGVjdChjaGFydCkudG9IYXZlQ2xhc3MoXCJoLTY0XCIpO1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAvLyBBbGwgY2hhcnRzIG11c3QgaGF2ZSByZXNwb25zaXZlIGNsYXNzZXNcclxuICAgICAgICAgICAgICAgIGV4cGVjdChjaGFydCkudG9IYXZlQ2xhc3MoXCJzbTpoLTgwXCIpO1xyXG4gICAgICAgICAgICAgICAgZXhwZWN0KGNoYXJ0KS50b0hhdmVDbGFzcyhcImxnOmgtOTZcIik7XHJcbiAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgLy8gQ2hhcnQuanMgbWF5IGZhaWwgdG8gcmVuZGVyIGluIEpTRE9NIGZvciBzb21lIGVkZ2UgY2FzZXNcclxuICAgICAgICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBUeXBlRXJyb3IgJiYgZXJyb3IubWVzc2FnZS5pbmNsdWRlcygnb3duZXJEb2N1bWVudCcpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBBdCBsZWFzdCB2ZXJpZnkgVHJlbmRDaGFydCB3b3Jrc1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdHJlbmRDaGFydHMgPSBmaW5kQ2hhcnRDb250YWluZXJzKHRyZW5kQ29udGFpbmVyKTtcclxuICAgICAgICAgICAgICAgIGV4cGVjdCh0cmVuZENoYXJ0cy5sZW5ndGgpLnRvQmVHcmVhdGVyVGhhbigwKTtcclxuICAgICAgICAgICAgICAgIHRyZW5kQ2hhcnRzLmZvckVhY2goKGNoYXJ0KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgIGV4cGVjdChjaGFydCkudG9IYXZlQ2xhc3MoXCJoLTY0XCIpO1xyXG4gICAgICAgICAgICAgICAgICBleHBlY3QoY2hhcnQpLnRvSGF2ZUNsYXNzKFwic206aC04MFwiKTtcclxuICAgICAgICAgICAgICAgICAgZXhwZWN0KGNoYXJ0KS50b0hhdmVDbGFzcyhcImxnOmgtOTZcIik7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICApLFxyXG4gICAgICAgIHsgbnVtUnVuczogZ2V0TnVtUnVucyhcIkZBU1RcIikgfVxyXG4gICAgICApO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaXQoXCJzaG91bGQgZW5zdXJlIGNoYXJ0IGhlaWdodCBjbGFzc2VzIGZvbGxvdyBtb2JpbGUtZmlyc3QgYXBwcm9hY2hcIiwgKCkgPT4ge1xyXG4gICAgICBmYy5hc3NlcnQoXHJcbiAgICAgICAgZmMucHJvcGVydHkoXHJcbiAgICAgICAgICB0cmVuZERhdGFBcmJpdHJhcnksXHJcbiAgICAgICAgICAoY2hhcnREYXRhKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgY29udGFpbmVyIH0gPSByZW5kZXIoXHJcbiAgICAgICAgICAgICAgPFRyZW5kQ2hhcnRcclxuICAgICAgICAgICAgICAgIGluY29tZURhdGE9e2NoYXJ0RGF0YS5pbmNvbWVEYXRhfVxyXG4gICAgICAgICAgICAgICAgZXhwZW5zZURhdGE9e2NoYXJ0RGF0YS5leHBlbnNlRGF0YX1cclxuICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgY2hhcnRDb250YWluZXJzID0gZmluZENoYXJ0Q29udGFpbmVycyhjb250YWluZXIpO1xyXG4gICAgICAgICAgICBleHBlY3QoY2hhcnRDb250YWluZXJzLmxlbmd0aCkudG9CZUdyZWF0ZXJUaGFuKDApO1xyXG5cclxuICAgICAgICAgICAgY2hhcnRDb250YWluZXJzLmZvckVhY2goKGNoYXJ0Q29udGFpbmVyKSA9PiB7XHJcbiAgICAgICAgICAgICAgLy8gTW9iaWxlLWZpcnN0OiBiYXNlIGNsYXNzIChoLTY0KSBzaG91bGQgYWx3YXlzIGJlIHByZXNlbnRcclxuICAgICAgICAgICAgICBleHBlY3QoY2hhcnRDb250YWluZXIpLnRvSGF2ZUNsYXNzKFwiaC02NFwiKTtcclxuICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAvLyBSZXNwb25zaXZlIGNsYXNzZXMgc2hvdWxkIGJlIHByZWZpeGVkIChzbTosIGxnOilcclxuICAgICAgICAgICAgICBjb25zdCBjbGFzc2VzID0gY2hhcnRDb250YWluZXIuY2xhc3NOYW1lO1xyXG4gICAgICAgICAgICAgIGV4cGVjdChjbGFzc2VzKS50b01hdGNoKC9cXGJoLTY0XFxiLyk7XHJcbiAgICAgICAgICAgICAgZXhwZWN0KGNsYXNzZXMpLnRvTWF0Y2goL1xcYnNtOmgtODBcXGIvKTtcclxuICAgICAgICAgICAgICBleHBlY3QoY2xhc3NlcykudG9NYXRjaCgvXFxibGc6aC05NlxcYi8pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICApLFxyXG4gICAgICAgIHsgbnVtUnVuczogZ2V0TnVtUnVucyhcIkZBU1RcIikgfVxyXG4gICAgICApO1xyXG4gICAgfSk7XHJcbiAgfSk7XHJcbn0pO1xyXG4iXSwibmFtZXMiOlsiTUlOX0NIQVJUX0hFSUdIVF9NT0JJTEUiLCJnZXRFbGVtZW50SGVpZ2h0IiwiZWxlbWVudCIsInJlY3QiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJoZWlnaHQiLCJmaW5kQ2hhcnRDb250YWluZXJzIiwiY29udGFpbmVyIiwic2VsZWN0b3JzIiwiZWxlbWVudHMiLCJmb3JFYWNoIiwic2VsZWN0b3IiLCJmb3VuZCIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJwdXNoIiwiQXJyYXkiLCJmcm9tIiwidHJlbmREYXRhQXJiaXRyYXJ5IiwiZmMiLCJyZWNvcmQiLCJpbmNvbWVEYXRhIiwiYXJyYXkiLCJkYXRlIiwibWFwIiwiZCIsInRvSVNPU3RyaW5nIiwic3BsaXQiLCJhbW91bnQiLCJmbG9hdCIsIm1pbiIsIm1heCIsIm5vTmFOIiwibWluTGVuZ3RoIiwibWF4TGVuZ3RoIiwiZXhwZW5zZURhdGEiLCJ0b3BDYXRlZ29yaWVzQXJiaXRyYXJ5IiwiY2F0ZWdvcnlOYW1lIiwic3RyaW5nIiwiY2F0ZWdvcnlJY29uIiwiY29uc3RhbnRGcm9tIiwidG90YWxBbW91bnQiLCJwZXJjZW50YWdlIiwiZGVzY3JpYmUiLCJpdCIsImFzc2VydCIsInByb3BlcnR5IiwiaW50ZWdlciIsInZpZXdwb3J0V2lkdGgiLCJjaGFydERhdGEiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsIndpbmRvdyIsIndyaXRhYmxlIiwiY29uZmlndXJhYmxlIiwidmFsdWUiLCJqZXN0IiwiZm4iLCJtb2NrSW1wbGVtZW50YXRpb24iLCJxdWVyeSIsIm1hdGNoZXMiLCJpbmNsdWRlcyIsIm1lZGlhIiwib25jaGFuZ2UiLCJhZGRMaXN0ZW5lciIsInJlbW92ZUxpc3RlbmVyIiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJkaXNwYXRjaEV2ZW50IiwicmVuZGVyIiwiVHJlbmRDaGFydCIsImNoYXJ0Q29udGFpbmVycyIsImV4cGVjdCIsImxlbmd0aCIsInRvQmVHcmVhdGVyVGhhbiIsImNoYXJ0Q29udGFpbmVyIiwidG9IYXZlQ2xhc3MiLCJudW1SdW5zIiwiZ2V0TnVtUnVucyIsImZpbHRlciIsImNhdHMiLCJldmVyeSIsImMiLCJ0cmltIiwiY2F0ZWdvcmllcyIsIlRvcENhdGVnb3JpZXNXaWRnZXQiLCJlcnJvciIsIlR5cGVFcnJvciIsIm1lc3NhZ2UiLCJjaGFydFJlc3BvbnNpdmVDb25maWciLCJtb2JpbGUiLCJ0b0JlIiwidG9CZUdyZWF0ZXJUaGFuT3JFcXVhbCIsInRvQmVMZXNzVGhhbiIsInRhYmxldCIsImRlc2t0b3AiLCJlbXB0eVN0YXRlQ29udGFpbmVyIiwicXVlcnlTZWxlY3RvciIsImxvYWRpbmciLCJsb2FkaW5nQ29udGFpbmVyIiwiZGF0YVBvaW50cyIsIl8iLCJpIiwiU3RyaW5nIiwicGFkU3RhcnQiLCJNYXRoIiwicmFuZG9tIiwidHJlbmREYXRhIiwidHJlbmRDb250YWluZXIiLCJjYXRlZ29yaWVzQ29udGFpbmVyIiwidHJlbmRDaGFydHMiLCJjYXRlZ29yeUNoYXJ0cyIsImNoYXJ0IiwiY2xhc3NlcyIsImNsYXNzTmFtZSIsInRvTWF0Y2giXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7OztDQVFDOzs7Ozs4REFFaUI7d0JBQ0s7a0VBQ1I7NEJBQ1k7cUNBQ1M7a0NBQ0U7b0NBQ0M7Ozs7OztBQUV2QyxrRUFBa0U7QUFDbEUsTUFBTUEsMEJBQTBCO0FBRWhDLHVEQUF1RDtBQUN2RCxNQUFNQyxtQkFBbUIsQ0FBQ0M7SUFDeEIsTUFBTUMsT0FBT0Qs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