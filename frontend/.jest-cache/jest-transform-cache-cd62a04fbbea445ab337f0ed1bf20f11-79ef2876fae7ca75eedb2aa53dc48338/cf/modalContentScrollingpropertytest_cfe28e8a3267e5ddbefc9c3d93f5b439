e55dbdd3ee667f2c0495ed7b92873ae8
/**
 * Property-Based Test — Modal Content Scrolling
 * 
 * **Свойство 11: Прокрутка содержимого модальных окон**
 * **Валидирует: Требования 4.2**
 * 
 * For any modal window with content exceeding viewport height,
 * vertical scrolling should be available (overflow-y: auto).
 * The modal content container should have max-h-[85vh] to ensure
 * scrollability when content is too tall.
 * 
 * NOTE: Skipped in CI due to performance (renders complex Modal with large content)
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _jsxruntime = require("react/jsx-runtime");
const _react = /*#__PURE__*/ _interop_require_default(require("react"));
const _react1 = require("@testing-library/react");
const _fastcheck = /*#__PURE__*/ _interop_require_default(require("fast-check"));
const _Modal = require("../../src/components/ui/Modal");
const _propertytestconfig = require("./property-test-config");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
// Skip in CI environment
const describeOrSkip = process.env.CI === "true" ? describe.skip : describe;
// Maximum height of modal content (85% of viewport height)
const MAX_MODAL_HEIGHT_VH = 85;
// Helper function to get computed styles
const getComputedOverflow = (element)=>{
    const computedStyle = window.getComputedStyle(element);
    return computedStyle.overflowY;
};
// Helper function to check if element has max-height constraint
const hasMaxHeightConstraint = (element)=>{
    const classes = element.className;
    return classes.includes("max-h-[85vh]");
};
// Helper function to find modal content container
const findModalContentContainer = (container)=>{
    // Look for the div with overflow-y-auto and max-h-[85vh]
    const contentContainer = container.querySelector(".overflow-y-auto.max-h-\\[85vh\\]");
    if (contentContainer) return contentContainer;
    // Fallback: look for any element with max-h-[85vh]
    return container.querySelector("[class*='max-h-[85vh]']");
};
// Generator for content that exceeds viewport height
const tallContentArbitrary = _fastcheck.default.array(_fastcheck.default.string({
    minLength: 50,
    maxLength: 200
}), {
    minLength: 20,
    maxLength: 100
});
// Generator for content that fits within viewport
const shortContentArbitrary = _fastcheck.default.array(_fastcheck.default.string({
    minLength: 10,
    maxLength: 50
}), {
    minLength: 1,
    maxLength: 5
});
describeOrSkip("Property: Modal Content Scrolling", ()=>{
    describe("Overflow-y auto property", ()=>{
        it("should have overflow-y: auto on modal content container", ()=>{
            jest.setTimeout((0, _propertytestconfig.getTimeout)("SLOW"));
            _fastcheck.default.assert(_fastcheck.default.property(_fastcheck.default.constantFrom("sm", "md", "lg", "xl"), _fastcheck.default.array(_fastcheck.default.string({
                minLength: 10,
                maxLength: 100
            }), {
                minLength: 1,
                maxLength: 50
            }), (size, contentLines)=>{
                const { container } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_Modal.Modal, {
                    isOpen: true,
                    onClose: ()=>{},
                    size: size,
                    children: /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                        children: contentLines.map((line, index)=>/*#__PURE__*/ (0, _jsxruntime.jsx)("p", {
                                children: line
                            }, index))
                    })
                }));
                const contentContainer = findModalContentContainer(container);
                if (contentContainer) {
                    // Should have overflow-y-auto class
                    expect(contentContainer.className).toMatch(/overflow-y-auto/);
                    // Computed style should be 'auto' or 'scroll'
                    const overflowY = getComputedOverflow(contentContainer);
                    expect([
                        "auto",
                        "scroll"
                    ]).toContain(overflowY);
                }
            }), {
                numRuns: (0, _propertytestconfig.getNumRuns)("MEDIUM")
            });
        });
        it("should have overflow-y: auto regardless of content length", ()=>{
            jest.setTimeout((0, _propertytestconfig.getTimeout)("SLOW"));
            _fastcheck.default.assert(_fastcheck.default.property(_fastcheck.default.oneof(shortContentArbitrary, tallContentArbitrary), _fastcheck.default.constantFrom("sm", "md", "lg", "xl"), (contentLines, size)=>{
                const { container } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_Modal.Modal, {
                    isOpen: true,
                    onClose: ()=>{},
                    size: size,
                    children: /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                        children: contentLines.map((line, index)=>/*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                                style: {
                                    minHeight: "50px"
                                },
                                children: line
                            }, index))
                    })
                }));
                const contentContainer = findModalContentContainer(container);
                if (contentContainer) {
                    expect(contentContainer.className).toMatch(/overflow-y-auto/);
                }
            }), {
                numRuns: (0, _propertytestconfig.getNumRuns)("MEDIUM")
            });
        });
    });
    describe("Max-height constraint", ()=>{
        it("should have max-h-[85vh] class on content container", ()=>{
            jest.setTimeout((0, _propertytestconfig.getTimeout)("SLOW"));
            _fastcheck.default.assert(_fastcheck.default.property(_fastcheck.default.constantFrom("sm", "md", "lg", "xl"), _fastcheck.default.array(_fastcheck.default.string({
                minLength: 10,
                maxLength: 100
            }), {
                minLength: 1,
                maxLength: 50
            }), (size, contentLines)=>{
                const { container } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_Modal.Modal, {
                    isOpen: true,
                    onClose: ()=>{},
                    size: size,
                    children: /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                        children: contentLines.map((line, index)=>/*#__PURE__*/ (0, _jsxruntime.jsx)("p", {
                                children: line
                            }, index))
                    })
                }));
                const contentContainer = findModalContentContainer(container);
                if (contentContainer) {
                    // Should have max-h-[85vh] class
                    expect(hasMaxHeightConstraint(contentContainer)).toBe(true);
                    expect(contentContainer.className).toMatch(/max-h-\[85vh\]/);
                }
            }), {
                numRuns: (0, _propertytestconfig.getNumRuns)("MEDIUM")
            });
        });
        it("should maintain max-h-[85vh] across all modal sizes", ()=>{
            jest.setTimeout((0, _propertytestconfig.getTimeout)("SLOW"));
            const sizes = [
                "sm",
                "md",
                "lg",
                "xl"
            ];
            _fastcheck.default.assert(_fastcheck.default.property(_fastcheck.default.array(_fastcheck.default.string({
                minLength: 20,
                maxLength: 100
            }), {
                minLength: 10,
                maxLength: 30
            }), (contentLines)=>{
                sizes.forEach((size)=>{
                    const { container } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_Modal.Modal, {
                        isOpen: true,
                        onClose: ()=>{},
                        size: size,
                        children: /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                            children: contentLines.map((line, index)=>/*#__PURE__*/ (0, _jsxruntime.jsx)("p", {
                                    children: line
                                }, index))
                        })
                    }));
                    const contentContainer = findModalContentContainer(container);
                    if (contentContainer) {
                        expect(contentContainer.className).toMatch(/max-h-\[85vh\]/);
                    }
                });
            }), {
                numRuns: (0, _propertytestconfig.getNumRuns)("FAST")
            });
        });
        it("should have max-h-[85vh] regardless of viewport width", ()=>{
            jest.setTimeout((0, _propertytestconfig.getTimeout)("SLOW"));
            _fastcheck.default.assert(_fastcheck.default.property(_fastcheck.default.integer({
                min: 320,
                max: 1440
            }), _fastcheck.default.constantFrom("sm", "md", "lg", "xl"), (viewportWidth, size)=>{
                // Mock window.innerWidth
                Object.defineProperty(window, "innerWidth", {
                    writable: true,
                    configurable: true,
                    value: viewportWidth
                });
                const { container } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_Modal.Modal, {
                    isOpen: true,
                    onClose: ()=>{},
                    size: size,
                    children: /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                        children: /*#__PURE__*/ (0, _jsxruntime.jsx)("p", {
                            children: "Test content"
                        })
                    })
                }));
                const contentContainer = findModalContentContainer(container);
                if (contentContainer) {
                    expect(contentContainer.className).toMatch(/max-h-\[85vh\]/);
                }
            }), {
                numRuns: (0, _propertytestconfig.getNumRuns)("MEDIUM")
            });
        });
    });
    describe("Scrollability with tall content", ()=>{
        it("should enable scrolling when content exceeds max-height", ()=>{
            jest.setTimeout((0, _propertytestconfig.getTimeout)("SLOW"));
            _fastcheck.default.assert(_fastcheck.default.property(tallContentArbitrary, _fastcheck.default.constantFrom("sm", "md", "lg", "xl"), (contentLines, size)=>{
                const { container } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_Modal.Modal, {
                    isOpen: true,
                    onClose: ()=>{},
                    size: size,
                    children: /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                        children: contentLines.map((line, index)=>/*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                                style: {
                                    minHeight: "100px",
                                    padding: "20px"
                                },
                                children: line
                            }, index))
                    })
                }));
                const contentContainer = findModalContentContainer(container);
                if (contentContainer) {
                    // Should have both overflow-y-auto and max-h-[85vh]
                    expect(contentContainer.className).toMatch(/overflow-y-auto/);
                    expect(contentContainer.className).toMatch(/max-h-\[85vh\]/);
                    // Overflow should be auto or scroll
                    const overflowY = getComputedOverflow(contentContainer);
                    expect([
                        "auto",
                        "scroll"
                    ]).toContain(overflowY);
                }
            }), {
                numRuns: (0, _propertytestconfig.getNumRuns)("FAST")
            });
        });
        it("should handle forms with many fields", ()=>{
            jest.setTimeout((0, _propertytestconfig.getTimeout)("SLOW"));
            _fastcheck.default.assert(_fastcheck.default.property(_fastcheck.default.array(_fastcheck.default.record({
                label: _fastcheck.default.string({
                    minLength: 5,
                    maxLength: 30
                }),
                type: _fastcheck.default.constantFrom("text", "email", "number", "textarea")
            }), {
                minLength: 10,
                maxLength: 20
            }), _fastcheck.default.constantFrom("sm", "md", "lg", "xl"), (fields, size)=>{
                const { container } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_Modal.Modal, {
                    isOpen: true,
                    onClose: ()=>{},
                    size: size,
                    title: "Form",
                    children: /*#__PURE__*/ (0, _jsxruntime.jsx)("form", {
                        children: fields.map((field, index)=>/*#__PURE__*/ (0, _jsxruntime.jsxs)("div", {
                                style: {
                                    marginBottom: "20px"
                                },
                                children: [
                                    /*#__PURE__*/ (0, _jsxruntime.jsx)("label", {
                                        children: field.label
                                    }),
                                    field.type === "textarea" ? /*#__PURE__*/ (0, _jsxruntime.jsx)("textarea", {
                                        style: {
                                            width: "100%",
                                            height: "80px"
                                        }
                                    }) : /*#__PURE__*/ (0, _jsxruntime.jsx)("input", {
                                        type: field.type,
                                        style: {
                                            width: "100%"
                                        }
                                    })
                                ]
                            }, index))
                    })
                }));
                const contentContainer = findModalContentContainer(container);
                if (contentContainer) {
                    // Form should be scrollable
                    expect(contentContainer.className).toMatch(/overflow-y-auto/);
                    expect(contentContainer.className).toMatch(/max-h-\[85vh\]/);
                }
            }), {
                numRuns: (0, _propertytestconfig.getNumRuns)("FAST")
            });
        });
        it("should handle nested content structures", ()=>{
            jest.setTimeout((0, _propertytestconfig.getTimeout)("SLOW"));
            _fastcheck.default.assert(_fastcheck.default.property(_fastcheck.default.array(_fastcheck.default.record({
                title: _fastcheck.default.string({
                    minLength: 10,
                    maxLength: 50
                }),
                items: _fastcheck.default.array(_fastcheck.default.string({
                    minLength: 20,
                    maxLength: 100
                }), {
                    minLength: 3,
                    maxLength: 10
                })
            }), {
                minLength: 5,
                maxLength: 15
            }), (sections)=>{
                const { container } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_Modal.Modal, {
                    isOpen: true,
                    onClose: ()=>{},
                    size: "lg",
                    children: /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                        children: sections.map((section, sectionIndex)=>/*#__PURE__*/ (0, _jsxruntime.jsxs)("div", {
                                style: {
                                    marginBottom: "30px"
                                },
                                children: [
                                    /*#__PURE__*/ (0, _jsxruntime.jsx)("h3", {
                                        children: section.title
                                    }),
                                    /*#__PURE__*/ (0, _jsxruntime.jsx)("ul", {
                                        children: section.items.map((item, itemIndex)=>/*#__PURE__*/ (0, _jsxruntime.jsx)("li", {
                                                style: {
                                                    padding: "10px"
                                                },
                                                children: item
                                            }, itemIndex))
                                    })
                                ]
                            }, sectionIndex))
                    })
                }));
                const contentContainer = findModalContentContainer(container);
                if (contentContainer) {
                    expect(contentContainer.className).toMatch(/overflow-y-auto/);
                    expect(contentContainer.className).toMatch(/max-h-\[85vh\]/);
                }
            }), {
                numRuns: (0, _propertytestconfig.getNumRuns)("FAST")
            });
        });
    });
    describe("Edge cases", ()=>{
        it("should handle modal with minimal content", ()=>{
            jest.setTimeout((0, _propertytestconfig.getTimeout)("SLOW"));
            _fastcheck.default.assert(_fastcheck.default.property(_fastcheck.default.constantFrom("sm", "md", "lg", "xl"), _fastcheck.default.string({
                minLength: 1,
                maxLength: 20
            }), (size, content)=>{
                const { container } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_Modal.Modal, {
                    isOpen: true,
                    onClose: ()=>{},
                    size: size,
                    children: /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                        children: content
                    })
                }));
                const contentContainer = findModalContentContainer(container);
                if (contentContainer) {
                    // Even with minimal content, scrolling properties should be present
                    expect(contentContainer.className).toMatch(/overflow-y-auto/);
                    expect(contentContainer.className).toMatch(/max-h-\[85vh\]/);
                }
            }), {
                numRuns: (0, _propertytestconfig.getNumRuns)("FAST")
            });
        });
        it("should handle modal with empty content", ()=>{
            jest.setTimeout((0, _propertytestconfig.getTimeout)("SLOW"));
            const sizes = [
                "sm",
                "md",
                "lg",
                "xl"
            ];
            sizes.forEach((size)=>{
                const { container } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_Modal.Modal, {
                    isOpen: true,
                    onClose: ()=>{},
                    size: size,
                    children: /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {})
                }));
                const contentContainer = findModalContentContainer(container);
                if (contentContainer) {
                    expect(contentContainer.className).toMatch(/overflow-y-auto/);
                    expect(contentContainer.className).toMatch(/max-h-\[85vh\]/);
                }
            });
        });
        it("should handle modal with title and content", ()=>{
            jest.setTimeout((0, _propertytestconfig.getTimeout)("SLOW"));
            _fastcheck.default.assert(_fastcheck.default.property(_fastcheck.default.string({
                minLength: 5,
                maxLength: 50
            }), _fastcheck.default.array(_fastcheck.default.string({
                minLength: 20,
                maxLength: 100
            }), {
                minLength: 5,
                maxLength: 20
            }), _fastcheck.default.constantFrom("sm", "md", "lg", "xl"), (title, contentLines, size)=>{
                const { container } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_Modal.Modal, {
                    isOpen: true,
                    onClose: ()=>{},
                    title: title,
                    size: size,
                    children: /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                        children: contentLines.map((line, index)=>/*#__PURE__*/ (0, _jsxruntime.jsx)("p", {
                                children: line
                            }, index))
                    })
                }));
                const contentContainer = findModalContentContainer(container);
                if (contentContainer) {
                    expect(contentContainer.className).toMatch(/overflow-y-auto/);
                    expect(contentContainer.className).toMatch(/max-h-\[85vh\]/);
                }
            }), {
                numRuns: (0, _propertytestconfig.getNumRuns)("FAST")
            });
        });
        it("should handle modal with images and mixed content", ()=>{
            jest.setTimeout((0, _propertytestconfig.getTimeout)("SLOW"));
            _fastcheck.default.assert(_fastcheck.default.property(_fastcheck.default.array(_fastcheck.default.record({
                type: _fastcheck.default.constantFrom("text", "image", "list"),
                content: _fastcheck.default.string({
                    minLength: 10,
                    maxLength: 100
                })
            }), {
                minLength: 5,
                maxLength: 15
            }), (contentBlocks)=>{
                const { container } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_Modal.Modal, {
                    isOpen: true,
                    onClose: ()=>{},
                    size: "lg",
                    children: /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                        children: contentBlocks.map((block, index)=>{
                            if (block.type === "text") {
                                return /*#__PURE__*/ (0, _jsxruntime.jsx)("p", {
                                    children: block.content
                                }, index);
                            } else if (block.type === "image") {
                                return /*#__PURE__*/ (0, _jsxruntime.jsxs)("div", {
                                    style: {
                                        height: "200px",
                                        background: "#ccc"
                                    },
                                    children: [
                                        "Image placeholder: ",
                                        block.content
                                    ]
                                }, index);
                            } else {
                                return /*#__PURE__*/ (0, _jsxruntime.jsx)("ul", {
                                    children: /*#__PURE__*/ (0, _jsxruntime.jsx)("li", {
                                        children: block.content
                                    })
                                }, index);
                            }
                        })
                    })
                }));
                const contentContainer = findModalContentContainer(container);
                if (contentContainer) {
                    expect(contentContainer.className).toMatch(/overflow-y-auto/);
                    expect(contentContainer.className).toMatch(/max-h-\[85vh\]/);
                }
            }), {
                numRuns: (0, _propertytestconfig.getNumRuns)("FAST")
            });
        });
        it("should handle modal on different viewport heights", ()=>{
            jest.setTimeout((0, _propertytestconfig.getTimeout)("SLOW"));
            _fastcheck.default.assert(_fastcheck.default.property(_fastcheck.default.integer({
                min: 480,
                max: 1080
            }), _fastcheck.default.array(_fastcheck.default.string({
                minLength: 50,
                maxLength: 150
            }), {
                minLength: 10,
                maxLength: 30
            }), (viewportHeight, contentLines)=>{
                // Mock window.innerHeight
                Object.defineProperty(window, "innerHeight", {
                    writable: true,
                    configurable: true,
                    value: viewportHeight
                });
                const { container } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_Modal.Modal, {
                    isOpen: true,
                    onClose: ()=>{},
                    size: "md",
                    children: /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                        children: contentLines.map((line, index)=>/*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                                style: {
                                    minHeight: "60px"
                                },
                                children: line
                            }, index))
                    })
                }));
                const contentContainer = findModalContentContainer(container);
                if (contentContainer) {
                    // Max height should always be 85vh regardless of viewport height
                    expect(contentContainer.className).toMatch(/max-h-\[85vh\]/);
                    expect(contentContainer.className).toMatch(/overflow-y-auto/);
                }
            }), {
                numRuns: (0, _propertytestconfig.getNumRuns)("FAST")
            });
        });
    });
    describe("Requirement validation", ()=>{
        it("validates Requirement 4.2: Modal content scrolling on mobile devices", ()=>{
            jest.setTimeout((0, _propertytestconfig.getTimeout)("SLOW"));
            _fastcheck.default.assert(_fastcheck.default.property(_fastcheck.default.integer({
                min: 320,
                max: 639
            }), _fastcheck.default.array(_fastcheck.default.string({
                minLength: 50,
                maxLength: 150
            }), {
                minLength: 15,
                maxLength: 40
            }), _fastcheck.default.constantFrom("sm", "md", "lg", "xl"), (viewportWidth, contentLines, size)=>{
                // Mock mobile viewport
                Object.defineProperty(window, "innerWidth", {
                    writable: true,
                    configurable: true,
                    value: viewportWidth
                });
                Object.defineProperty(window, "innerHeight", {
                    writable: true,
                    configurable: true,
                    value: 667
                });
                // Requirement 4.2: WHEN Модальное_Окно открыто на мобильном устройстве,
                // THE Система SHALL обеспечивать возможность прокрутки содержимого
                const { container } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_Modal.Modal, {
                    isOpen: true,
                    onClose: ()=>{},
                    size: size,
                    children: /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                        children: contentLines.map((line, index)=>/*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                                style: {
                                    minHeight: "80px",
                                    padding: "10px"
                                },
                                children: line
                            }, index))
                    })
                }));
                const contentContainer = findModalContentContainer(container);
                if (contentContainer) {
                    // Modal content should have overflow-y: auto for scrolling
                    expect(contentContainer.className).toMatch(/overflow-y-auto/);
                    // Should have max-height constraint to enable scrolling
                    expect(contentContainer.className).toMatch(/max-h-\[85vh\]/);
                    // Computed overflow should allow scrolling
                    const overflowY = getComputedOverflow(contentContainer);
                    expect([
                        "auto",
                        "scroll"
                    ]).toContain(overflowY);
                }
            }), {
                numRuns: (0, _propertytestconfig.getNumRuns)("MEDIUM")
            });
        });
        it("validates that scrolling is available on all device sizes", ()=>{
            jest.setTimeout((0, _propertytestconfig.getTimeout)("SLOW"));
            _fastcheck.default.assert(_fastcheck.default.property(_fastcheck.default.integer({
                min: 320,
                max: 1440
            }), _fastcheck.default.array(_fastcheck.default.string({
                minLength: 30,
                maxLength: 100
            }), {
                minLength: 20,
                maxLength: 50
            }), (viewportWidth, contentLines)=>{
                Object.defineProperty(window, "innerWidth", {
                    writable: true,
                    configurable: true,
                    value: viewportWidth
                });
                const { container } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_Modal.Modal, {
                    isOpen: true,
                    onClose: ()=>{},
                    size: "md",
                    children: /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                        children: contentLines.map((line, index)=>/*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                                style: {
                                    minHeight: "70px"
                                },
                                children: line
                            }, index))
                    })
                }));
                const contentContainer = findModalContentContainer(container);
                if (contentContainer) {
                    // Scrolling should be available on all device sizes
                    expect(contentContainer.className).toMatch(/overflow-y-auto/);
                    expect(contentContainer.className).toMatch(/max-h-\[85vh\]/);
                }
            }), {
                numRuns: (0, _propertytestconfig.getNumRuns)("MEDIUM")
            });
        });
        it("validates that max-height is 85% of viewport height", ()=>{
            jest.setTimeout((0, _propertytestconfig.getTimeout)("SLOW"));
            _fastcheck.default.assert(_fastcheck.default.property(_fastcheck.default.constantFrom("sm", "md", "lg", "xl"), (size)=>{
                const { container } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_Modal.Modal, {
                    isOpen: true,
                    onClose: ()=>{},
                    size: size,
                    children: /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                        children: "Test content"
                    })
                }));
                const contentContainer = findModalContentContainer(container);
                if (contentContainer) {
                    // Should use max-h-[85vh] which is 85% of viewport height
                    expect(contentContainer.className).toMatch(/max-h-\[85vh\]/);
                }
            }), {
                numRuns: (0, _propertytestconfig.getNumRuns)("FAST")
            });
        });
    });
    describe("General property validation", ()=>{
        it("should verify scrolling properties are present across all configurations", ()=>{
            jest.setTimeout((0, _propertytestconfig.getTimeout)("SLOW"));
            _fastcheck.default.assert(_fastcheck.default.property(_fastcheck.default.integer({
                min: 320,
                max: 1440
            }), _fastcheck.default.constantFrom("sm", "md", "lg", "xl"), _fastcheck.default.oneof(shortContentArbitrary, tallContentArbitrary), _fastcheck.default.option(_fastcheck.default.string({
                minLength: 5,
                maxLength: 50
            }), {
                nil: undefined
            }), (viewportWidth, size, contentLines, title)=>{
                Object.defineProperty(window, "innerWidth", {
                    writable: true,
                    configurable: true,
                    value: viewportWidth
                });
                const { container } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_Modal.Modal, {
                    isOpen: true,
                    onClose: ()=>{},
                    size: size,
                    title: title,
                    children: /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                        children: contentLines.map((line, index)=>/*#__PURE__*/ (0, _jsxruntime.jsx)("p", {
                                children: line
                            }, index))
                    })
                }));
                const contentContainer = findModalContentContainer(container);
                if (contentContainer) {
                    // All modals should have scrolling capability
                    expect(contentContainer.className).toMatch(/overflow-y-auto/);
                    expect(contentContainer.className).toMatch(/max-h-\[85vh\]/);
                }
            }), {
                numRuns: (0, _propertytestconfig.getNumRuns)("MEDIUM")
            });
        });
        it("should ensure consistent scrolling behavior across modal lifecycle", ()=>{
            jest.setTimeout((0, _propertytestconfig.getTimeout)("SLOW"));
            _fastcheck.default.assert(_fastcheck.default.property(_fastcheck.default.array(_fastcheck.default.string({
                minLength: 20,
                maxLength: 100
            }), {
                minLength: 10,
                maxLength: 30
            }), (contentLines)=>{
                // Render modal
                const { container, rerender } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_Modal.Modal, {
                    isOpen: true,
                    onClose: ()=>{},
                    size: "md",
                    children: /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                        children: contentLines.map((line, index)=>/*#__PURE__*/ (0, _jsxruntime.jsx)("p", {
                                children: line
                            }, index))
                    })
                }));
                let contentContainer = findModalContentContainer(container);
                if (contentContainer) {
                    expect(contentContainer.className).toMatch(/overflow-y-auto/);
                    expect(contentContainer.className).toMatch(/max-h-\[85vh\]/);
                }
                // Re-render with different content
                rerender(/*#__PURE__*/ (0, _jsxruntime.jsx)(_Modal.Modal, {
                    isOpen: true,
                    onClose: ()=>{},
                    size: "lg",
                    children: /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                        children: contentLines.slice(0, 5).map((line, index)=>/*#__PURE__*/ (0, _jsxruntime.jsx)("p", {
                                children: line
                            }, index))
                    })
                }));
                contentContainer = findModalContentContainer(container);
                if (contentContainer) {
                    // Scrolling properties should persist after re-render
                    expect(contentContainer.className).toMatch(/overflow-y-auto/);
                    expect(contentContainer.className).toMatch(/max-h-\[85vh\]/);
                }
            }), {
                numRuns: (0, _propertytestconfig.getNumRuns)("FAST")
            });
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkU6XFxteVxcb3R1c1xcZmluYW5jZV90cmFja2VyXFxmcm9udGVuZFxcX190ZXN0c19fXFxwcm9wZXJ0aWVzXFxtb2RhbENvbnRlbnRTY3JvbGxpbmcucHJvcGVydHkudGVzdC50c3giXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIFByb3BlcnR5LUJhc2VkIFRlc3Qg4oCUIE1vZGFsIENvbnRlbnQgU2Nyb2xsaW5nXHJcbiAqIFxyXG4gKiAqKtCh0LLQvtC50YHRgtCy0L4gMTE6INCf0YDQvtC60YDRg9GC0LrQsCDRgdC+0LTQtdGA0LbQuNC80L7Qs9C+INC80L7QtNCw0LvRjNC90YvRhSDQvtC60L7QvSoqXHJcbiAqICoq0JLQsNC70LjQtNC40YDRg9C10YI6INCi0YDQtdCx0L7QstCw0L3QuNGPIDQuMioqXHJcbiAqIFxyXG4gKiBGb3IgYW55IG1vZGFsIHdpbmRvdyB3aXRoIGNvbnRlbnQgZXhjZWVkaW5nIHZpZXdwb3J0IGhlaWdodCxcclxuICogdmVydGljYWwgc2Nyb2xsaW5nIHNob3VsZCBiZSBhdmFpbGFibGUgKG92ZXJmbG93LXk6IGF1dG8pLlxyXG4gKiBUaGUgbW9kYWwgY29udGVudCBjb250YWluZXIgc2hvdWxkIGhhdmUgbWF4LWgtWzg1dmhdIHRvIGVuc3VyZVxyXG4gKiBzY3JvbGxhYmlsaXR5IHdoZW4gY29udGVudCBpcyB0b28gdGFsbC5cclxuICogXHJcbiAqIE5PVEU6IFNraXBwZWQgaW4gQ0kgZHVlIHRvIHBlcmZvcm1hbmNlIChyZW5kZXJzIGNvbXBsZXggTW9kYWwgd2l0aCBsYXJnZSBjb250ZW50KVxyXG4gKi9cclxuXHJcbmltcG9ydCBSZWFjdCBmcm9tIFwicmVhY3RcIjtcclxuaW1wb3J0IHsgcmVuZGVyIH0gZnJvbSBcIkB0ZXN0aW5nLWxpYnJhcnkvcmVhY3RcIjtcclxuaW1wb3J0IGZjIGZyb20gXCJmYXN0LWNoZWNrXCI7XHJcbmltcG9ydCB7IE1vZGFsIH0gZnJvbSBcIkAvY29tcG9uZW50cy91aS9Nb2RhbFwiO1xyXG5pbXBvcnQgeyBnZXROdW1SdW5zLCBnZXRUaW1lb3V0IH0gZnJvbSBcIi4vcHJvcGVydHktdGVzdC1jb25maWdcIjtcclxuXHJcbi8vIFNraXAgaW4gQ0kgZW52aXJvbm1lbnRcclxuY29uc3QgZGVzY3JpYmVPclNraXAgPSBwcm9jZXNzLmVudi5DSSA9PT0gXCJ0cnVlXCIgPyBkZXNjcmliZS5za2lwIDogZGVzY3JpYmU7XHJcblxyXG4vLyBNYXhpbXVtIGhlaWdodCBvZiBtb2RhbCBjb250ZW50ICg4NSUgb2Ygdmlld3BvcnQgaGVpZ2h0KVxyXG5jb25zdCBNQVhfTU9EQUxfSEVJR0hUX1ZIID0gODU7XHJcblxyXG4vLyBIZWxwZXIgZnVuY3Rpb24gdG8gZ2V0IGNvbXB1dGVkIHN0eWxlc1xyXG5jb25zdCBnZXRDb21wdXRlZE92ZXJmbG93ID0gKGVsZW1lbnQ6IEVsZW1lbnQpOiBzdHJpbmcgPT4ge1xyXG4gIGNvbnN0IGNvbXB1dGVkU3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcclxuICByZXR1cm4gY29tcHV0ZWRTdHlsZS5vdmVyZmxvd1k7XHJcbn07XHJcblxyXG4vLyBIZWxwZXIgZnVuY3Rpb24gdG8gY2hlY2sgaWYgZWxlbWVudCBoYXMgbWF4LWhlaWdodCBjb25zdHJhaW50XHJcbmNvbnN0IGhhc01heEhlaWdodENvbnN0cmFpbnQgPSAoZWxlbWVudDogRWxlbWVudCk6IGJvb2xlYW4gPT4ge1xyXG4gIGNvbnN0IGNsYXNzZXMgPSBlbGVtZW50LmNsYXNzTmFtZTtcclxuICByZXR1cm4gY2xhc3Nlcy5pbmNsdWRlcyhcIm1heC1oLVs4NXZoXVwiKTtcclxufTtcclxuXHJcbi8vIEhlbHBlciBmdW5jdGlvbiB0byBmaW5kIG1vZGFsIGNvbnRlbnQgY29udGFpbmVyXHJcbmNvbnN0IGZpbmRNb2RhbENvbnRlbnRDb250YWluZXIgPSAoY29udGFpbmVyOiBIVE1MRWxlbWVudCk6IEVsZW1lbnQgfCBudWxsID0+IHtcclxuICAvLyBMb29rIGZvciB0aGUgZGl2IHdpdGggb3ZlcmZsb3cteS1hdXRvIGFuZCBtYXgtaC1bODV2aF1cclxuICBjb25zdCBjb250ZW50Q29udGFpbmVyID0gY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoXCIub3ZlcmZsb3cteS1hdXRvLm1heC1oLVxcXFxbODV2aFxcXFxdXCIpO1xyXG4gIGlmIChjb250ZW50Q29udGFpbmVyKSByZXR1cm4gY29udGVudENvbnRhaW5lcjtcclxuICBcclxuICAvLyBGYWxsYmFjazogbG9vayBmb3IgYW55IGVsZW1lbnQgd2l0aCBtYXgtaC1bODV2aF1cclxuICByZXR1cm4gY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoXCJbY2xhc3MqPSdtYXgtaC1bODV2aF0nXVwiKTtcclxufTtcclxuXHJcbi8vIEdlbmVyYXRvciBmb3IgY29udGVudCB0aGF0IGV4Y2VlZHMgdmlld3BvcnQgaGVpZ2h0XHJcbmNvbnN0IHRhbGxDb250ZW50QXJiaXRyYXJ5ID0gZmMuYXJyYXkoXHJcbiAgZmMuc3RyaW5nKHsgbWluTGVuZ3RoOiA1MCwgbWF4TGVuZ3RoOiAyMDAgfSksXHJcbiAgeyBtaW5MZW5ndGg6IDIwLCBtYXhMZW5ndGg6IDEwMCB9XHJcbik7XHJcblxyXG4vLyBHZW5lcmF0b3IgZm9yIGNvbnRlbnQgdGhhdCBmaXRzIHdpdGhpbiB2aWV3cG9ydFxyXG5jb25zdCBzaG9ydENvbnRlbnRBcmJpdHJhcnkgPSBmYy5hcnJheShcclxuICBmYy5zdHJpbmcoeyBtaW5MZW5ndGg6IDEwLCBtYXhMZW5ndGg6IDUwIH0pLFxyXG4gIHsgbWluTGVuZ3RoOiAxLCBtYXhMZW5ndGg6IDUgfVxyXG4pO1xyXG5cclxuZGVzY3JpYmVPclNraXAoXCJQcm9wZXJ0eTogTW9kYWwgQ29udGVudCBTY3JvbGxpbmdcIiwgKCkgPT4ge1xyXG4gIGRlc2NyaWJlKFwiT3ZlcmZsb3cteSBhdXRvIHByb3BlcnR5XCIsICgpID0+IHtcclxuICAgIGl0KFwic2hvdWxkIGhhdmUgb3ZlcmZsb3cteTogYXV0byBvbiBtb2RhbCBjb250ZW50IGNvbnRhaW5lclwiLCAoKSA9PiB7XHJcbiAgICAgIGplc3Quc2V0VGltZW91dChnZXRUaW1lb3V0KFwiU0xPV1wiKSk7XHJcbiAgICAgIGZjLmFzc2VydChcclxuICAgICAgICBmYy5wcm9wZXJ0eShcclxuICAgICAgICAgIGZjLmNvbnN0YW50RnJvbShcInNtXCIgYXMgY29uc3QsIFwibWRcIiBhcyBjb25zdCwgXCJsZ1wiIGFzIGNvbnN0LCBcInhsXCIgYXMgY29uc3QpLFxyXG4gICAgICAgICAgZmMuYXJyYXkoZmMuc3RyaW5nKHsgbWluTGVuZ3RoOiAxMCwgbWF4TGVuZ3RoOiAxMDAgfSksIHsgbWluTGVuZ3RoOiAxLCBtYXhMZW5ndGg6IDUwIH0pLFxyXG4gICAgICAgICAgKHNpemUsIGNvbnRlbnRMaW5lcykgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCB7IGNvbnRhaW5lciB9ID0gcmVuZGVyKFxyXG4gICAgICAgICAgICAgIDxNb2RhbCBpc09wZW49e3RydWV9IG9uQ2xvc2U9eygpID0+IHt9fSBzaXplPXtzaXplfT5cclxuICAgICAgICAgICAgICAgIDxkaXY+XHJcbiAgICAgICAgICAgICAgICAgIHtjb250ZW50TGluZXMubWFwKChsaW5lLCBpbmRleCkgPT4gKFxyXG4gICAgICAgICAgICAgICAgICAgIDxwIGtleT17aW5kZXh9PntsaW5lfTwvcD5cclxuICAgICAgICAgICAgICAgICAgKSl9XHJcbiAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICA8L01vZGFsPlxyXG4gICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgY29udGVudENvbnRhaW5lciA9IGZpbmRNb2RhbENvbnRlbnRDb250YWluZXIoY29udGFpbmVyKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChjb250ZW50Q29udGFpbmVyKSB7XHJcbiAgICAgICAgICAgICAgLy8gU2hvdWxkIGhhdmUgb3ZlcmZsb3cteS1hdXRvIGNsYXNzXHJcbiAgICAgICAgICAgICAgZXhwZWN0KGNvbnRlbnRDb250YWluZXIuY2xhc3NOYW1lKS50b01hdGNoKC9vdmVyZmxvdy15LWF1dG8vKTtcclxuICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAvLyBDb21wdXRlZCBzdHlsZSBzaG91bGQgYmUgJ2F1dG8nIG9yICdzY3JvbGwnXHJcbiAgICAgICAgICAgICAgY29uc3Qgb3ZlcmZsb3dZID0gZ2V0Q29tcHV0ZWRPdmVyZmxvdyhjb250ZW50Q29udGFpbmVyKTtcclxuICAgICAgICAgICAgICBleHBlY3QoW1wiYXV0b1wiLCBcInNjcm9sbFwiXSkudG9Db250YWluKG92ZXJmbG93WSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICApLFxyXG4gICAgICAgIHsgbnVtUnVuczogZ2V0TnVtUnVucyhcIk1FRElVTVwiKSB9XHJcbiAgICAgICk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBpdChcInNob3VsZCBoYXZlIG92ZXJmbG93LXk6IGF1dG8gcmVnYXJkbGVzcyBvZiBjb250ZW50IGxlbmd0aFwiLCAoKSA9PiB7XHJcbiAgICAgIGplc3Quc2V0VGltZW91dChnZXRUaW1lb3V0KFwiU0xPV1wiKSk7XHJcbiAgICAgIGZjLmFzc2VydChcclxuICAgICAgICBmYy5wcm9wZXJ0eShcclxuICAgICAgICAgIGZjLm9uZW9mKHNob3J0Q29udGVudEFyYml0cmFyeSwgdGFsbENvbnRlbnRBcmJpdHJhcnkpLFxyXG4gICAgICAgICAgZmMuY29uc3RhbnRGcm9tKFwic21cIiBhcyBjb25zdCwgXCJtZFwiIGFzIGNvbnN0LCBcImxnXCIgYXMgY29uc3QsIFwieGxcIiBhcyBjb25zdCksXHJcbiAgICAgICAgICAoY29udGVudExpbmVzLCBzaXplKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgY29udGFpbmVyIH0gPSByZW5kZXIoXHJcbiAgICAgICAgICAgICAgPE1vZGFsIGlzT3Blbj17dHJ1ZX0gb25DbG9zZT17KCkgPT4ge319IHNpemU9e3NpemV9PlxyXG4gICAgICAgICAgICAgICAgPGRpdj5cclxuICAgICAgICAgICAgICAgICAge2NvbnRlbnRMaW5lcy5tYXAoKGxpbmUsIGluZGV4KSA9PiAoXHJcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBrZXk9e2luZGV4fSBzdHlsZT17eyBtaW5IZWlnaHQ6IFwiNTBweFwiIH19PlxyXG4gICAgICAgICAgICAgICAgICAgICAge2xpbmV9XHJcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICkpfVxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgPC9Nb2RhbD5cclxuICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IGNvbnRlbnRDb250YWluZXIgPSBmaW5kTW9kYWxDb250ZW50Q29udGFpbmVyKGNvbnRhaW5lcik7XHJcblxyXG4gICAgICAgICAgICBpZiAoY29udGVudENvbnRhaW5lcikge1xyXG4gICAgICAgICAgICAgIGV4cGVjdChjb250ZW50Q29udGFpbmVyLmNsYXNzTmFtZSkudG9NYXRjaCgvb3ZlcmZsb3cteS1hdXRvLyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICApLFxyXG4gICAgICAgIHsgbnVtUnVuczogZ2V0TnVtUnVucyhcIk1FRElVTVwiKSB9XHJcbiAgICAgICk7XHJcbiAgICB9KTtcclxuICB9KTtcclxuXHJcbiAgZGVzY3JpYmUoXCJNYXgtaGVpZ2h0IGNvbnN0cmFpbnRcIiwgKCkgPT4ge1xyXG4gICAgaXQoXCJzaG91bGQgaGF2ZSBtYXgtaC1bODV2aF0gY2xhc3Mgb24gY29udGVudCBjb250YWluZXJcIiwgKCkgPT4ge1xyXG4gICAgICBqZXN0LnNldFRpbWVvdXQoZ2V0VGltZW91dChcIlNMT1dcIikpO1xyXG4gICAgICBmYy5hc3NlcnQoXHJcbiAgICAgICAgZmMucHJvcGVydHkoXHJcbiAgICAgICAgICBmYy5jb25zdGFudEZyb20oXCJzbVwiIGFzIGNvbnN0LCBcIm1kXCIgYXMgY29uc3QsIFwibGdcIiBhcyBjb25zdCwgXCJ4bFwiIGFzIGNvbnN0KSxcclxuICAgICAgICAgIGZjLmFycmF5KGZjLnN0cmluZyh7IG1pbkxlbmd0aDogMTAsIG1heExlbmd0aDogMTAwIH0pLCB7IG1pbkxlbmd0aDogMSwgbWF4TGVuZ3RoOiA1MCB9KSxcclxuICAgICAgICAgIChzaXplLCBjb250ZW50TGluZXMpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgeyBjb250YWluZXIgfSA9IHJlbmRlcihcclxuICAgICAgICAgICAgICA8TW9kYWwgaXNPcGVuPXt0cnVlfSBvbkNsb3NlPXsoKSA9PiB7fX0gc2l6ZT17c2l6ZX0+XHJcbiAgICAgICAgICAgICAgICA8ZGl2PlxyXG4gICAgICAgICAgICAgICAgICB7Y29udGVudExpbmVzLm1hcCgobGluZSwgaW5kZXgpID0+IChcclxuICAgICAgICAgICAgICAgICAgICA8cCBrZXk9e2luZGV4fT57bGluZX08L3A+XHJcbiAgICAgICAgICAgICAgICAgICkpfVxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgPC9Nb2RhbD5cclxuICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IGNvbnRlbnRDb250YWluZXIgPSBmaW5kTW9kYWxDb250ZW50Q29udGFpbmVyKGNvbnRhaW5lcik7XHJcblxyXG4gICAgICAgICAgICBpZiAoY29udGVudENvbnRhaW5lcikge1xyXG4gICAgICAgICAgICAgIC8vIFNob3VsZCBoYXZlIG1heC1oLVs4NXZoXSBjbGFzc1xyXG4gICAgICAgICAgICAgIGV4cGVjdChoYXNNYXhIZWlnaHRDb25zdHJhaW50KGNvbnRlbnRDb250YWluZXIpKS50b0JlKHRydWUpO1xyXG4gICAgICAgICAgICAgIGV4cGVjdChjb250ZW50Q29udGFpbmVyLmNsYXNzTmFtZSkudG9NYXRjaCgvbWF4LWgtXFxbODV2aFxcXS8pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgKSxcclxuICAgICAgICB7IG51bVJ1bnM6IGdldE51bVJ1bnMoXCJNRURJVU1cIikgfVxyXG4gICAgICApO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaXQoXCJzaG91bGQgbWFpbnRhaW4gbWF4LWgtWzg1dmhdIGFjcm9zcyBhbGwgbW9kYWwgc2l6ZXNcIiwgKCkgPT4ge1xyXG4gICAgICBqZXN0LnNldFRpbWVvdXQoZ2V0VGltZW91dChcIlNMT1dcIikpO1xyXG4gICAgICBjb25zdCBzaXplczogQXJyYXk8XCJzbVwiIHwgXCJtZFwiIHwgXCJsZ1wiIHwgXCJ4bFwiPiA9IFtcInNtXCIsIFwibWRcIiwgXCJsZ1wiLCBcInhsXCJdO1xyXG5cclxuICAgICAgZmMuYXNzZXJ0KFxyXG4gICAgICAgIGZjLnByb3BlcnR5KFxyXG4gICAgICAgICAgZmMuYXJyYXkoZmMuc3RyaW5nKHsgbWluTGVuZ3RoOiAyMCwgbWF4TGVuZ3RoOiAxMDAgfSksIHsgbWluTGVuZ3RoOiAxMCwgbWF4TGVuZ3RoOiAzMCB9KSxcclxuICAgICAgICAgIChjb250ZW50TGluZXMpID0+IHtcclxuICAgICAgICAgICAgc2l6ZXMuZm9yRWFjaCgoc2l6ZSkgPT4ge1xyXG4gICAgICAgICAgICAgIGNvbnN0IHsgY29udGFpbmVyIH0gPSByZW5kZXIoXHJcbiAgICAgICAgICAgICAgICA8TW9kYWwgaXNPcGVuPXt0cnVlfSBvbkNsb3NlPXsoKSA9PiB7fX0gc2l6ZT17c2l6ZX0+XHJcbiAgICAgICAgICAgICAgICAgIDxkaXY+XHJcbiAgICAgICAgICAgICAgICAgICAge2NvbnRlbnRMaW5lcy5tYXAoKGxpbmUsIGluZGV4KSA9PiAoXHJcbiAgICAgICAgICAgICAgICAgICAgICA8cCBrZXk9e2luZGV4fT57bGluZX08L3A+XHJcbiAgICAgICAgICAgICAgICAgICAgKSl9XHJcbiAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgPC9Nb2RhbD5cclxuICAgICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgICBjb25zdCBjb250ZW50Q29udGFpbmVyID0gZmluZE1vZGFsQ29udGVudENvbnRhaW5lcihjb250YWluZXIpO1xyXG5cclxuICAgICAgICAgICAgICBpZiAoY29udGVudENvbnRhaW5lcikge1xyXG4gICAgICAgICAgICAgICAgZXhwZWN0KGNvbnRlbnRDb250YWluZXIuY2xhc3NOYW1lKS50b01hdGNoKC9tYXgtaC1cXFs4NXZoXFxdLyk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICApLFxyXG4gICAgICAgIHsgbnVtUnVuczogZ2V0TnVtUnVucyhcIkZBU1RcIikgfVxyXG4gICAgICApO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaXQoXCJzaG91bGQgaGF2ZSBtYXgtaC1bODV2aF0gcmVnYXJkbGVzcyBvZiB2aWV3cG9ydCB3aWR0aFwiLCAoKSA9PiB7XHJcbiAgICAgIGplc3Quc2V0VGltZW91dChnZXRUaW1lb3V0KFwiU0xPV1wiKSk7XHJcbiAgICAgIGZjLmFzc2VydChcclxuICAgICAgICBmYy5wcm9wZXJ0eShcclxuICAgICAgICAgIGZjLmludGVnZXIoeyBtaW46IDMyMCwgbWF4OiAxNDQwIH0pLFxyXG4gICAgICAgICAgZmMuY29uc3RhbnRGcm9tKFwic21cIiBhcyBjb25zdCwgXCJtZFwiIGFzIGNvbnN0LCBcImxnXCIgYXMgY29uc3QsIFwieGxcIiBhcyBjb25zdCksXHJcbiAgICAgICAgICAodmlld3BvcnRXaWR0aCwgc2l6ZSkgPT4ge1xyXG4gICAgICAgICAgICAvLyBNb2NrIHdpbmRvdy5pbm5lcldpZHRoXHJcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3aW5kb3csIFwiaW5uZXJXaWR0aFwiLCB7XHJcbiAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICAgIHZhbHVlOiB2aWV3cG9ydFdpZHRoLFxyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IHsgY29udGFpbmVyIH0gPSByZW5kZXIoXHJcbiAgICAgICAgICAgICAgPE1vZGFsIGlzT3Blbj17dHJ1ZX0gb25DbG9zZT17KCkgPT4ge319IHNpemU9e3NpemV9PlxyXG4gICAgICAgICAgICAgICAgPGRpdj5cclxuICAgICAgICAgICAgICAgICAgPHA+VGVzdCBjb250ZW50PC9wPlxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgPC9Nb2RhbD5cclxuICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IGNvbnRlbnRDb250YWluZXIgPSBmaW5kTW9kYWxDb250ZW50Q29udGFpbmVyKGNvbnRhaW5lcik7XHJcblxyXG4gICAgICAgICAgICBpZiAoY29udGVudENvbnRhaW5lcikge1xyXG4gICAgICAgICAgICAgIGV4cGVjdChjb250ZW50Q29udGFpbmVyLmNsYXNzTmFtZSkudG9NYXRjaCgvbWF4LWgtXFxbODV2aFxcXS8pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgKSxcclxuICAgICAgICB7IG51bVJ1bnM6IGdldE51bVJ1bnMoXCJNRURJVU1cIikgfVxyXG4gICAgICApO1xyXG4gICAgfSk7XHJcbiAgfSk7XHJcblxyXG4gIGRlc2NyaWJlKFwiU2Nyb2xsYWJpbGl0eSB3aXRoIHRhbGwgY29udGVudFwiLCAoKSA9PiB7XHJcbiAgICBpdChcInNob3VsZCBlbmFibGUgc2Nyb2xsaW5nIHdoZW4gY29udGVudCBleGNlZWRzIG1heC1oZWlnaHRcIiwgKCkgPT4ge1xyXG4gICAgICBqZXN0LnNldFRpbWVvdXQoZ2V0VGltZW91dChcIlNMT1dcIikpO1xyXG4gICAgICBmYy5hc3NlcnQoXHJcbiAgICAgICAgZmMucHJvcGVydHkoXHJcbiAgICAgICAgICB0YWxsQ29udGVudEFyYml0cmFyeSxcclxuICAgICAgICAgIGZjLmNvbnN0YW50RnJvbShcInNtXCIgYXMgY29uc3QsIFwibWRcIiBhcyBjb25zdCwgXCJsZ1wiIGFzIGNvbnN0LCBcInhsXCIgYXMgY29uc3QpLFxyXG4gICAgICAgICAgKGNvbnRlbnRMaW5lcywgc2l6ZSkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCB7IGNvbnRhaW5lciB9ID0gcmVuZGVyKFxyXG4gICAgICAgICAgICAgIDxNb2RhbCBpc09wZW49e3RydWV9IG9uQ2xvc2U9eygpID0+IHt9fSBzaXplPXtzaXplfT5cclxuICAgICAgICAgICAgICAgIDxkaXY+XHJcbiAgICAgICAgICAgICAgICAgIHtjb250ZW50TGluZXMubWFwKChsaW5lLCBpbmRleCkgPT4gKFxyXG4gICAgICAgICAgICAgICAgICAgIDxkaXYga2V5PXtpbmRleH0gc3R5bGU9e3sgbWluSGVpZ2h0OiBcIjEwMHB4XCIsIHBhZGRpbmc6IFwiMjBweFwiIH19PlxyXG4gICAgICAgICAgICAgICAgICAgICAge2xpbmV9XHJcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICkpfVxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgPC9Nb2RhbD5cclxuICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IGNvbnRlbnRDb250YWluZXIgPSBmaW5kTW9kYWxDb250ZW50Q29udGFpbmVyKGNvbnRhaW5lcik7XHJcblxyXG4gICAgICAgICAgICBpZiAoY29udGVudENvbnRhaW5lcikge1xyXG4gICAgICAgICAgICAgIC8vIFNob3VsZCBoYXZlIGJvdGggb3ZlcmZsb3cteS1hdXRvIGFuZCBtYXgtaC1bODV2aF1cclxuICAgICAgICAgICAgICBleHBlY3QoY29udGVudENvbnRhaW5lci5jbGFzc05hbWUpLnRvTWF0Y2goL292ZXJmbG93LXktYXV0by8pO1xyXG4gICAgICAgICAgICAgIGV4cGVjdChjb250ZW50Q29udGFpbmVyLmNsYXNzTmFtZSkudG9NYXRjaCgvbWF4LWgtXFxbODV2aFxcXS8pO1xyXG4gICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgIC8vIE92ZXJmbG93IHNob3VsZCBiZSBhdXRvIG9yIHNjcm9sbFxyXG4gICAgICAgICAgICAgIGNvbnN0IG92ZXJmbG93WSA9IGdldENvbXB1dGVkT3ZlcmZsb3coY29udGVudENvbnRhaW5lcik7XHJcbiAgICAgICAgICAgICAgZXhwZWN0KFtcImF1dG9cIiwgXCJzY3JvbGxcIl0pLnRvQ29udGFpbihvdmVyZmxvd1kpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgKSxcclxuICAgICAgICB7IG51bVJ1bnM6IGdldE51bVJ1bnMoXCJGQVNUXCIpIH1cclxuICAgICAgKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGl0KFwic2hvdWxkIGhhbmRsZSBmb3JtcyB3aXRoIG1hbnkgZmllbGRzXCIsICgpID0+IHtcclxuICAgICAgamVzdC5zZXRUaW1lb3V0KGdldFRpbWVvdXQoXCJTTE9XXCIpKTtcclxuICAgICAgZmMuYXNzZXJ0KFxyXG4gICAgICAgIGZjLnByb3BlcnR5KFxyXG4gICAgICAgICAgZmMuYXJyYXkoXHJcbiAgICAgICAgICAgIGZjLnJlY29yZCh7XHJcbiAgICAgICAgICAgICAgbGFiZWw6IGZjLnN0cmluZyh7IG1pbkxlbmd0aDogNSwgbWF4TGVuZ3RoOiAzMCB9KSxcclxuICAgICAgICAgICAgICB0eXBlOiBmYy5jb25zdGFudEZyb20oXCJ0ZXh0XCIsIFwiZW1haWxcIiwgXCJudW1iZXJcIiwgXCJ0ZXh0YXJlYVwiKSxcclxuICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgIHsgbWluTGVuZ3RoOiAxMCwgbWF4TGVuZ3RoOiAyMCB9XHJcbiAgICAgICAgICApLFxyXG4gICAgICAgICAgZmMuY29uc3RhbnRGcm9tKFwic21cIiBhcyBjb25zdCwgXCJtZFwiIGFzIGNvbnN0LCBcImxnXCIgYXMgY29uc3QsIFwieGxcIiBhcyBjb25zdCksXHJcbiAgICAgICAgICAoZmllbGRzLCBzaXplKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgY29udGFpbmVyIH0gPSByZW5kZXIoXHJcbiAgICAgICAgICAgICAgPE1vZGFsIGlzT3Blbj17dHJ1ZX0gb25DbG9zZT17KCkgPT4ge319IHNpemU9e3NpemV9IHRpdGxlPVwiRm9ybVwiPlxyXG4gICAgICAgICAgICAgICAgPGZvcm0+XHJcbiAgICAgICAgICAgICAgICAgIHtmaWVsZHMubWFwKChmaWVsZCwgaW5kZXgpID0+IChcclxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGtleT17aW5kZXh9IHN0eWxlPXt7IG1hcmdpbkJvdHRvbTogXCIyMHB4XCIgfX0+XHJcbiAgICAgICAgICAgICAgICAgICAgICA8bGFiZWw+e2ZpZWxkLmxhYmVsfTwvbGFiZWw+XHJcbiAgICAgICAgICAgICAgICAgICAgICB7ZmllbGQudHlwZSA9PT0gXCJ0ZXh0YXJlYVwiID8gKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8dGV4dGFyZWEgc3R5bGU9e3sgd2lkdGg6IFwiMTAwJVwiLCBoZWlnaHQ6IFwiODBweFwiIH19IC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICApIDogKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8aW5wdXQgdHlwZT17ZmllbGQudHlwZX0gc3R5bGU9e3sgd2lkdGg6IFwiMTAwJVwiIH19IC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICApfVxyXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICApKX1cclxuICAgICAgICAgICAgICAgIDwvZm9ybT5cclxuICAgICAgICAgICAgICA8L01vZGFsPlxyXG4gICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgY29udGVudENvbnRhaW5lciA9IGZpbmRNb2RhbENvbnRlbnRDb250YWluZXIoY29udGFpbmVyKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChjb250ZW50Q29udGFpbmVyKSB7XHJcbiAgICAgICAgICAgICAgLy8gRm9ybSBzaG91bGQgYmUgc2Nyb2xsYWJsZVxyXG4gICAgICAgICAgICAgIGV4cGVjdChjb250ZW50Q29udGFpbmVyLmNsYXNzTmFtZSkudG9NYXRjaCgvb3ZlcmZsb3cteS1hdXRvLyk7XHJcbiAgICAgICAgICAgICAgZXhwZWN0KGNvbnRlbnRDb250YWluZXIuY2xhc3NOYW1lKS50b01hdGNoKC9tYXgtaC1cXFs4NXZoXFxdLyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICApLFxyXG4gICAgICAgIHsgbnVtUnVuczogZ2V0TnVtUnVucyhcIkZBU1RcIikgfVxyXG4gICAgICApO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaXQoXCJzaG91bGQgaGFuZGxlIG5lc3RlZCBjb250ZW50IHN0cnVjdHVyZXNcIiwgKCkgPT4ge1xyXG4gICAgICBqZXN0LnNldFRpbWVvdXQoZ2V0VGltZW91dChcIlNMT1dcIikpO1xyXG4gICAgICBmYy5hc3NlcnQoXHJcbiAgICAgICAgZmMucHJvcGVydHkoXHJcbiAgICAgICAgICBmYy5hcnJheShcclxuICAgICAgICAgICAgZmMucmVjb3JkKHtcclxuICAgICAgICAgICAgICB0aXRsZTogZmMuc3RyaW5nKHsgbWluTGVuZ3RoOiAxMCwgbWF4TGVuZ3RoOiA1MCB9KSxcclxuICAgICAgICAgICAgICBpdGVtczogZmMuYXJyYXkoZmMuc3RyaW5nKHsgbWluTGVuZ3RoOiAyMCwgbWF4TGVuZ3RoOiAxMDAgfSksIHsgbWluTGVuZ3RoOiAzLCBtYXhMZW5ndGg6IDEwIH0pLFxyXG4gICAgICAgICAgICB9KSxcclxuICAgICAgICAgICAgeyBtaW5MZW5ndGg6IDUsIG1heExlbmd0aDogMTUgfVxyXG4gICAgICAgICAgKSxcclxuICAgICAgICAgIChzZWN0aW9ucykgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCB7IGNvbnRhaW5lciB9ID0gcmVuZGVyKFxyXG4gICAgICAgICAgICAgIDxNb2RhbCBpc09wZW49e3RydWV9IG9uQ2xvc2U9eygpID0+IHt9fSBzaXplPVwibGdcIj5cclxuICAgICAgICAgICAgICAgIDxkaXY+XHJcbiAgICAgICAgICAgICAgICAgIHtzZWN0aW9ucy5tYXAoKHNlY3Rpb24sIHNlY3Rpb25JbmRleCkgPT4gKFxyXG4gICAgICAgICAgICAgICAgICAgIDxkaXYga2V5PXtzZWN0aW9uSW5kZXh9IHN0eWxlPXt7IG1hcmdpbkJvdHRvbTogXCIzMHB4XCIgfX0+XHJcbiAgICAgICAgICAgICAgICAgICAgICA8aDM+e3NlY3Rpb24udGl0bGV9PC9oMz5cclxuICAgICAgICAgICAgICAgICAgICAgIDx1bD5cclxuICAgICAgICAgICAgICAgICAgICAgICAge3NlY3Rpb24uaXRlbXMubWFwKChpdGVtLCBpdGVtSW5kZXgpID0+IChcclxuICAgICAgICAgICAgICAgICAgICAgICAgICA8bGkga2V5PXtpdGVtSW5kZXh9IHN0eWxlPXt7IHBhZGRpbmc6IFwiMTBweFwiIH19PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge2l0ZW19XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgPC9saT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgKSl9XHJcbiAgICAgICAgICAgICAgICAgICAgICA8L3VsPlxyXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICApKX1cclxuICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgIDwvTW9kYWw+XHJcbiAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICBjb25zdCBjb250ZW50Q29udGFpbmVyID0gZmluZE1vZGFsQ29udGVudENvbnRhaW5lcihjb250YWluZXIpO1xyXG5cclxuICAgICAgICAgICAgaWYgKGNvbnRlbnRDb250YWluZXIpIHtcclxuICAgICAgICAgICAgICBleHBlY3QoY29udGVudENvbnRhaW5lci5jbGFzc05hbWUpLnRvTWF0Y2goL292ZXJmbG93LXktYXV0by8pO1xyXG4gICAgICAgICAgICAgIGV4cGVjdChjb250ZW50Q29udGFpbmVyLmNsYXNzTmFtZSkudG9NYXRjaCgvbWF4LWgtXFxbODV2aFxcXS8pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgKSxcclxuICAgICAgICB7IG51bVJ1bnM6IGdldE51bVJ1bnMoXCJGQVNUXCIpIH1cclxuICAgICAgKTtcclxuICAgIH0pO1xyXG4gIH0pO1xyXG5cclxuICBkZXNjcmliZShcIkVkZ2UgY2FzZXNcIiwgKCkgPT4ge1xyXG4gICAgaXQoXCJzaG91bGQgaGFuZGxlIG1vZGFsIHdpdGggbWluaW1hbCBjb250ZW50XCIsICgpID0+IHtcclxuICAgICAgamVzdC5zZXRUaW1lb3V0KGdldFRpbWVvdXQoXCJTTE9XXCIpKTtcclxuICAgICAgZmMuYXNzZXJ0KFxyXG4gICAgICAgIGZjLnByb3BlcnR5KFxyXG4gICAgICAgICAgZmMuY29uc3RhbnRGcm9tKFwic21cIiBhcyBjb25zdCwgXCJtZFwiIGFzIGNvbnN0LCBcImxnXCIgYXMgY29uc3QsIFwieGxcIiBhcyBjb25zdCksXHJcbiAgICAgICAgICBmYy5zdHJpbmcoeyBtaW5MZW5ndGg6IDEsIG1heExlbmd0aDogMjAgfSksXHJcbiAgICAgICAgICAoc2l6ZSwgY29udGVudCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCB7IGNvbnRhaW5lciB9ID0gcmVuZGVyKFxyXG4gICAgICAgICAgICAgIDxNb2RhbCBpc09wZW49e3RydWV9IG9uQ2xvc2U9eygpID0+IHt9fSBzaXplPXtzaXplfT5cclxuICAgICAgICAgICAgICAgIDxkaXY+e2NvbnRlbnR9PC9kaXY+XHJcbiAgICAgICAgICAgICAgPC9Nb2RhbD5cclxuICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IGNvbnRlbnRDb250YWluZXIgPSBmaW5kTW9kYWxDb250ZW50Q29udGFpbmVyKGNvbnRhaW5lcik7XHJcblxyXG4gICAgICAgICAgICBpZiAoY29udGVudENvbnRhaW5lcikge1xyXG4gICAgICAgICAgICAgIC8vIEV2ZW4gd2l0aCBtaW5pbWFsIGNvbnRlbnQsIHNjcm9sbGluZyBwcm9wZXJ0aWVzIHNob3VsZCBiZSBwcmVzZW50XHJcbiAgICAgICAgICAgICAgZXhwZWN0KGNvbnRlbnRDb250YWluZXIuY2xhc3NOYW1lKS50b01hdGNoKC9vdmVyZmxvdy15LWF1dG8vKTtcclxuICAgICAgICAgICAgICBleHBlY3QoY29udGVudENvbnRhaW5lci5jbGFzc05hbWUpLnRvTWF0Y2goL21heC1oLVxcWzg1dmhcXF0vKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICksXHJcbiAgICAgICAgeyBudW1SdW5zOiBnZXROdW1SdW5zKFwiRkFTVFwiKSB9XHJcbiAgICAgICk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBpdChcInNob3VsZCBoYW5kbGUgbW9kYWwgd2l0aCBlbXB0eSBjb250ZW50XCIsICgpID0+IHtcclxuICAgICAgamVzdC5zZXRUaW1lb3V0KGdldFRpbWVvdXQoXCJTTE9XXCIpKTtcclxuICAgICAgY29uc3Qgc2l6ZXM6IEFycmF5PFwic21cIiB8IFwibWRcIiB8IFwibGdcIiB8IFwieGxcIj4gPSBbXCJzbVwiLCBcIm1kXCIsIFwibGdcIiwgXCJ4bFwiXTtcclxuXHJcbiAgICAgIHNpemVzLmZvckVhY2goKHNpemUpID0+IHtcclxuICAgICAgICBjb25zdCB7IGNvbnRhaW5lciB9ID0gcmVuZGVyKFxyXG4gICAgICAgICAgPE1vZGFsIGlzT3Blbj17dHJ1ZX0gb25DbG9zZT17KCkgPT4ge319IHNpemU9e3NpemV9PlxyXG4gICAgICAgICAgICA8ZGl2PjwvZGl2PlxyXG4gICAgICAgICAgPC9Nb2RhbD5cclxuICAgICAgICApO1xyXG5cclxuICAgICAgICBjb25zdCBjb250ZW50Q29udGFpbmVyID0gZmluZE1vZGFsQ29udGVudENvbnRhaW5lcihjb250YWluZXIpO1xyXG5cclxuICAgICAgICBpZiAoY29udGVudENvbnRhaW5lcikge1xyXG4gICAgICAgICAgZXhwZWN0KGNvbnRlbnRDb250YWluZXIuY2xhc3NOYW1lKS50b01hdGNoKC9vdmVyZmxvdy15LWF1dG8vKTtcclxuICAgICAgICAgIGV4cGVjdChjb250ZW50Q29udGFpbmVyLmNsYXNzTmFtZSkudG9NYXRjaCgvbWF4LWgtXFxbODV2aFxcXS8pO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBpdChcInNob3VsZCBoYW5kbGUgbW9kYWwgd2l0aCB0aXRsZSBhbmQgY29udGVudFwiLCAoKSA9PiB7XHJcbiAgICAgIGplc3Quc2V0VGltZW91dChnZXRUaW1lb3V0KFwiU0xPV1wiKSk7XHJcbiAgICAgIGZjLmFzc2VydChcclxuICAgICAgICBmYy5wcm9wZXJ0eShcclxuICAgICAgICAgIGZjLnN0cmluZyh7IG1pbkxlbmd0aDogNSwgbWF4TGVuZ3RoOiA1MCB9KSxcclxuICAgICAgICAgIGZjLmFycmF5KGZjLnN0cmluZyh7IG1pbkxlbmd0aDogMjAsIG1heExlbmd0aDogMTAwIH0pLCB7IG1pbkxlbmd0aDogNSwgbWF4TGVuZ3RoOiAyMCB9KSxcclxuICAgICAgICAgIGZjLmNvbnN0YW50RnJvbShcInNtXCIgYXMgY29uc3QsIFwibWRcIiBhcyBjb25zdCwgXCJsZ1wiIGFzIGNvbnN0LCBcInhsXCIgYXMgY29uc3QpLFxyXG4gICAgICAgICAgKHRpdGxlLCBjb250ZW50TGluZXMsIHNpemUpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgeyBjb250YWluZXIgfSA9IHJlbmRlcihcclxuICAgICAgICAgICAgICA8TW9kYWwgaXNPcGVuPXt0cnVlfSBvbkNsb3NlPXsoKSA9PiB7fX0gdGl0bGU9e3RpdGxlfSBzaXplPXtzaXplfT5cclxuICAgICAgICAgICAgICAgIDxkaXY+XHJcbiAgICAgICAgICAgICAgICAgIHtjb250ZW50TGluZXMubWFwKChsaW5lLCBpbmRleCkgPT4gKFxyXG4gICAgICAgICAgICAgICAgICAgIDxwIGtleT17aW5kZXh9PntsaW5lfTwvcD5cclxuICAgICAgICAgICAgICAgICAgKSl9XHJcbiAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICA8L01vZGFsPlxyXG4gICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgY29udGVudENvbnRhaW5lciA9IGZpbmRNb2RhbENvbnRlbnRDb250YWluZXIoY29udGFpbmVyKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChjb250ZW50Q29udGFpbmVyKSB7XHJcbiAgICAgICAgICAgICAgZXhwZWN0KGNvbnRlbnRDb250YWluZXIuY2xhc3NOYW1lKS50b01hdGNoKC9vdmVyZmxvdy15LWF1dG8vKTtcclxuICAgICAgICAgICAgICBleHBlY3QoY29udGVudENvbnRhaW5lci5jbGFzc05hbWUpLnRvTWF0Y2goL21heC1oLVxcWzg1dmhcXF0vKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICksXHJcbiAgICAgICAgeyBudW1SdW5zOiBnZXROdW1SdW5zKFwiRkFTVFwiKSB9XHJcbiAgICAgICk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBpdChcInNob3VsZCBoYW5kbGUgbW9kYWwgd2l0aCBpbWFnZXMgYW5kIG1peGVkIGNvbnRlbnRcIiwgKCkgPT4ge1xyXG4gICAgICBqZXN0LnNldFRpbWVvdXQoZ2V0VGltZW91dChcIlNMT1dcIikpO1xyXG4gICAgICBmYy5hc3NlcnQoXHJcbiAgICAgICAgZmMucHJvcGVydHkoXHJcbiAgICAgICAgICBmYy5hcnJheShcclxuICAgICAgICAgICAgZmMucmVjb3JkKHtcclxuICAgICAgICAgICAgICB0eXBlOiBmYy5jb25zdGFudEZyb20oXCJ0ZXh0XCIsIFwiaW1hZ2VcIiwgXCJsaXN0XCIpLFxyXG4gICAgICAgICAgICAgIGNvbnRlbnQ6IGZjLnN0cmluZyh7IG1pbkxlbmd0aDogMTAsIG1heExlbmd0aDogMTAwIH0pLFxyXG4gICAgICAgICAgICB9KSxcclxuICAgICAgICAgICAgeyBtaW5MZW5ndGg6IDUsIG1heExlbmd0aDogMTUgfVxyXG4gICAgICAgICAgKSxcclxuICAgICAgICAgIChjb250ZW50QmxvY2tzKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgY29udGFpbmVyIH0gPSByZW5kZXIoXHJcbiAgICAgICAgICAgICAgPE1vZGFsIGlzT3Blbj17dHJ1ZX0gb25DbG9zZT17KCkgPT4ge319IHNpemU9XCJsZ1wiPlxyXG4gICAgICAgICAgICAgICAgPGRpdj5cclxuICAgICAgICAgICAgICAgICAge2NvbnRlbnRCbG9ja3MubWFwKChibG9jaywgaW5kZXgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYmxvY2sudHlwZSA9PT0gXCJ0ZXh0XCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiA8cCBrZXk9e2luZGV4fT57YmxvY2suY29udGVudH08L3A+O1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYmxvY2sudHlwZSA9PT0gXCJpbWFnZVwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGtleT17aW5kZXh9IHN0eWxlPXt7IGhlaWdodDogXCIyMDBweFwiLCBiYWNrZ3JvdW5kOiBcIiNjY2NcIiB9fT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICBJbWFnZSBwbGFjZWhvbGRlcjoge2Jsb2NrLmNvbnRlbnR9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgICAgICAgICAgICAgPHVsIGtleT17aW5kZXh9PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIDxsaT57YmxvY2suY29udGVudH08L2xpPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8L3VsPlxyXG4gICAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgIH0pfVxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgPC9Nb2RhbD5cclxuICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IGNvbnRlbnRDb250YWluZXIgPSBmaW5kTW9kYWxDb250ZW50Q29udGFpbmVyKGNvbnRhaW5lcik7XHJcblxyXG4gICAgICAgICAgICBpZiAoY29udGVudENvbnRhaW5lcikge1xyXG4gICAgICAgICAgICAgIGV4cGVjdChjb250ZW50Q29udGFpbmVyLmNsYXNzTmFtZSkudG9NYXRjaCgvb3ZlcmZsb3cteS1hdXRvLyk7XHJcbiAgICAgICAgICAgICAgZXhwZWN0KGNvbnRlbnRDb250YWluZXIuY2xhc3NOYW1lKS50b01hdGNoKC9tYXgtaC1cXFs4NXZoXFxdLyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICApLFxyXG4gICAgICAgIHsgbnVtUnVuczogZ2V0TnVtUnVucyhcIkZBU1RcIikgfVxyXG4gICAgICApO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaXQoXCJzaG91bGQgaGFuZGxlIG1vZGFsIG9uIGRpZmZlcmVudCB2aWV3cG9ydCBoZWlnaHRzXCIsICgpID0+IHtcclxuICAgICAgamVzdC5zZXRUaW1lb3V0KGdldFRpbWVvdXQoXCJTTE9XXCIpKTtcclxuICAgICAgZmMuYXNzZXJ0KFxyXG4gICAgICAgIGZjLnByb3BlcnR5KFxyXG4gICAgICAgICAgZmMuaW50ZWdlcih7IG1pbjogNDgwLCBtYXg6IDEwODAgfSksIC8vIHZpZXdwb3J0IGhlaWdodFxyXG4gICAgICAgICAgZmMuYXJyYXkoZmMuc3RyaW5nKHsgbWluTGVuZ3RoOiA1MCwgbWF4TGVuZ3RoOiAxNTAgfSksIHsgbWluTGVuZ3RoOiAxMCwgbWF4TGVuZ3RoOiAzMCB9KSxcclxuICAgICAgICAgICh2aWV3cG9ydEhlaWdodCwgY29udGVudExpbmVzKSA9PiB7XHJcbiAgICAgICAgICAgIC8vIE1vY2sgd2luZG93LmlubmVySGVpZ2h0XHJcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3aW5kb3csIFwiaW5uZXJIZWlnaHRcIiwge1xyXG4gICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgICB2YWx1ZTogdmlld3BvcnRIZWlnaHQsXHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgeyBjb250YWluZXIgfSA9IHJlbmRlcihcclxuICAgICAgICAgICAgICA8TW9kYWwgaXNPcGVuPXt0cnVlfSBvbkNsb3NlPXsoKSA9PiB7fX0gc2l6ZT1cIm1kXCI+XHJcbiAgICAgICAgICAgICAgICA8ZGl2PlxyXG4gICAgICAgICAgICAgICAgICB7Y29udGVudExpbmVzLm1hcCgobGluZSwgaW5kZXgpID0+IChcclxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGtleT17aW5kZXh9IHN0eWxlPXt7IG1pbkhlaWdodDogXCI2MHB4XCIgfX0+XHJcbiAgICAgICAgICAgICAgICAgICAgICB7bGluZX1cclxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgKSl9XHJcbiAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICA8L01vZGFsPlxyXG4gICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgY29udGVudENvbnRhaW5lciA9IGZpbmRNb2RhbENvbnRlbnRDb250YWluZXIoY29udGFpbmVyKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChjb250ZW50Q29udGFpbmVyKSB7XHJcbiAgICAgICAgICAgICAgLy8gTWF4IGhlaWdodCBzaG91bGQgYWx3YXlzIGJlIDg1dmggcmVnYXJkbGVzcyBvZiB2aWV3cG9ydCBoZWlnaHRcclxuICAgICAgICAgICAgICBleHBlY3QoY29udGVudENvbnRhaW5lci5jbGFzc05hbWUpLnRvTWF0Y2goL21heC1oLVxcWzg1dmhcXF0vKTtcclxuICAgICAgICAgICAgICBleHBlY3QoY29udGVudENvbnRhaW5lci5jbGFzc05hbWUpLnRvTWF0Y2goL292ZXJmbG93LXktYXV0by8pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgKSxcclxuICAgICAgICB7IG51bVJ1bnM6IGdldE51bVJ1bnMoXCJGQVNUXCIpIH1cclxuICAgICAgKTtcclxuICAgIH0pO1xyXG4gIH0pO1xyXG5cclxuICBkZXNjcmliZShcIlJlcXVpcmVtZW50IHZhbGlkYXRpb25cIiwgKCkgPT4ge1xyXG4gICAgaXQoXCJ2YWxpZGF0ZXMgUmVxdWlyZW1lbnQgNC4yOiBNb2RhbCBjb250ZW50IHNjcm9sbGluZyBvbiBtb2JpbGUgZGV2aWNlc1wiLCAoKSA9PiB7XHJcbiAgICAgIGplc3Quc2V0VGltZW91dChnZXRUaW1lb3V0KFwiU0xPV1wiKSk7XHJcbiAgICAgIGZjLmFzc2VydChcclxuICAgICAgICBmYy5wcm9wZXJ0eShcclxuICAgICAgICAgIGZjLmludGVnZXIoeyBtaW46IDMyMCwgbWF4OiA2MzkgfSksIC8vIE1vYmlsZSB2aWV3cG9ydCB3aWR0aFxyXG4gICAgICAgICAgZmMuYXJyYXkoZmMuc3RyaW5nKHsgbWluTGVuZ3RoOiA1MCwgbWF4TGVuZ3RoOiAxNTAgfSksIHsgbWluTGVuZ3RoOiAxNSwgbWF4TGVuZ3RoOiA0MCB9KSxcclxuICAgICAgICAgIGZjLmNvbnN0YW50RnJvbShcInNtXCIgYXMgY29uc3QsIFwibWRcIiBhcyBjb25zdCwgXCJsZ1wiIGFzIGNvbnN0LCBcInhsXCIgYXMgY29uc3QpLFxyXG4gICAgICAgICAgKHZpZXdwb3J0V2lkdGgsIGNvbnRlbnRMaW5lcywgc2l6ZSkgPT4ge1xyXG4gICAgICAgICAgICAvLyBNb2NrIG1vYmlsZSB2aWV3cG9ydFxyXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkod2luZG93LCBcImlubmVyV2lkdGhcIiwge1xyXG4gICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgICB2YWx1ZTogdmlld3BvcnRXaWR0aCxcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkod2luZG93LCBcImlubmVySGVpZ2h0XCIsIHtcclxuICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgdmFsdWU6IDY2NywgLy8gVHlwaWNhbCBtb2JpbGUgaGVpZ2h0XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgLy8gUmVxdWlyZW1lbnQgNC4yOiBXSEVOINCc0L7QtNCw0LvRjNC90L7QtV/QntC60L3QviDQvtGC0LrRgNGL0YLQviDQvdCwINC80L7QsdC40LvRjNC90L7QvCDRg9GB0YLRgNC+0LnRgdGC0LLQtSxcclxuICAgICAgICAgICAgLy8gVEhFINCh0LjRgdGC0LXQvNCwIFNIQUxMINC+0LHQtdGB0L/QtdGH0LjQstCw0YLRjCDQstC+0LfQvNC+0LbQvdC+0YHRgtGMINC/0YDQvtC60YDRg9GC0LrQuCDRgdC+0LTQtdGA0LbQuNC80L7Qs9C+XHJcbiAgICAgICAgICAgIGNvbnN0IHsgY29udGFpbmVyIH0gPSByZW5kZXIoXHJcbiAgICAgICAgICAgICAgPE1vZGFsIGlzT3Blbj17dHJ1ZX0gb25DbG9zZT17KCkgPT4ge319IHNpemU9e3NpemV9PlxyXG4gICAgICAgICAgICAgICAgPGRpdj5cclxuICAgICAgICAgICAgICAgICAge2NvbnRlbnRMaW5lcy5tYXAoKGxpbmUsIGluZGV4KSA9PiAoXHJcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBrZXk9e2luZGV4fSBzdHlsZT17eyBtaW5IZWlnaHQ6IFwiODBweFwiLCBwYWRkaW5nOiBcIjEwcHhcIiB9fT5cclxuICAgICAgICAgICAgICAgICAgICAgIHtsaW5lfVxyXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICApKX1cclxuICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgIDwvTW9kYWw+XHJcbiAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICBjb25zdCBjb250ZW50Q29udGFpbmVyID0gZmluZE1vZGFsQ29udGVudENvbnRhaW5lcihjb250YWluZXIpO1xyXG5cclxuICAgICAgICAgICAgaWYgKGNvbnRlbnRDb250YWluZXIpIHtcclxuICAgICAgICAgICAgICAvLyBNb2RhbCBjb250ZW50IHNob3VsZCBoYXZlIG92ZXJmbG93LXk6IGF1dG8gZm9yIHNjcm9sbGluZ1xyXG4gICAgICAgICAgICAgIGV4cGVjdChjb250ZW50Q29udGFpbmVyLmNsYXNzTmFtZSkudG9NYXRjaCgvb3ZlcmZsb3cteS1hdXRvLyk7XHJcbiAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgLy8gU2hvdWxkIGhhdmUgbWF4LWhlaWdodCBjb25zdHJhaW50IHRvIGVuYWJsZSBzY3JvbGxpbmdcclxuICAgICAgICAgICAgICBleHBlY3QoY29udGVudENvbnRhaW5lci5jbGFzc05hbWUpLnRvTWF0Y2goL21heC1oLVxcWzg1dmhcXF0vKTtcclxuICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAvLyBDb21wdXRlZCBvdmVyZmxvdyBzaG91bGQgYWxsb3cgc2Nyb2xsaW5nXHJcbiAgICAgICAgICAgICAgY29uc3Qgb3ZlcmZsb3dZID0gZ2V0Q29tcHV0ZWRPdmVyZmxvdyhjb250ZW50Q29udGFpbmVyKTtcclxuICAgICAgICAgICAgICBleHBlY3QoW1wiYXV0b1wiLCBcInNjcm9sbFwiXSkudG9Db250YWluKG92ZXJmbG93WSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICApLFxyXG4gICAgICAgIHsgbnVtUnVuczogZ2V0TnVtUnVucyhcIk1FRElVTVwiKSB9XHJcbiAgICAgICk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBpdChcInZhbGlkYXRlcyB0aGF0IHNjcm9sbGluZyBpcyBhdmFpbGFibGUgb24gYWxsIGRldmljZSBzaXplc1wiLCAoKSA9PiB7XHJcbiAgICAgIGplc3Quc2V0VGltZW91dChnZXRUaW1lb3V0KFwiU0xPV1wiKSk7XHJcbiAgICAgIGZjLmFzc2VydChcclxuICAgICAgICBmYy5wcm9wZXJ0eShcclxuICAgICAgICAgIGZjLmludGVnZXIoeyBtaW46IDMyMCwgbWF4OiAxNDQwIH0pLCAvLyBBbGwgdmlld3BvcnQgd2lkdGhzXHJcbiAgICAgICAgICBmYy5hcnJheShmYy5zdHJpbmcoeyBtaW5MZW5ndGg6IDMwLCBtYXhMZW5ndGg6IDEwMCB9KSwgeyBtaW5MZW5ndGg6IDIwLCBtYXhMZW5ndGg6IDUwIH0pLFxyXG4gICAgICAgICAgKHZpZXdwb3J0V2lkdGgsIGNvbnRlbnRMaW5lcykgPT4ge1xyXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkod2luZG93LCBcImlubmVyV2lkdGhcIiwge1xyXG4gICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgICB2YWx1ZTogdmlld3BvcnRXaWR0aCxcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBjb25zdCB7IGNvbnRhaW5lciB9ID0gcmVuZGVyKFxyXG4gICAgICAgICAgICAgIDxNb2RhbCBpc09wZW49e3RydWV9IG9uQ2xvc2U9eygpID0+IHt9fSBzaXplPVwibWRcIj5cclxuICAgICAgICAgICAgICAgIDxkaXY+XHJcbiAgICAgICAgICAgICAgICAgIHtjb250ZW50TGluZXMubWFwKChsaW5lLCBpbmRleCkgPT4gKFxyXG4gICAgICAgICAgICAgICAgICAgIDxkaXYga2V5PXtpbmRleH0gc3R5bGU9e3sgbWluSGVpZ2h0OiBcIjcwcHhcIiB9fT5cclxuICAgICAgICAgICAgICAgICAgICAgIHtsaW5lfVxyXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICApKX1cclxuICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgIDwvTW9kYWw+XHJcbiAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICBjb25zdCBjb250ZW50Q29udGFpbmVyID0gZmluZE1vZGFsQ29udGVudENvbnRhaW5lcihjb250YWluZXIpO1xyXG5cclxuICAgICAgICAgICAgaWYgKGNvbnRlbnRDb250YWluZXIpIHtcclxuICAgICAgICAgICAgICAvLyBTY3JvbGxpbmcgc2hvdWxkIGJlIGF2YWlsYWJsZSBvbiBhbGwgZGV2aWNlIHNpemVzXHJcbiAgICAgICAgICAgICAgZXhwZWN0KGNvbnRlbnRDb250YWluZXIuY2xhc3NOYW1lKS50b01hdGNoKC9vdmVyZmxvdy15LWF1dG8vKTtcclxuICAgICAgICAgICAgICBleHBlY3QoY29udGVudENvbnRhaW5lci5jbGFzc05hbWUpLnRvTWF0Y2goL21heC1oLVxcWzg1dmhcXF0vKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICksXHJcbiAgICAgICAgeyBudW1SdW5zOiBnZXROdW1SdW5zKFwiTUVESVVNXCIpIH1cclxuICAgICAgKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGl0KFwidmFsaWRhdGVzIHRoYXQgbWF4LWhlaWdodCBpcyA4NSUgb2Ygdmlld3BvcnQgaGVpZ2h0XCIsICgpID0+IHtcclxuICAgICAgamVzdC5zZXRUaW1lb3V0KGdldFRpbWVvdXQoXCJTTE9XXCIpKTtcclxuICAgICAgZmMuYXNzZXJ0KFxyXG4gICAgICAgIGZjLnByb3BlcnR5KFxyXG4gICAgICAgICAgZmMuY29uc3RhbnRGcm9tKFwic21cIiBhcyBjb25zdCwgXCJtZFwiIGFzIGNvbnN0LCBcImxnXCIgYXMgY29uc3QsIFwieGxcIiBhcyBjb25zdCksXHJcbiAgICAgICAgICAoc2l6ZSkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCB7IGNvbnRhaW5lciB9ID0gcmVuZGVyKFxyXG4gICAgICAgICAgICAgIDxNb2RhbCBpc09wZW49e3RydWV9IG9uQ2xvc2U9eygpID0+IHt9fSBzaXplPXtzaXplfT5cclxuICAgICAgICAgICAgICAgIDxkaXY+VGVzdCBjb250ZW50PC9kaXY+XHJcbiAgICAgICAgICAgICAgPC9Nb2RhbD5cclxuICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IGNvbnRlbnRDb250YWluZXIgPSBmaW5kTW9kYWxDb250ZW50Q29udGFpbmVyKGNvbnRhaW5lcik7XHJcblxyXG4gICAgICAgICAgICBpZiAoY29udGVudENvbnRhaW5lcikge1xyXG4gICAgICAgICAgICAgIC8vIFNob3VsZCB1c2UgbWF4LWgtWzg1dmhdIHdoaWNoIGlzIDg1JSBvZiB2aWV3cG9ydCBoZWlnaHRcclxuICAgICAgICAgICAgICBleHBlY3QoY29udGVudENvbnRhaW5lci5jbGFzc05hbWUpLnRvTWF0Y2goL21heC1oLVxcWzg1dmhcXF0vKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICksXHJcbiAgICAgICAgeyBudW1SdW5zOiBnZXROdW1SdW5zKFwiRkFTVFwiKSB9XHJcbiAgICAgICk7XHJcbiAgICB9KTtcclxuICB9KTtcclxuXHJcbiAgZGVzY3JpYmUoXCJHZW5lcmFsIHByb3BlcnR5IHZhbGlkYXRpb25cIiwgKCkgPT4ge1xyXG4gICAgaXQoXCJzaG91bGQgdmVyaWZ5IHNjcm9sbGluZyBwcm9wZXJ0aWVzIGFyZSBwcmVzZW50IGFjcm9zcyBhbGwgY29uZmlndXJhdGlvbnNcIiwgKCkgPT4ge1xyXG4gICAgICBqZXN0LnNldFRpbWVvdXQoZ2V0VGltZW91dChcIlNMT1dcIikpO1xyXG4gICAgICBmYy5hc3NlcnQoXHJcbiAgICAgICAgZmMucHJvcGVydHkoXHJcbiAgICAgICAgICBmYy5pbnRlZ2VyKHsgbWluOiAzMjAsIG1heDogMTQ0MCB9KSxcclxuICAgICAgICAgIGZjLmNvbnN0YW50RnJvbShcInNtXCIgYXMgY29uc3QsIFwibWRcIiBhcyBjb25zdCwgXCJsZ1wiIGFzIGNvbnN0LCBcInhsXCIgYXMgY29uc3QpLFxyXG4gICAgICAgICAgZmMub25lb2Yoc2hvcnRDb250ZW50QXJiaXRyYXJ5LCB0YWxsQ29udGVudEFyYml0cmFyeSksXHJcbiAgICAgICAgICBmYy5vcHRpb24oZmMuc3RyaW5nKHsgbWluTGVuZ3RoOiA1LCBtYXhMZW5ndGg6IDUwIH0pLCB7IG5pbDogdW5kZWZpbmVkIH0pLFxyXG4gICAgICAgICAgKHZpZXdwb3J0V2lkdGgsIHNpemUsIGNvbnRlbnRMaW5lcywgdGl0bGUpID0+IHtcclxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHdpbmRvdywgXCJpbm5lcldpZHRoXCIsIHtcclxuICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgdmFsdWU6IHZpZXdwb3J0V2lkdGgsXHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgeyBjb250YWluZXIgfSA9IHJlbmRlcihcclxuICAgICAgICAgICAgICA8TW9kYWwgaXNPcGVuPXt0cnVlfSBvbkNsb3NlPXsoKSA9PiB7fX0gc2l6ZT17c2l6ZX0gdGl0bGU9e3RpdGxlfT5cclxuICAgICAgICAgICAgICAgIDxkaXY+XHJcbiAgICAgICAgICAgICAgICAgIHtjb250ZW50TGluZXMubWFwKChsaW5lLCBpbmRleCkgPT4gKFxyXG4gICAgICAgICAgICAgICAgICAgIDxwIGtleT17aW5kZXh9PntsaW5lfTwvcD5cclxuICAgICAgICAgICAgICAgICAgKSl9XHJcbiAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICA8L01vZGFsPlxyXG4gICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgY29udGVudENvbnRhaW5lciA9IGZpbmRNb2RhbENvbnRlbnRDb250YWluZXIoY29udGFpbmVyKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChjb250ZW50Q29udGFpbmVyKSB7XHJcbiAgICAgICAgICAgICAgLy8gQWxsIG1vZGFscyBzaG91bGQgaGF2ZSBzY3JvbGxpbmcgY2FwYWJpbGl0eVxyXG4gICAgICAgICAgICAgIGV4cGVjdChjb250ZW50Q29udGFpbmVyLmNsYXNzTmFtZSkudG9NYXRjaCgvb3ZlcmZsb3cteS1hdXRvLyk7XHJcbiAgICAgICAgICAgICAgZXhwZWN0KGNvbnRlbnRDb250YWluZXIuY2xhc3NOYW1lKS50b01hdGNoKC9tYXgtaC1cXFs4NXZoXFxdLyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICApLFxyXG4gICAgICAgIHsgbnVtUnVuczogZ2V0TnVtUnVucyhcIk1FRElVTVwiKSB9XHJcbiAgICAgICk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBpdChcInNob3VsZCBlbnN1cmUgY29uc2lzdGVudCBzY3JvbGxpbmcgYmVoYXZpb3IgYWNyb3NzIG1vZGFsIGxpZmVjeWNsZVwiLCAoKSA9PiB7XHJcbiAgICAgIGplc3Quc2V0VGltZW91dChnZXRUaW1lb3V0KFwiU0xPV1wiKSk7XHJcbiAgICAgIGZjLmFzc2VydChcclxuICAgICAgICBmYy5wcm9wZXJ0eShcclxuICAgICAgICAgIGZjLmFycmF5KGZjLnN0cmluZyh7IG1pbkxlbmd0aDogMjAsIG1heExlbmd0aDogMTAwIH0pLCB7IG1pbkxlbmd0aDogMTAsIG1heExlbmd0aDogMzAgfSksXHJcbiAgICAgICAgICAoY29udGVudExpbmVzKSA9PiB7XHJcbiAgICAgICAgICAgIC8vIFJlbmRlciBtb2RhbFxyXG4gICAgICAgICAgICBjb25zdCB7IGNvbnRhaW5lciwgcmVyZW5kZXIgfSA9IHJlbmRlcihcclxuICAgICAgICAgICAgICA8TW9kYWwgaXNPcGVuPXt0cnVlfSBvbkNsb3NlPXsoKSA9PiB7fX0gc2l6ZT1cIm1kXCI+XHJcbiAgICAgICAgICAgICAgICA8ZGl2PlxyXG4gICAgICAgICAgICAgICAgICB7Y29udGVudExpbmVzLm1hcCgobGluZSwgaW5kZXgpID0+IChcclxuICAgICAgICAgICAgICAgICAgICA8cCBrZXk9e2luZGV4fT57bGluZX08L3A+XHJcbiAgICAgICAgICAgICAgICAgICkpfVxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgPC9Nb2RhbD5cclxuICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgIGxldCBjb250ZW50Q29udGFpbmVyID0gZmluZE1vZGFsQ29udGVudENvbnRhaW5lcihjb250YWluZXIpO1xyXG5cclxuICAgICAgICAgICAgaWYgKGNvbnRlbnRDb250YWluZXIpIHtcclxuICAgICAgICAgICAgICBleHBlY3QoY29udGVudENvbnRhaW5lci5jbGFzc05hbWUpLnRvTWF0Y2goL292ZXJmbG93LXktYXV0by8pO1xyXG4gICAgICAgICAgICAgIGV4cGVjdChjb250ZW50Q29udGFpbmVyLmNsYXNzTmFtZSkudG9NYXRjaCgvbWF4LWgtXFxbODV2aFxcXS8pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBSZS1yZW5kZXIgd2l0aCBkaWZmZXJlbnQgY29udGVudFxyXG4gICAgICAgICAgICByZXJlbmRlcihcclxuICAgICAgICAgICAgICA8TW9kYWwgaXNPcGVuPXt0cnVlfSBvbkNsb3NlPXsoKSA9PiB7fX0gc2l6ZT1cImxnXCI+XHJcbiAgICAgICAgICAgICAgICA8ZGl2PlxyXG4gICAgICAgICAgICAgICAgICB7Y29udGVudExpbmVzLnNsaWNlKDAsIDUpLm1hcCgobGluZSwgaW5kZXgpID0+IChcclxuICAgICAgICAgICAgICAgICAgICA8cCBrZXk9e2luZGV4fT57bGluZX08L3A+XHJcbiAgICAgICAgICAgICAgICAgICkpfVxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgPC9Nb2RhbD5cclxuICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgIGNvbnRlbnRDb250YWluZXIgPSBmaW5kTW9kYWxDb250ZW50Q29udGFpbmVyKGNvbnRhaW5lcik7XHJcblxyXG4gICAgICAgICAgICBpZiAoY29udGVudENvbnRhaW5lcikge1xyXG4gICAgICAgICAgICAgIC8vIFNjcm9sbGluZyBwcm9wZXJ0aWVzIHNob3VsZCBwZXJzaXN0IGFmdGVyIHJlLXJlbmRlclxyXG4gICAgICAgICAgICAgIGV4cGVjdChjb250ZW50Q29udGFpbmVyLmNsYXNzTmFtZSkudG9NYXRjaCgvb3ZlcmZsb3cteS1hdXRvLyk7XHJcbiAgICAgICAgICAgICAgZXhwZWN0KGNvbnRlbnRDb250YWluZXIuY2xhc3NOYW1lKS50b01hdGNoKC9tYXgtaC1cXFs4NXZoXFxdLyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICApLFxyXG4gICAgICAgIHsgbnVtUnVuczogZ2V0TnVtUnVucyhcIkZBU1RcIikgfVxyXG4gICAgICApO1xyXG4gICAgfSk7XHJcbiAgfSk7XHJcbn0pO1xyXG4iXSwibmFtZXMiOlsiZGVzY3JpYmVPclNraXAiLCJwcm9jZXNzIiwiZW52IiwiQ0kiLCJkZXNjcmliZSIsInNraXAiLCJNQVhfTU9EQUxfSEVJR0hUX1ZIIiwiZ2V0Q29tcHV0ZWRPdmVyZmxvdyIsImVsZW1lbnQiLCJjb21wdXRlZFN0eWxlIiwid2luZG93IiwiZ2V0Q29tcHV0ZWRTdHlsZSIsIm92ZXJmbG93WSIsImhhc01heEhlaWdodENvbnN0cmFpbnQiLCJjbGFzc2VzIiwiY2xhc3NOYW1lIiwiaW5jbHVkZXMiLCJmaW5kTW9kYWxDb250ZW50Q29udGFpbmVyIiwiY29udGFpbmVyIiwiY29udGVudENvbnRhaW5lciIsInF1ZXJ5U2VsZWN0b3IiLCJ0YWxsQ29udGVudEFyYml0cmFyeSIsImZjIiwiYXJyYXkiLCJzdHJpbmciLCJtaW5MZW5ndGgiLCJtYXhMZW5ndGgiLCJzaG9ydENvbnRlbnRBcmJpdHJhcnkiLCJpdCIsImplc3QiLCJzZXRUaW1lb3V0IiwiZ2V0VGltZW91dCIsImFzc2VydCIsInByb3BlcnR5IiwiY29uc3RhbnRGcm9tIiwic2l6ZSIsImNvbnRlbnRMaW5lcyIsInJlbmRlciIsIk1vZGFsIiwiaXNPcGVuIiwib25DbG9zZSIsImRpdiIsIm1hcCIsImxpbmUiLCJpbmRleCIsInAiLCJleHBlY3QiLCJ0b01hdGNoIiwidG9Db250YWluIiwibnVtUnVucyIsImdldE51bVJ1bnMiLCJvbmVvZiIsInN0eWxlIiwibWluSGVpZ2h0IiwidG9CZSIsInNpemVzIiwiZm9yRWFjaCIsImludGVnZXIiLCJtaW4iLCJtYXgiLCJ2aWV3cG9ydFdpZHRoIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJ3cml0YWJsZSIsImNvbmZpZ3VyYWJsZSIsInZhbHVlIiwicGFkZGluZyIsInJlY29yZCIsImxhYmVsIiwidHlwZSIsImZpZWxkcyIsInRpdGxlIiwiZm9ybSIsImZpZWxkIiwibWFyZ2luQm90dG9tIiwidGV4dGFyZWEiLCJ3aWR0aCIsImhlaWdodCIsImlucHV0IiwiaXRlbXMiLCJzZWN0aW9ucyIsInNlY3Rpb24iLCJzZWN0aW9uSW5kZXgiLCJoMyIsInVsIiwiaXRlbSIsIml0ZW1JbmRleCIsImxpIiwiY29udGVudCIsImNvbnRlbnRCbG9ja3MiLCJibG9jayIsImJhY2tncm91bmQiLCJ2aWV3cG9ydEhlaWdodCIsIm9wdGlvbiIsIm5pbCIsInVuZGVmaW5lZCIsInJlcmVuZGVyIiwic2xpY2UiXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Q0FZQzs7Ozs7OERBRWlC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