d7dcb477eba4974b55e4fb25427e7be8
/**
 * Unit tests — TrendChart
 * Тестирование интерактивности графиков на сенсорных экранах
 * Требования: 3.5
 */ "use strict";
// Mock Chart.js to access tooltip functionality
jest.mock("react-chartjs-2", ()=>({
        Line: jest.fn(({ data, options })=>{
            // Store the chart configuration for testing
            const chartId = "test-chart";
            return /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                "data-testid": "chart-container",
                "data-chart-id": chartId,
                children: /*#__PURE__*/ (0, _jsxruntime.jsx)("canvas", {
                    "data-testid": "chart-canvas"
                })
            });
        })
    }));
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _jsxruntime = require("react/jsx-runtime");
const _react = /*#__PURE__*/ _interop_require_default(require("react"));
const _react1 = require("@testing-library/react");
const _TrendChart = require("../../src/components/dashboard/TrendChart");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
describe("TrendChart - Touch Interactivity", ()=>{
    const mockIncomeData = [
        {
            date: "2024-01-01",
            amount: 5000
        },
        {
            date: "2024-01-02",
            amount: 6000
        },
        {
            date: "2024-01-03",
            amount: 5500
        }
    ];
    const mockExpenseData = [
        {
            date: "2024-01-01",
            amount: 3000
        },
        {
            date: "2024-01-02",
            amount: 3500
        },
        {
            date: "2024-01-03",
            amount: 3200
        }
    ];
    beforeEach(()=>{
        // Reset mocks before each test
        jest.clearAllMocks();
    });
    describe("tooltip configuration for touch events", ()=>{
        it("should configure tooltip with mode 'index' for touch interaction", ()=>{
            const { Line } = require("react-chartjs-2");
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_TrendChart.TrendChart, {
                incomeData: mockIncomeData,
                expenseData: mockExpenseData
            }));
            // Verify Line component was called
            expect(Line).toHaveBeenCalled();
            // Get the options passed to the Line component
            const callArgs = Line.mock.calls[0];
            const options = callArgs[0].options;
            // Verify tooltip configuration supports touch interaction
            expect(options.plugins.tooltip).toBeDefined();
            expect(options.plugins.tooltip.mode).toBe("index");
            expect(options.plugins.tooltip.intersect).toBe(false);
        });
        it("should configure tooltip with proper styling for visibility", ()=>{
            const { Line } = require("react-chartjs-2");
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_TrendChart.TrendChart, {
                incomeData: mockIncomeData,
                expenseData: mockExpenseData
            }));
            const callArgs = Line.mock.calls[0];
            const tooltipConfig = callArgs[0].options.plugins.tooltip;
            // Verify tooltip has proper styling for touch screens
            expect(tooltipConfig.backgroundColor).toBeDefined();
            expect(tooltipConfig.titleColor).toBeDefined();
            expect(tooltipConfig.bodyColor).toBeDefined();
            expect(tooltipConfig.borderColor).toBeDefined();
            expect(tooltipConfig.borderWidth).toBeDefined();
            expect(tooltipConfig.padding).toBeDefined();
            expect(tooltipConfig.cornerRadius).toBeDefined();
        });
        it("should format tooltip labels with currency", ()=>{
            const { Line } = require("react-chartjs-2");
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_TrendChart.TrendChart, {
                incomeData: mockIncomeData,
                expenseData: mockExpenseData
            }));
            const callArgs = Line.mock.calls[0];
            const tooltipConfig = callArgs[0].options.plugins.tooltip;
            // Verify tooltip has label callback for formatting
            expect(tooltipConfig.callbacks).toBeDefined();
            expect(tooltipConfig.callbacks.label).toBeDefined();
            expect(typeof tooltipConfig.callbacks.label).toBe("function");
            // Test the label formatter
            const mockContext = {
                dataset: {
                    label: "Доходы"
                },
                parsed: {
                    y: 5000
                }
            };
            const formattedLabel = tooltipConfig.callbacks.label(mockContext);
            expect(formattedLabel).toContain("Доходы");
            expect(formattedLabel).toContain("5");
        });
    });
    describe("responsive tooltip behavior", ()=>{
        it("should maintain tooltip configuration on mobile viewports", ()=>{
            const { Line } = require("react-chartjs-2");
            // Set mobile viewport
            Object.defineProperty(window, "innerWidth", {
                writable: true,
                configurable: true,
                value: 375
            });
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_TrendChart.TrendChart, {
                incomeData: mockIncomeData,
                expenseData: mockExpenseData
            }));
            const callArgs = Line.mock.calls[0];
            const tooltipConfig = callArgs[0].options.plugins.tooltip;
            // Tooltip should still be configured on mobile
            expect(tooltipConfig.mode).toBe("index");
            expect(tooltipConfig.intersect).toBe(false);
        });
        it("should maintain tooltip configuration on tablet viewports", ()=>{
            const { Line } = require("react-chartjs-2");
            // Set tablet viewport
            Object.defineProperty(window, "innerWidth", {
                writable: true,
                configurable: true,
                value: 768
            });
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_TrendChart.TrendChart, {
                incomeData: mockIncomeData,
                expenseData: mockExpenseData
            }));
            const callArgs = Line.mock.calls[0];
            const tooltipConfig = callArgs[0].options.plugins.tooltip;
            // Tooltip should still be configured on tablet
            expect(tooltipConfig.mode).toBe("index");
            expect(tooltipConfig.intersect).toBe(false);
        });
        it("should maintain tooltip configuration on desktop viewports", ()=>{
            const { Line } = require("react-chartjs-2");
            // Set desktop viewport
            Object.defineProperty(window, "innerWidth", {
                writable: true,
                configurable: true,
                value: 1024
            });
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_TrendChart.TrendChart, {
                incomeData: mockIncomeData,
                expenseData: mockExpenseData
            }));
            const callArgs = Line.mock.calls[0];
            const tooltipConfig = callArgs[0].options.plugins.tooltip;
            // Tooltip should be configured on desktop
            expect(tooltipConfig.mode).toBe("index");
            expect(tooltipConfig.intersect).toBe(false);
        });
    });
    describe("chart rendering with tooltip support", ()=>{
        it("should render chart canvas for touch interaction", ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_TrendChart.TrendChart, {
                incomeData: mockIncomeData,
                expenseData: mockExpenseData
            }));
            const canvas = _react1.screen.getByTestId("chart-canvas");
            expect(canvas).toBeInTheDocument();
            expect(canvas.tagName).toBe("CANVAS");
        });
        it("should render chart with data for tooltip display", ()=>{
            const { Line } = require("react-chartjs-2");
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_TrendChart.TrendChart, {
                incomeData: mockIncomeData,
                expenseData: mockExpenseData
            }));
            const callArgs = Line.mock.calls[0];
            const chartData = callArgs[0].data;
            // Verify chart has data for tooltips to display
            expect(chartData.labels).toHaveLength(3);
            expect(chartData.datasets).toHaveLength(2);
            expect(chartData.datasets[0].label).toBe("Доходы");
            expect(chartData.datasets[1].label).toBe("Расходы");
        });
        it("should not render chart when no data is provided", ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_TrendChart.TrendChart, {
                incomeData: [],
                expenseData: []
            }));
            // Should show "no data" message instead of chart
            expect(_react1.screen.getByText("Нет данных для отображения")).toBeInTheDocument();
            expect(_react1.screen.queryByTestId("chart-canvas")).not.toBeInTheDocument();
        });
    });
    describe("tooltip accessibility on touch devices", ()=>{
        it("should configure tooltip with adequate padding for touch targets", ()=>{
            const { Line } = require("react-chartjs-2");
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_TrendChart.TrendChart, {
                incomeData: mockIncomeData,
                expenseData: mockExpenseData
            }));
            const callArgs = Line.mock.calls[0];
            const tooltipConfig = callArgs[0].options.plugins.tooltip;
            // Tooltip should have adequate padding for readability on touch screens
            expect(tooltipConfig.padding).toBeGreaterThanOrEqual(8);
        });
        it("should configure tooltip with rounded corners for modern touch UI", ()=>{
            const { Line } = require("react-chartjs-2");
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_TrendChart.TrendChart, {
                incomeData: mockIncomeData,
                expenseData: mockExpenseData
            }));
            const callArgs = Line.mock.calls[0];
            const tooltipConfig = callArgs[0].options.plugins.tooltip;
            // Tooltip should have rounded corners for better touch UI
            expect(tooltipConfig.cornerRadius).toBeGreaterThan(0);
        });
    });
    describe("edge cases", ()=>{
        it("should handle tooltip with null values gracefully", ()=>{
            const { Line } = require("react-chartjs-2");
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_TrendChart.TrendChart, {
                incomeData: mockIncomeData,
                expenseData: mockExpenseData
            }));
            const callArgs = Line.mock.calls[0];
            const labelCallback = callArgs[0].options.plugins.tooltip.callbacks.label;
            // Test with null value
            const mockContextWithNull = {
                dataset: {
                    label: "Доходы"
                },
                parsed: {
                    y: null
                }
            };
            const result = labelCallback(mockContextWithNull);
            expect(result).toBe("Доходы");
        });
        it("should handle tooltip with missing label gracefully", ()=>{
            const { Line } = require("react-chartjs-2");
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_TrendChart.TrendChart, {
                incomeData: mockIncomeData,
                expenseData: mockExpenseData
            }));
            const callArgs = Line.mock.calls[0];
            const labelCallback = callArgs[0].options.plugins.tooltip.callbacks.label;
            // Test with missing label
            const mockContextWithoutLabel = {
                dataset: {},
                parsed: {
                    y: 5000
                }
            };
            const result = labelCallback(mockContextWithoutLabel);
            expect(result).toBe("");
        });
        it("should render loading state without tooltip interaction", ()=>{
            const { container } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_TrendChart.TrendChart, {
                incomeData: mockIncomeData,
                expenseData: mockExpenseData,
                loading: true
            }));
            // Should show loading skeleton, not chart
            expect(_react1.screen.queryByTestId("chart-canvas")).not.toBeInTheDocument();
            const skeleton = container.querySelector(".animate-pulse");
            expect(skeleton).toBeInTheDocument();
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkU6XFxteVxcb3R1c1xcZmluYW5jZV90cmFja2VyXFxmcm9udGVuZFxcX190ZXN0c19fXFxjb21wb25lbnRzXFxUcmVuZENoYXJ0LnRlc3QudHN4Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBVbml0IHRlc3RzIOKAlCBUcmVuZENoYXJ0XHJcbiAqINCi0LXRgdGC0LjRgNC+0LLQsNC90LjQtSDQuNC90YLQtdGA0LDQutGC0LjQstC90L7RgdGC0Lgg0LPRgNCw0YTQuNC60L7QsiDQvdCwINGB0LXQvdGB0L7RgNC90YvRhSDRjdC60YDQsNC90LDRhVxyXG4gKiDQotGA0LXQsdC+0LLQsNC90LjRjzogMy41XHJcbiAqL1xyXG5pbXBvcnQgUmVhY3QgZnJvbSBcInJlYWN0XCI7XHJcbmltcG9ydCB7IHJlbmRlciwgc2NyZWVuLCB3YWl0Rm9yIH0gZnJvbSBcIkB0ZXN0aW5nLWxpYnJhcnkvcmVhY3RcIjtcclxuaW1wb3J0IHsgVHJlbmRDaGFydCB9IGZyb20gXCJAL2NvbXBvbmVudHMvZGFzaGJvYXJkL1RyZW5kQ2hhcnRcIjtcclxuaW1wb3J0IHsgQ2hhcnQgfSBmcm9tIFwiY2hhcnQuanNcIjtcclxuXHJcbi8vIE1vY2sgQ2hhcnQuanMgdG8gYWNjZXNzIHRvb2x0aXAgZnVuY3Rpb25hbGl0eVxyXG5qZXN0Lm1vY2soXCJyZWFjdC1jaGFydGpzLTJcIiwgKCkgPT4gKHtcclxuICBMaW5lOiBqZXN0LmZuKCh7IGRhdGEsIG9wdGlvbnMgfSkgPT4ge1xyXG4gICAgLy8gU3RvcmUgdGhlIGNoYXJ0IGNvbmZpZ3VyYXRpb24gZm9yIHRlc3RpbmdcclxuICAgIGNvbnN0IGNoYXJ0SWQgPSBcInRlc3QtY2hhcnRcIjtcclxuICAgIHJldHVybiAoXHJcbiAgICAgIDxkaXYgZGF0YS10ZXN0aWQ9XCJjaGFydC1jb250YWluZXJcIiBkYXRhLWNoYXJ0LWlkPXtjaGFydElkfT5cclxuICAgICAgICA8Y2FudmFzIGRhdGEtdGVzdGlkPVwiY2hhcnQtY2FudmFzXCIgLz5cclxuICAgICAgPC9kaXY+XHJcbiAgICApO1xyXG4gIH0pLFxyXG59KSk7XHJcblxyXG5kZXNjcmliZShcIlRyZW5kQ2hhcnQgLSBUb3VjaCBJbnRlcmFjdGl2aXR5XCIsICgpID0+IHtcclxuICBjb25zdCBtb2NrSW5jb21lRGF0YSA9IFtcclxuICAgIHsgZGF0ZTogXCIyMDI0LTAxLTAxXCIsIGFtb3VudDogNTAwMCB9LFxyXG4gICAgeyBkYXRlOiBcIjIwMjQtMDEtMDJcIiwgYW1vdW50OiA2MDAwIH0sXHJcbiAgICB7IGRhdGU6IFwiMjAyNC0wMS0wM1wiLCBhbW91bnQ6IDU1MDAgfSxcclxuICBdO1xyXG5cclxuICBjb25zdCBtb2NrRXhwZW5zZURhdGEgPSBbXHJcbiAgICB7IGRhdGU6IFwiMjAyNC0wMS0wMVwiLCBhbW91bnQ6IDMwMDAgfSxcclxuICAgIHsgZGF0ZTogXCIyMDI0LTAxLTAyXCIsIGFtb3VudDogMzUwMCB9LFxyXG4gICAgeyBkYXRlOiBcIjIwMjQtMDEtMDNcIiwgYW1vdW50OiAzMjAwIH0sXHJcbiAgXTtcclxuXHJcbiAgYmVmb3JlRWFjaCgoKSA9PiB7XHJcbiAgICAvLyBSZXNldCBtb2NrcyBiZWZvcmUgZWFjaCB0ZXN0XHJcbiAgICBqZXN0LmNsZWFyQWxsTW9ja3MoKTtcclxuICB9KTtcclxuXHJcbiAgZGVzY3JpYmUoXCJ0b29sdGlwIGNvbmZpZ3VyYXRpb24gZm9yIHRvdWNoIGV2ZW50c1wiLCAoKSA9PiB7XHJcbiAgICBpdChcInNob3VsZCBjb25maWd1cmUgdG9vbHRpcCB3aXRoIG1vZGUgJ2luZGV4JyBmb3IgdG91Y2ggaW50ZXJhY3Rpb25cIiwgKCkgPT4ge1xyXG4gICAgICBjb25zdCB7IExpbmUgfSA9IHJlcXVpcmUoXCJyZWFjdC1jaGFydGpzLTJcIik7XHJcbiAgICAgIFxyXG4gICAgICByZW5kZXIoXHJcbiAgICAgICAgPFRyZW5kQ2hhcnRcclxuICAgICAgICAgIGluY29tZURhdGE9e21vY2tJbmNvbWVEYXRhfVxyXG4gICAgICAgICAgZXhwZW5zZURhdGE9e21vY2tFeHBlbnNlRGF0YX1cclxuICAgICAgICAvPlxyXG4gICAgICApO1xyXG5cclxuICAgICAgLy8gVmVyaWZ5IExpbmUgY29tcG9uZW50IHdhcyBjYWxsZWRcclxuICAgICAgZXhwZWN0KExpbmUpLnRvSGF2ZUJlZW5DYWxsZWQoKTtcclxuXHJcbiAgICAgIC8vIEdldCB0aGUgb3B0aW9ucyBwYXNzZWQgdG8gdGhlIExpbmUgY29tcG9uZW50XHJcbiAgICAgIGNvbnN0IGNhbGxBcmdzID0gTGluZS5tb2NrLmNhbGxzWzBdO1xyXG4gICAgICBjb25zdCBvcHRpb25zID0gY2FsbEFyZ3NbMF0ub3B0aW9ucztcclxuXHJcbiAgICAgIC8vIFZlcmlmeSB0b29sdGlwIGNvbmZpZ3VyYXRpb24gc3VwcG9ydHMgdG91Y2ggaW50ZXJhY3Rpb25cclxuICAgICAgZXhwZWN0KG9wdGlvbnMucGx1Z2lucy50b29sdGlwKS50b0JlRGVmaW5lZCgpO1xyXG4gICAgICBleHBlY3Qob3B0aW9ucy5wbHVnaW5zLnRvb2x0aXAubW9kZSkudG9CZShcImluZGV4XCIpO1xyXG4gICAgICBleHBlY3Qob3B0aW9ucy5wbHVnaW5zLnRvb2x0aXAuaW50ZXJzZWN0KS50b0JlKGZhbHNlKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGl0KFwic2hvdWxkIGNvbmZpZ3VyZSB0b29sdGlwIHdpdGggcHJvcGVyIHN0eWxpbmcgZm9yIHZpc2liaWxpdHlcIiwgKCkgPT4ge1xyXG4gICAgICBjb25zdCB7IExpbmUgfSA9IHJlcXVpcmUoXCJyZWFjdC1jaGFydGpzLTJcIik7XHJcbiAgICAgIFxyXG4gICAgICByZW5kZXIoXHJcbiAgICAgICAgPFRyZW5kQ2hhcnRcclxuICAgICAgICAgIGluY29tZURhdGE9e21vY2tJbmNvbWVEYXRhfVxyXG4gICAgICAgICAgZXhwZW5zZURhdGE9e21vY2tFeHBlbnNlRGF0YX1cclxuICAgICAgICAvPlxyXG4gICAgICApO1xyXG5cclxuICAgICAgY29uc3QgY2FsbEFyZ3MgPSBMaW5lLm1vY2suY2FsbHNbMF07XHJcbiAgICAgIGNvbnN0IHRvb2x0aXBDb25maWcgPSBjYWxsQXJnc1swXS5vcHRpb25zLnBsdWdpbnMudG9vbHRpcDtcclxuXHJcbiAgICAgIC8vIFZlcmlmeSB0b29sdGlwIGhhcyBwcm9wZXIgc3R5bGluZyBmb3IgdG91Y2ggc2NyZWVuc1xyXG4gICAgICBleHBlY3QodG9vbHRpcENvbmZpZy5iYWNrZ3JvdW5kQ29sb3IpLnRvQmVEZWZpbmVkKCk7XHJcbiAgICAgIGV4cGVjdCh0b29sdGlwQ29uZmlnLnRpdGxlQ29sb3IpLnRvQmVEZWZpbmVkKCk7XHJcbiAgICAgIGV4cGVjdCh0b29sdGlwQ29uZmlnLmJvZHlDb2xvcikudG9CZURlZmluZWQoKTtcclxuICAgICAgZXhwZWN0KHRvb2x0aXBDb25maWcuYm9yZGVyQ29sb3IpLnRvQmVEZWZpbmVkKCk7XHJcbiAgICAgIGV4cGVjdCh0b29sdGlwQ29uZmlnLmJvcmRlcldpZHRoKS50b0JlRGVmaW5lZCgpO1xyXG4gICAgICBleHBlY3QodG9vbHRpcENvbmZpZy5wYWRkaW5nKS50b0JlRGVmaW5lZCgpO1xyXG4gICAgICBleHBlY3QodG9vbHRpcENvbmZpZy5jb3JuZXJSYWRpdXMpLnRvQmVEZWZpbmVkKCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBpdChcInNob3VsZCBmb3JtYXQgdG9vbHRpcCBsYWJlbHMgd2l0aCBjdXJyZW5jeVwiLCAoKSA9PiB7XHJcbiAgICAgIGNvbnN0IHsgTGluZSB9ID0gcmVxdWlyZShcInJlYWN0LWNoYXJ0anMtMlwiKTtcclxuICAgICAgXHJcbiAgICAgIHJlbmRlcihcclxuICAgICAgICA8VHJlbmRDaGFydFxyXG4gICAgICAgICAgaW5jb21lRGF0YT17bW9ja0luY29tZURhdGF9XHJcbiAgICAgICAgICBleHBlbnNlRGF0YT17bW9ja0V4cGVuc2VEYXRhfVxyXG4gICAgICAgIC8+XHJcbiAgICAgICk7XHJcblxyXG4gICAgICBjb25zdCBjYWxsQXJncyA9IExpbmUubW9jay5jYWxsc1swXTtcclxuICAgICAgY29uc3QgdG9vbHRpcENvbmZpZyA9IGNhbGxBcmdzWzBdLm9wdGlvbnMucGx1Z2lucy50b29sdGlwO1xyXG5cclxuICAgICAgLy8gVmVyaWZ5IHRvb2x0aXAgaGFzIGxhYmVsIGNhbGxiYWNrIGZvciBmb3JtYXR0aW5nXHJcbiAgICAgIGV4cGVjdCh0b29sdGlwQ29uZmlnLmNhbGxiYWNrcykudG9CZURlZmluZWQoKTtcclxuICAgICAgZXhwZWN0KHRvb2x0aXBDb25maWcuY2FsbGJhY2tzLmxhYmVsKS50b0JlRGVmaW5lZCgpO1xyXG4gICAgICBleHBlY3QodHlwZW9mIHRvb2x0aXBDb25maWcuY2FsbGJhY2tzLmxhYmVsKS50b0JlKFwiZnVuY3Rpb25cIik7XHJcblxyXG4gICAgICAvLyBUZXN0IHRoZSBsYWJlbCBmb3JtYXR0ZXJcclxuICAgICAgY29uc3QgbW9ja0NvbnRleHQgPSB7XHJcbiAgICAgICAgZGF0YXNldDogeyBsYWJlbDogXCLQlNC+0YXQvtC00YtcIiB9LFxyXG4gICAgICAgIHBhcnNlZDogeyB5OiA1MDAwIH0sXHJcbiAgICAgIH07XHJcblxyXG4gICAgICBjb25zdCBmb3JtYXR0ZWRMYWJlbCA9IHRvb2x0aXBDb25maWcuY2FsbGJhY2tzLmxhYmVsKG1vY2tDb250ZXh0KTtcclxuICAgICAgZXhwZWN0KGZvcm1hdHRlZExhYmVsKS50b0NvbnRhaW4oXCLQlNC+0YXQvtC00YtcIik7XHJcbiAgICAgIGV4cGVjdChmb3JtYXR0ZWRMYWJlbCkudG9Db250YWluKFwiNVwiKTtcclxuICAgIH0pO1xyXG4gIH0pO1xyXG5cclxuICBkZXNjcmliZShcInJlc3BvbnNpdmUgdG9vbHRpcCBiZWhhdmlvclwiLCAoKSA9PiB7XHJcbiAgICBpdChcInNob3VsZCBtYWludGFpbiB0b29sdGlwIGNvbmZpZ3VyYXRpb24gb24gbW9iaWxlIHZpZXdwb3J0c1wiLCAoKSA9PiB7XHJcbiAgICAgIGNvbnN0IHsgTGluZSB9ID0gcmVxdWlyZShcInJlYWN0LWNoYXJ0anMtMlwiKTtcclxuICAgICAgXHJcbiAgICAgIC8vIFNldCBtb2JpbGUgdmlld3BvcnRcclxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHdpbmRvdywgXCJpbm5lcldpZHRoXCIsIHtcclxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgdmFsdWU6IDM3NSxcclxuICAgICAgfSk7XHJcblxyXG4gICAgICByZW5kZXIoXHJcbiAgICAgICAgPFRyZW5kQ2hhcnRcclxuICAgICAgICAgIGluY29tZURhdGE9e21vY2tJbmNvbWVEYXRhfVxyXG4gICAgICAgICAgZXhwZW5zZURhdGE9e21vY2tFeHBlbnNlRGF0YX1cclxuICAgICAgICAvPlxyXG4gICAgICApO1xyXG5cclxuICAgICAgY29uc3QgY2FsbEFyZ3MgPSBMaW5lLm1vY2suY2FsbHNbMF07XHJcbiAgICAgIGNvbnN0IHRvb2x0aXBDb25maWcgPSBjYWxsQXJnc1swXS5vcHRpb25zLnBsdWdpbnMudG9vbHRpcDtcclxuXHJcbiAgICAgIC8vIFRvb2x0aXAgc2hvdWxkIHN0aWxsIGJlIGNvbmZpZ3VyZWQgb24gbW9iaWxlXHJcbiAgICAgIGV4cGVjdCh0b29sdGlwQ29uZmlnLm1vZGUpLnRvQmUoXCJpbmRleFwiKTtcclxuICAgICAgZXhwZWN0KHRvb2x0aXBDb25maWcuaW50ZXJzZWN0KS50b0JlKGZhbHNlKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGl0KFwic2hvdWxkIG1haW50YWluIHRvb2x0aXAgY29uZmlndXJhdGlvbiBvbiB0YWJsZXQgdmlld3BvcnRzXCIsICgpID0+IHtcclxuICAgICAgY29uc3QgeyBMaW5lIH0gPSByZXF1aXJlKFwicmVhY3QtY2hhcnRqcy0yXCIpO1xyXG4gICAgICBcclxuICAgICAgLy8gU2V0IHRhYmxldCB2aWV3cG9ydFxyXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkod2luZG93LCBcImlubmVyV2lkdGhcIiwge1xyXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICB2YWx1ZTogNzY4LFxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIHJlbmRlcihcclxuICAgICAgICA8VHJlbmRDaGFydFxyXG4gICAgICAgICAgaW5jb21lRGF0YT17bW9ja0luY29tZURhdGF9XHJcbiAgICAgICAgICBleHBlbnNlRGF0YT17bW9ja0V4cGVuc2VEYXRhfVxyXG4gICAgICAgIC8+XHJcbiAgICAgICk7XHJcblxyXG4gICAgICBjb25zdCBjYWxsQXJncyA9IExpbmUubW9jay5jYWxsc1swXTtcclxuICAgICAgY29uc3QgdG9vbHRpcENvbmZpZyA9IGNhbGxBcmdzWzBdLm9wdGlvbnMucGx1Z2lucy50b29sdGlwO1xyXG5cclxuICAgICAgLy8gVG9vbHRpcCBzaG91bGQgc3RpbGwgYmUgY29uZmlndXJlZCBvbiB0YWJsZXRcclxuICAgICAgZXhwZWN0KHRvb2x0aXBDb25maWcubW9kZSkudG9CZShcImluZGV4XCIpO1xyXG4gICAgICBleHBlY3QodG9vbHRpcENvbmZpZy5pbnRlcnNlY3QpLnRvQmUoZmFsc2UpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaXQoXCJzaG91bGQgbWFpbnRhaW4gdG9vbHRpcCBjb25maWd1cmF0aW9uIG9uIGRlc2t0b3Agdmlld3BvcnRzXCIsICgpID0+IHtcclxuICAgICAgY29uc3QgeyBMaW5lIH0gPSByZXF1aXJlKFwicmVhY3QtY2hhcnRqcy0yXCIpO1xyXG4gICAgICBcclxuICAgICAgLy8gU2V0IGRlc2t0b3Agdmlld3BvcnRcclxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHdpbmRvdywgXCJpbm5lcldpZHRoXCIsIHtcclxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgdmFsdWU6IDEwMjQsXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgcmVuZGVyKFxyXG4gICAgICAgIDxUcmVuZENoYXJ0XHJcbiAgICAgICAgICBpbmNvbWVEYXRhPXttb2NrSW5jb21lRGF0YX1cclxuICAgICAgICAgIGV4cGVuc2VEYXRhPXttb2NrRXhwZW5zZURhdGF9XHJcbiAgICAgICAgLz5cclxuICAgICAgKTtcclxuXHJcbiAgICAgIGNvbnN0IGNhbGxBcmdzID0gTGluZS5tb2NrLmNhbGxzWzBdO1xyXG4gICAgICBjb25zdCB0b29sdGlwQ29uZmlnID0gY2FsbEFyZ3NbMF0ub3B0aW9ucy5wbHVnaW5zLnRvb2x0aXA7XHJcblxyXG4gICAgICAvLyBUb29sdGlwIHNob3VsZCBiZSBjb25maWd1cmVkIG9uIGRlc2t0b3BcclxuICAgICAgZXhwZWN0KHRvb2x0aXBDb25maWcubW9kZSkudG9CZShcImluZGV4XCIpO1xyXG4gICAgICBleHBlY3QodG9vbHRpcENvbmZpZy5pbnRlcnNlY3QpLnRvQmUoZmFsc2UpO1xyXG4gICAgfSk7XHJcbiAgfSk7XHJcblxyXG4gIGRlc2NyaWJlKFwiY2hhcnQgcmVuZGVyaW5nIHdpdGggdG9vbHRpcCBzdXBwb3J0XCIsICgpID0+IHtcclxuICAgIGl0KFwic2hvdWxkIHJlbmRlciBjaGFydCBjYW52YXMgZm9yIHRvdWNoIGludGVyYWN0aW9uXCIsICgpID0+IHtcclxuICAgICAgcmVuZGVyKFxyXG4gICAgICAgIDxUcmVuZENoYXJ0XHJcbiAgICAgICAgICBpbmNvbWVEYXRhPXttb2NrSW5jb21lRGF0YX1cclxuICAgICAgICAgIGV4cGVuc2VEYXRhPXttb2NrRXhwZW5zZURhdGF9XHJcbiAgICAgICAgLz5cclxuICAgICAgKTtcclxuXHJcbiAgICAgIGNvbnN0IGNhbnZhcyA9IHNjcmVlbi5nZXRCeVRlc3RJZChcImNoYXJ0LWNhbnZhc1wiKTtcclxuICAgICAgZXhwZWN0KGNhbnZhcykudG9CZUluVGhlRG9jdW1lbnQoKTtcclxuICAgICAgZXhwZWN0KGNhbnZhcy50YWdOYW1lKS50b0JlKFwiQ0FOVkFTXCIpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaXQoXCJzaG91bGQgcmVuZGVyIGNoYXJ0IHdpdGggZGF0YSBmb3IgdG9vbHRpcCBkaXNwbGF5XCIsICgpID0+IHtcclxuICAgICAgY29uc3QgeyBMaW5lIH0gPSByZXF1aXJlKFwicmVhY3QtY2hhcnRqcy0yXCIpO1xyXG4gICAgICBcclxuICAgICAgcmVuZGVyKFxyXG4gICAgICAgIDxUcmVuZENoYXJ0XHJcbiAgICAgICAgICBpbmNvbWVEYXRhPXttb2NrSW5jb21lRGF0YX1cclxuICAgICAgICAgIGV4cGVuc2VEYXRhPXttb2NrRXhwZW5zZURhdGF9XHJcbiAgICAgICAgLz5cclxuICAgICAgKTtcclxuXHJcbiAgICAgIGNvbnN0IGNhbGxBcmdzID0gTGluZS5tb2NrLmNhbGxzWzBdO1xyXG4gICAgICBjb25zdCBjaGFydERhdGEgPSBjYWxsQXJnc1swXS5kYXRhO1xyXG5cclxuICAgICAgLy8gVmVyaWZ5IGNoYXJ0IGhhcyBkYXRhIGZvciB0b29sdGlwcyB0byBkaXNwbGF5XHJcbiAgICAgIGV4cGVjdChjaGFydERhdGEubGFiZWxzKS50b0hhdmVMZW5ndGgoMyk7XHJcbiAgICAgIGV4cGVjdChjaGFydERhdGEuZGF0YXNldHMpLnRvSGF2ZUxlbmd0aCgyKTtcclxuICAgICAgZXhwZWN0KGNoYXJ0RGF0YS5kYXRhc2V0c1swXS5sYWJlbCkudG9CZShcItCU0L7RhdC+0LTRi1wiKTtcclxuICAgICAgZXhwZWN0KGNoYXJ0RGF0YS5kYXRhc2V0c1sxXS5sYWJlbCkudG9CZShcItCg0LDRgdGF0L7QtNGLXCIpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaXQoXCJzaG91bGQgbm90IHJlbmRlciBjaGFydCB3aGVuIG5vIGRhdGEgaXMgcHJvdmlkZWRcIiwgKCkgPT4ge1xyXG4gICAgICByZW5kZXIoPFRyZW5kQ2hhcnQgaW5jb21lRGF0YT17W119IGV4cGVuc2VEYXRhPXtbXX0gLz4pO1xyXG5cclxuICAgICAgLy8gU2hvdWxkIHNob3cgXCJubyBkYXRhXCIgbWVzc2FnZSBpbnN0ZWFkIG9mIGNoYXJ0XHJcbiAgICAgIGV4cGVjdChzY3JlZW4uZ2V0QnlUZXh0KFwi0J3QtdGCINC00LDQvdC90YvRhSDQtNC70Y8g0L7RgtC+0LHRgNCw0LbQtdC90LjRj1wiKSkudG9CZUluVGhlRG9jdW1lbnQoKTtcclxuICAgICAgZXhwZWN0KHNjcmVlbi5xdWVyeUJ5VGVzdElkKFwiY2hhcnQtY2FudmFzXCIpKS5ub3QudG9CZUluVGhlRG9jdW1lbnQoKTtcclxuICAgIH0pO1xyXG4gIH0pO1xyXG5cclxuICBkZXNjcmliZShcInRvb2x0aXAgYWNjZXNzaWJpbGl0eSBvbiB0b3VjaCBkZXZpY2VzXCIsICgpID0+IHtcclxuICAgIGl0KFwic2hvdWxkIGNvbmZpZ3VyZSB0b29sdGlwIHdpdGggYWRlcXVhdGUgcGFkZGluZyBmb3IgdG91Y2ggdGFyZ2V0c1wiLCAoKSA9PiB7XHJcbiAgICAgIGNvbnN0IHsgTGluZSB9ID0gcmVxdWlyZShcInJlYWN0LWNoYXJ0anMtMlwiKTtcclxuICAgICAgXHJcbiAgICAgIHJlbmRlcihcclxuICAgICAgICA8VHJlbmRDaGFydFxyXG4gICAgICAgICAgaW5jb21lRGF0YT17bW9ja0luY29tZURhdGF9XHJcbiAgICAgICAgICBleHBlbnNlRGF0YT17bW9ja0V4cGVuc2VEYXRhfVxyXG4gICAgICAgIC8+XHJcbiAgICAgICk7XHJcblxyXG4gICAgICBjb25zdCBjYWxsQXJncyA9IExpbmUubW9jay5jYWxsc1swXTtcclxuICAgICAgY29uc3QgdG9vbHRpcENvbmZpZyA9IGNhbGxBcmdzWzBdLm9wdGlvbnMucGx1Z2lucy50b29sdGlwO1xyXG5cclxuICAgICAgLy8gVG9vbHRpcCBzaG91bGQgaGF2ZSBhZGVxdWF0ZSBwYWRkaW5nIGZvciByZWFkYWJpbGl0eSBvbiB0b3VjaCBzY3JlZW5zXHJcbiAgICAgIGV4cGVjdCh0b29sdGlwQ29uZmlnLnBhZGRpbmcpLnRvQmVHcmVhdGVyVGhhbk9yRXF1YWwoOCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBpdChcInNob3VsZCBjb25maWd1cmUgdG9vbHRpcCB3aXRoIHJvdW5kZWQgY29ybmVycyBmb3IgbW9kZXJuIHRvdWNoIFVJXCIsICgpID0+IHtcclxuICAgICAgY29uc3QgeyBMaW5lIH0gPSByZXF1aXJlKFwicmVhY3QtY2hhcnRqcy0yXCIpO1xyXG4gICAgICBcclxuICAgICAgcmVuZGVyKFxyXG4gICAgICAgIDxUcmVuZENoYXJ0XHJcbiAgICAgICAgICBpbmNvbWVEYXRhPXttb2NrSW5jb21lRGF0YX1cclxuICAgICAgICAgIGV4cGVuc2VEYXRhPXttb2NrRXhwZW5zZURhdGF9XHJcbiAgICAgICAgLz5cclxuICAgICAgKTtcclxuXHJcbiAgICAgIGNvbnN0IGNhbGxBcmdzID0gTGluZS5tb2NrLmNhbGxzWzBdO1xyXG4gICAgICBjb25zdCB0b29sdGlwQ29uZmlnID0gY2FsbEFyZ3NbMF0ub3B0aW9ucy5wbHVnaW5zLnRvb2x0aXA7XHJcblxyXG4gICAgICAvLyBUb29sdGlwIHNob3VsZCBoYXZlIHJvdW5kZWQgY29ybmVycyBmb3IgYmV0dGVyIHRvdWNoIFVJXHJcbiAgICAgIGV4cGVjdCh0b29sdGlwQ29uZmlnLmNvcm5lclJhZGl1cykudG9CZUdyZWF0ZXJUaGFuKDApO1xyXG4gICAgfSk7XHJcbiAgfSk7XHJcblxyXG4gIGRlc2NyaWJlKFwiZWRnZSBjYXNlc1wiLCAoKSA9PiB7XHJcbiAgICBpdChcInNob3VsZCBoYW5kbGUgdG9vbHRpcCB3aXRoIG51bGwgdmFsdWVzIGdyYWNlZnVsbHlcIiwgKCkgPT4ge1xyXG4gICAgICBjb25zdCB7IExpbmUgfSA9IHJlcXVpcmUoXCJyZWFjdC1jaGFydGpzLTJcIik7XHJcbiAgICAgIFxyXG4gICAgICByZW5kZXIoXHJcbiAgICAgICAgPFRyZW5kQ2hhcnRcclxuICAgICAgICAgIGluY29tZURhdGE9e21vY2tJbmNvbWVEYXRhfVxyXG4gICAgICAgICAgZXhwZW5zZURhdGE9e21vY2tFeHBlbnNlRGF0YX1cclxuICAgICAgICAvPlxyXG4gICAgICApO1xyXG5cclxuICAgICAgY29uc3QgY2FsbEFyZ3MgPSBMaW5lLm1vY2suY2FsbHNbMF07XHJcbiAgICAgIGNvbnN0IGxhYmVsQ2FsbGJhY2sgPSBjYWxsQXJnc1swXS5vcHRpb25zLnBsdWdpbnMudG9vbHRpcC5jYWxsYmFja3MubGFiZWw7XHJcblxyXG4gICAgICAvLyBUZXN0IHdpdGggbnVsbCB2YWx1ZVxyXG4gICAgICBjb25zdCBtb2NrQ29udGV4dFdpdGhOdWxsID0ge1xyXG4gICAgICAgIGRhdGFzZXQ6IHsgbGFiZWw6IFwi0JTQvtGF0L7QtNGLXCIgfSxcclxuICAgICAgICBwYXJzZWQ6IHsgeTogbnVsbCB9LFxyXG4gICAgICB9O1xyXG5cclxuICAgICAgY29uc3QgcmVzdWx0ID0gbGFiZWxDYWxsYmFjayhtb2NrQ29udGV4dFdpdGhOdWxsKTtcclxuICAgICAgZXhwZWN0KHJlc3VsdCkudG9CZShcItCU0L7RhdC+0LTRi1wiKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGl0KFwic2hvdWxkIGhhbmRsZSB0b29sdGlwIHdpdGggbWlzc2luZyBsYWJlbCBncmFjZWZ1bGx5XCIsICgpID0+IHtcclxuICAgICAgY29uc3QgeyBMaW5lIH0gPSByZXF1aXJlKFwicmVhY3QtY2hhcnRqcy0yXCIpO1xyXG4gICAgICBcclxuICAgICAgcmVuZGVyKFxyXG4gICAgICAgIDxUcmVuZENoYXJ0XHJcbiAgICAgICAgICBpbmNvbWVEYXRhPXttb2NrSW5jb21lRGF0YX1cclxuICAgICAgICAgIGV4cGVuc2VEYXRhPXttb2NrRXhwZW5zZURhdGF9XHJcbiAgICAgICAgLz5cclxuICAgICAgKTtcclxuXHJcbiAgICAgIGNvbnN0IGNhbGxBcmdzID0gTGluZS5tb2NrLmNhbGxzWzBdO1xyXG4gICAgICBjb25zdCBsYWJlbENhbGxiYWNrID0gY2FsbEFyZ3NbMF0ub3B0aW9ucy5wbHVnaW5zLnRvb2x0aXAuY2FsbGJhY2tzLmxhYmVsO1xyXG5cclxuICAgICAgLy8gVGVzdCB3aXRoIG1pc3NpbmcgbGFiZWxcclxuICAgICAgY29uc3QgbW9ja0NvbnRleHRXaXRob3V0TGFiZWwgPSB7XHJcbiAgICAgICAgZGF0YXNldDoge30sXHJcbiAgICAgICAgcGFyc2VkOiB7IHk6IDUwMDAgfSxcclxuICAgICAgfTtcclxuXHJcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGxhYmVsQ2FsbGJhY2sobW9ja0NvbnRleHRXaXRob3V0TGFiZWwpO1xyXG4gICAgICBleHBlY3QocmVzdWx0KS50b0JlKFwiXCIpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaXQoXCJzaG91bGQgcmVuZGVyIGxvYWRpbmcgc3RhdGUgd2l0aG91dCB0b29sdGlwIGludGVyYWN0aW9uXCIsICgpID0+IHtcclxuICAgICAgY29uc3QgeyBjb250YWluZXIgfSA9IHJlbmRlcihcclxuICAgICAgICA8VHJlbmRDaGFydFxyXG4gICAgICAgICAgaW5jb21lRGF0YT17bW9ja0luY29tZURhdGF9XHJcbiAgICAgICAgICBleHBlbnNlRGF0YT17bW9ja0V4cGVuc2VEYXRhfVxyXG4gICAgICAgICAgbG9hZGluZz17dHJ1ZX1cclxuICAgICAgICAvPlxyXG4gICAgICApO1xyXG5cclxuICAgICAgLy8gU2hvdWxkIHNob3cgbG9hZGluZyBza2VsZXRvbiwgbm90IGNoYXJ0XHJcbiAgICAgIGV4cGVjdChzY3JlZW4ucXVlcnlCeVRlc3RJZChcImNoYXJ0LWNhbnZhc1wiKSkubm90LnRvQmVJblRoZURvY3VtZW50KCk7XHJcbiAgICAgIGNvbnN0IHNrZWxldG9uID0gY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoXCIuYW5pbWF0ZS1wdWxzZVwiKTtcclxuICAgICAgZXhwZWN0KHNrZWxldG9uKS50b0JlSW5UaGVEb2N1bWVudCgpO1xyXG4gICAgfSk7XHJcbiAgfSk7XHJcbn0pO1xyXG4iXSwibmFtZXMiOlsiamVzdCIsIm1vY2siLCJMaW5lIiwiZm4iLCJkYXRhIiwib3B0aW9ucyIsImNoYXJ0SWQiLCJkaXYiLCJkYXRhLXRlc3RpZCIsImRhdGEtY2hhcnQtaWQiLCJjYW52YXMiLCJkZXNjcmliZSIsIm1vY2tJbmNvbWVEYXRhIiwiZGF0ZSIsImFtb3VudCIsIm1vY2tFeHBlbnNlRGF0YSIsImJlZm9yZUVhY2giLCJjbGVhckFsbE1vY2tzIiwiaXQiLCJyZXF1aXJlIiwicmVuZGVyIiwiVHJlbmRDaGFydCIsImluY29tZURhdGEiLCJleHBlbnNlRGF0YSIsImV4cGVjdCIsInRvSGF2ZUJlZW5DYWxsZWQiLCJjYWxsQXJncyIsImNhbGxzIiwicGx1Z2lucyIsInRvb2x0aXAiLCJ0b0JlRGVmaW5lZCIsIm1vZGUiLCJ0b0JlIiwiaW50ZXJzZWN0IiwidG9vbHRpcENvbmZpZyIsImJhY2tncm91bmRDb2xvciIsInRpdGxlQ29sb3IiLCJib2R5Q29sb3IiLCJib3JkZXJDb2xvciIsImJvcmRlcldpZHRoIiwicGFkZGluZyIsImNvcm5lclJhZGl1cyIsImNhbGxiYWNrcyIsImxhYmVsIiwibW9ja0NvbnRleHQiLCJkYXRhc2V0IiwicGFyc2VkIiwieSIsImZvcm1hdHRlZExhYmVsIiwidG9Db250YWluIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJ3aW5kb3ciLCJ3cml0YWJsZSIsImNvbmZpZ3VyYWJsZSIsInZhbHVlIiwic2NyZWVuIiwiZ2V0QnlUZXN0SWQiLCJ0b0JlSW5UaGVEb2N1bWVudCIsInRhZ05hbWUiLCJjaGFydERhdGEiLCJsYWJlbHMiLCJ0b0hhdmVMZW5ndGgiLCJkYXRhc2V0cyIsImdldEJ5VGV4dCIsInF1ZXJ5QnlUZXN0SWQiLCJub3QiLCJ0b0JlR3JlYXRlclRoYW5PckVxdWFsIiwidG9CZUdyZWF0ZXJUaGFuIiwibGFiZWxDYWxsYmFjayIsIm1vY2tDb250ZXh0V2l0aE51bGwiLCJyZXN1bHQiLCJtb2NrQ29udGV4dFdpdGhvdXRMYWJlbCIsImNvbnRhaW5lciIsImxvYWRpbmciLCJza2VsZXRvbiIsInF1ZXJ5U2VsZWN0b3IiXSwibWFwcGluZ3MiOiJBQUFBOzs7O0NBSUM7QUFNRCxnREFBZ0Q7QUFDaERBLEtBQUtDLElBQUksQ0FBQyxtQkFBbUIsSUFBTyxDQUFBO1FBQ2xDQyxNQUFNRixLQUFLRyxF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