f3088757bda18167677c2d589a64c588
/**
 * Property-Based Test — Modal Content Scrolling
 * 
 * **Свойство 11: Прокрутка содержимого модальных окон**
 * **Валидирует: Требования 4.2**
 * 
 * For any modal window with content exceeding viewport height,
 * vertical scrolling should be available (overflow-y: auto).
 * The modal content container should have max-h-[85vh] to ensure
 * scrollability when content is too tall.
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _jsxruntime = require("react/jsx-runtime");
const _react = /*#__PURE__*/ _interop_require_default(require("react"));
const _react1 = require("@testing-library/react");
const _fastcheck = /*#__PURE__*/ _interop_require_default(require("fast-check"));
const _Modal = require("../../src/components/ui/Modal");
const _propertytestconfig = require("./property-test-config");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
// Maximum height of modal content (85% of viewport height)
const MAX_MODAL_HEIGHT_VH = 85;
// Helper function to get computed styles
const getComputedOverflow = (element)=>{
    const computedStyle = window.getComputedStyle(element);
    return computedStyle.overflowY;
};
// Helper function to check if element has max-height constraint
const hasMaxHeightConstraint = (element)=>{
    const classes = element.className;
    return classes.includes("max-h-[85vh]");
};
// Helper function to find modal content container
const findModalContentContainer = (container)=>{
    // Look for the div with overflow-y-auto and max-h-[85vh]
    const contentContainer = container.querySelector(".overflow-y-auto.max-h-\\[85vh\\]");
    if (contentContainer) return contentContainer;
    // Fallback: look for any element with max-h-[85vh]
    return container.querySelector("[class*='max-h-[85vh]']");
};
// Generator for content that exceeds viewport height
const tallContentArbitrary = _fastcheck.default.array(_fastcheck.default.string({
    minLength: 50,
    maxLength: 200
}), {
    minLength: 20,
    maxLength: 100
});
// Generator for content that fits within viewport
const shortContentArbitrary = _fastcheck.default.array(_fastcheck.default.string({
    minLength: 10,
    maxLength: 50
}), {
    minLength: 1,
    maxLength: 5
});
describe("Property: Modal Content Scrolling", ()=>{
    describe("Overflow-y auto property", ()=>{
        it("should have overflow-y: auto on modal content container", ()=>{
            jest.setTimeout((0, _propertytestconfig.getTimeout)("SLOW"));
            _fastcheck.default.assert(_fastcheck.default.property(_fastcheck.default.constantFrom("sm", "md", "lg", "xl"), _fastcheck.default.array(_fastcheck.default.string({
                minLength: 10,
                maxLength: 100
            }), {
                minLength: 1,
                maxLength: 50
            }), (size, contentLines)=>{
                const { container } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_Modal.Modal, {
                    isOpen: true,
                    onClose: ()=>{},
                    size: size,
                    children: /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                        children: contentLines.map((line, index)=>/*#__PURE__*/ (0, _jsxruntime.jsx)("p", {
                                children: line
                            }, index))
                    })
                }));
                const contentContainer = findModalContentContainer(container);
                if (contentContainer) {
                    // Should have overflow-y-auto class
                    expect(contentContainer.className).toMatch(/overflow-y-auto/);
                    // Computed style should be 'auto' or 'scroll'
                    const overflowY = getComputedOverflow(contentContainer);
                    expect([
                        "auto",
                        "scroll"
                    ]).toContain(overflowY);
                }
            }), {
                numRuns: (0, _propertytestconfig.getNumRuns)("MEDIUM")
            });
        });
        it("should have overflow-y: auto regardless of content length", ()=>{
            jest.setTimeout((0, _propertytestconfig.getTimeout)("SLOW"));
            _fastcheck.default.assert(_fastcheck.default.property(_fastcheck.default.oneof(shortContentArbitrary, tallContentArbitrary), _fastcheck.default.constantFrom("sm", "md", "lg", "xl"), (contentLines, size)=>{
                const { container } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_Modal.Modal, {
                    isOpen: true,
                    onClose: ()=>{},
                    size: size,
                    children: /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                        children: contentLines.map((line, index)=>/*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                                style: {
                                    minHeight: "50px"
                                },
                                children: line
                            }, index))
                    })
                }));
                const contentContainer = findModalContentContainer(container);
                if (contentContainer) {
                    expect(contentContainer.className).toMatch(/overflow-y-auto/);
                }
            }), {
                numRuns: (0, _propertytestconfig.getNumRuns)("MEDIUM")
            });
        });
    });
    describe("Max-height constraint", ()=>{
        it("should have max-h-[85vh] class on content container", ()=>{
            jest.setTimeout((0, _propertytestconfig.getTimeout)("SLOW"));
            _fastcheck.default.assert(_fastcheck.default.property(_fastcheck.default.constantFrom("sm", "md", "lg", "xl"), _fastcheck.default.array(_fastcheck.default.string({
                minLength: 10,
                maxLength: 100
            }), {
                minLength: 1,
                maxLength: 50
            }), (size, contentLines)=>{
                const { container } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_Modal.Modal, {
                    isOpen: true,
                    onClose: ()=>{},
                    size: size,
                    children: /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                        children: contentLines.map((line, index)=>/*#__PURE__*/ (0, _jsxruntime.jsx)("p", {
                                children: line
                            }, index))
                    })
                }));
                const contentContainer = findModalContentContainer(container);
                if (contentContainer) {
                    // Should have max-h-[85vh] class
                    expect(hasMaxHeightConstraint(contentContainer)).toBe(true);
                    expect(contentContainer.className).toMatch(/max-h-\[85vh\]/);
                }
            }), {
                numRuns: (0, _propertytestconfig.getNumRuns)("MEDIUM")
            });
        });
        it("should maintain max-h-[85vh] across all modal sizes", ()=>{
            jest.setTimeout((0, _propertytestconfig.getTimeout)("SLOW"));
            const sizes = [
                "sm",
                "md",
                "lg",
                "xl"
            ];
            _fastcheck.default.assert(_fastcheck.default.property(_fastcheck.default.array(_fastcheck.default.string({
                minLength: 20,
                maxLength: 100
            }), {
                minLength: 10,
                maxLength: 30
            }), (contentLines)=>{
                sizes.forEach((size)=>{
                    const { container } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_Modal.Modal, {
                        isOpen: true,
                        onClose: ()=>{},
                        size: size,
                        children: /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                            children: contentLines.map((line, index)=>/*#__PURE__*/ (0, _jsxruntime.jsx)("p", {
                                    children: line
                                }, index))
                        })
                    }));
                    const contentContainer = findModalContentContainer(container);
                    if (contentContainer) {
                        expect(contentContainer.className).toMatch(/max-h-\[85vh\]/);
                    }
                });
            }), {
                numRuns: (0, _propertytestconfig.getNumRuns)("FAST")
            });
        });
        it("should have max-h-[85vh] regardless of viewport width", ()=>{
            jest.setTimeout((0, _propertytestconfig.getTimeout)("SLOW"));
            _fastcheck.default.assert(_fastcheck.default.property(_fastcheck.default.integer({
                min: 320,
                max: 1440
            }), _fastcheck.default.constantFrom("sm", "md", "lg", "xl"), (viewportWidth, size)=>{
                // Mock window.innerWidth
                Object.defineProperty(window, "innerWidth", {
                    writable: true,
                    configurable: true,
                    value: viewportWidth
                });
                const { container } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_Modal.Modal, {
                    isOpen: true,
                    onClose: ()=>{},
                    size: size,
                    children: /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                        children: /*#__PURE__*/ (0, _jsxruntime.jsx)("p", {
                            children: "Test content"
                        })
                    })
                }));
                const contentContainer = findModalContentContainer(container);
                if (contentContainer) {
                    expect(contentContainer.className).toMatch(/max-h-\[85vh\]/);
                }
            }), {
                numRuns: (0, _propertytestconfig.getNumRuns)("MEDIUM")
            });
        });
    });
    describe("Scrollability with tall content", ()=>{
        it("should enable scrolling when content exceeds max-height", ()=>{
            jest.setTimeout((0, _propertytestconfig.getTimeout)("SLOW"));
            _fastcheck.default.assert(_fastcheck.default.property(tallContentArbitrary, _fastcheck.default.constantFrom("sm", "md", "lg", "xl"), (contentLines, size)=>{
                const { container } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_Modal.Modal, {
                    isOpen: true,
                    onClose: ()=>{},
                    size: size,
                    children: /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                        children: contentLines.map((line, index)=>/*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                                style: {
                                    minHeight: "100px",
                                    padding: "20px"
                                },
                                children: line
                            }, index))
                    })
                }));
                const contentContainer = findModalContentContainer(container);
                if (contentContainer) {
                    // Should have both overflow-y-auto and max-h-[85vh]
                    expect(contentContainer.className).toMatch(/overflow-y-auto/);
                    expect(contentContainer.className).toMatch(/max-h-\[85vh\]/);
                    // Overflow should be auto or scroll
                    const overflowY = getComputedOverflow(contentContainer);
                    expect([
                        "auto",
                        "scroll"
                    ]).toContain(overflowY);
                }
            }), {
                numRuns: (0, _propertytestconfig.getNumRuns)("FAST")
            });
        });
        it("should handle forms with many fields", ()=>{
            jest.setTimeout((0, _propertytestconfig.getTimeout)("SLOW"));
            _fastcheck.default.assert(_fastcheck.default.property(_fastcheck.default.array(_fastcheck.default.record({
                label: _fastcheck.default.string({
                    minLength: 5,
                    maxLength: 30
                }),
                type: _fastcheck.default.constantFrom("text", "email", "number", "textarea")
            }), {
                minLength: 10,
                maxLength: 20
            }), _fastcheck.default.constantFrom("sm", "md", "lg", "xl"), (fields, size)=>{
                const { container } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_Modal.Modal, {
                    isOpen: true,
                    onClose: ()=>{},
                    size: size,
                    title: "Form",
                    children: /*#__PURE__*/ (0, _jsxruntime.jsx)("form", {
                        children: fields.map((field, index)=>/*#__PURE__*/ (0, _jsxruntime.jsxs)("div", {
                                style: {
                                    marginBottom: "20px"
                                },
                                children: [
                                    /*#__PURE__*/ (0, _jsxruntime.jsx)("label", {
                                        children: field.label
                                    }),
                                    field.type === "textarea" ? /*#__PURE__*/ (0, _jsxruntime.jsx)("textarea", {
                                        style: {
                                            width: "100%",
                                            height: "80px"
                                        }
                                    }) : /*#__PURE__*/ (0, _jsxruntime.jsx)("input", {
                                        type: field.type,
                                        style: {
                                            width: "100%"
                                        }
                                    })
                                ]
                            }, index))
                    })
                }));
                const contentContainer = findModalContentContainer(container);
                if (contentContainer) {
                    // Form should be scrollable
                    expect(contentContainer.className).toMatch(/overflow-y-auto/);
                    expect(contentContainer.className).toMatch(/max-h-\[85vh\]/);
                }
            }), {
                numRuns: (0, _propertytestconfig.getNumRuns)("FAST")
            });
        });
        it("should handle nested content structures", ()=>{
            jest.setTimeout((0, _propertytestconfig.getTimeout)("SLOW"));
            _fastcheck.default.assert(_fastcheck.default.property(_fastcheck.default.array(_fastcheck.default.record({
                title: _fastcheck.default.string({
                    minLength: 10,
                    maxLength: 50
                }),
                items: _fastcheck.default.array(_fastcheck.default.string({
                    minLength: 20,
                    maxLength: 100
                }), {
                    minLength: 3,
                    maxLength: 10
                })
            }), {
                minLength: 5,
                maxLength: 15
            }), (sections)=>{
                const { container } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_Modal.Modal, {
                    isOpen: true,
                    onClose: ()=>{},
                    size: "lg",
                    children: /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                        children: sections.map((section, sectionIndex)=>/*#__PURE__*/ (0, _jsxruntime.jsxs)("div", {
                                style: {
                                    marginBottom: "30px"
                                },
                                children: [
                                    /*#__PURE__*/ (0, _jsxruntime.jsx)("h3", {
                                        children: section.title
                                    }),
                                    /*#__PURE__*/ (0, _jsxruntime.jsx)("ul", {
                                        children: section.items.map((item, itemIndex)=>/*#__PURE__*/ (0, _jsxruntime.jsx)("li", {
                                                style: {
                                                    padding: "10px"
                                                },
                                                children: item
                                            }, itemIndex))
                                    })
                                ]
                            }, sectionIndex))
                    })
                }));
                const contentContainer = findModalContentContainer(container);
                if (contentContainer) {
                    expect(contentContainer.className).toMatch(/overflow-y-auto/);
                    expect(contentContainer.className).toMatch(/max-h-\[85vh\]/);
                }
            }), {
                numRuns: (0, _propertytestconfig.getNumRuns)("FAST")
            });
        });
    });
    describe("Edge cases", ()=>{
        it("should handle modal with minimal content", ()=>{
            jest.setTimeout((0, _propertytestconfig.getTimeout)("SLOW"));
            _fastcheck.default.assert(_fastcheck.default.property(_fastcheck.default.constantFrom("sm", "md", "lg", "xl"), _fastcheck.default.string({
                minLength: 1,
                maxLength: 20
            }), (size, content)=>{
                const { container } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_Modal.Modal, {
                    isOpen: true,
                    onClose: ()=>{},
                    size: size,
                    children: /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                        children: content
                    })
                }));
                const contentContainer = findModalContentContainer(container);
                if (contentContainer) {
                    // Even with minimal content, scrolling properties should be present
                    expect(contentContainer.className).toMatch(/overflow-y-auto/);
                    expect(contentContainer.className).toMatch(/max-h-\[85vh\]/);
                }
            }), {
                numRuns: (0, _propertytestconfig.getNumRuns)("FAST")
            });
        });
        it("should handle modal with empty content", ()=>{
            jest.setTimeout((0, _propertytestconfig.getTimeout)("SLOW"));
            const sizes = [
                "sm",
                "md",
                "lg",
                "xl"
            ];
            sizes.forEach((size)=>{
                const { container } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_Modal.Modal, {
                    isOpen: true,
                    onClose: ()=>{},
                    size: size,
                    children: /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {})
                }));
                const contentContainer = findModalContentContainer(container);
                if (contentContainer) {
                    expect(contentContainer.className).toMatch(/overflow-y-auto/);
                    expect(contentContainer.className).toMatch(/max-h-\[85vh\]/);
                }
            });
        });
        it("should handle modal with title and content", ()=>{
            jest.setTimeout((0, _propertytestconfig.getTimeout)("SLOW"));
            _fastcheck.default.assert(_fastcheck.default.property(_fastcheck.default.string({
                minLength: 5,
                maxLength: 50
            }), _fastcheck.default.array(_fastcheck.default.string({
                minLength: 20,
                maxLength: 100
            }), {
                minLength: 5,
                maxLength: 20
            }), _fastcheck.default.constantFrom("sm", "md", "lg", "xl"), (title, contentLines, size)=>{
                const { container } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_Modal.Modal, {
                    isOpen: true,
                    onClose: ()=>{},
                    title: title,
                    size: size,
                    children: /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                        children: contentLines.map((line, index)=>/*#__PURE__*/ (0, _jsxruntime.jsx)("p", {
                                children: line
                            }, index))
                    })
                }));
                const contentContainer = findModalContentContainer(container);
                if (contentContainer) {
                    expect(contentContainer.className).toMatch(/overflow-y-auto/);
                    expect(contentContainer.className).toMatch(/max-h-\[85vh\]/);
                }
            }), {
                numRuns: (0, _propertytestconfig.getNumRuns)("FAST")
            });
        });
        it("should handle modal with images and mixed content", ()=>{
            jest.setTimeout((0, _propertytestconfig.getTimeout)("SLOW"));
            _fastcheck.default.assert(_fastcheck.default.property(_fastcheck.default.array(_fastcheck.default.record({
                type: _fastcheck.default.constantFrom("text", "image", "list"),
                content: _fastcheck.default.string({
                    minLength: 10,
                    maxLength: 100
                })
            }), {
                minLength: 5,
                maxLength: 15
            }), (contentBlocks)=>{
                const { container } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_Modal.Modal, {
                    isOpen: true,
                    onClose: ()=>{},
                    size: "lg",
                    children: /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                        children: contentBlocks.map((block, index)=>{
                            if (block.type === "text") {
                                return /*#__PURE__*/ (0, _jsxruntime.jsx)("p", {
                                    children: block.content
                                }, index);
                            } else if (block.type === "image") {
                                return /*#__PURE__*/ (0, _jsxruntime.jsxs)("div", {
                                    style: {
                                        height: "200px",
                                        background: "#ccc"
                                    },
                                    children: [
                                        "Image placeholder: ",
                                        block.content
                                    ]
                                }, index);
                            } else {
                                return /*#__PURE__*/ (0, _jsxruntime.jsx)("ul", {
                                    children: /*#__PURE__*/ (0, _jsxruntime.jsx)("li", {
                                        children: block.content
                                    })
                                }, index);
                            }
                        })
                    })
                }));
                const contentContainer = findModalContentContainer(container);
                if (contentContainer) {
                    expect(contentContainer.className).toMatch(/overflow-y-auto/);
                    expect(contentContainer.className).toMatch(/max-h-\[85vh\]/);
                }
            }), {
                numRuns: (0, _propertytestconfig.getNumRuns)("FAST")
            });
        });
        it("should handle modal on different viewport heights", ()=>{
            jest.setTimeout((0, _propertytestconfig.getTimeout)("SLOW"));
            _fastcheck.default.assert(_fastcheck.default.property(_fastcheck.default.integer({
                min: 480,
                max: 1080
            }), _fastcheck.default.array(_fastcheck.default.string({
                minLength: 50,
                maxLength: 150
            }), {
                minLength: 10,
                maxLength: 30
            }), (viewportHeight, contentLines)=>{
                // Mock window.innerHeight
                Object.defineProperty(window, "innerHeight", {
                    writable: true,
                    configurable: true,
                    value: viewportHeight
                });
                const { container } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_Modal.Modal, {
                    isOpen: true,
                    onClose: ()=>{},
                    size: "md",
                    children: /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                        children: contentLines.map((line, index)=>/*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                                style: {
                                    minHeight: "60px"
                                },
                                children: line
                            }, index))
                    })
                }));
                const contentContainer = findModalContentContainer(container);
                if (contentContainer) {
                    // Max height should always be 85vh regardless of viewport height
                    expect(contentContainer.className).toMatch(/max-h-\[85vh\]/);
                    expect(contentContainer.className).toMatch(/overflow-y-auto/);
                }
            }), {
                numRuns: (0, _propertytestconfig.getNumRuns)("FAST")
            });
        });
    });
    describe("Requirement validation", ()=>{
        it("validates Requirement 4.2: Modal content scrolling on mobile devices", ()=>{
            jest.setTimeout((0, _propertytestconfig.getTimeout)("SLOW"));
            _fastcheck.default.assert(_fastcheck.default.property(_fastcheck.default.integer({
                min: 320,
                max: 639
            }), _fastcheck.default.array(_fastcheck.default.string({
                minLength: 50,
                maxLength: 150
            }), {
                minLength: 15,
                maxLength: 40
            }), _fastcheck.default.constantFrom("sm", "md", "lg", "xl"), (viewportWidth, contentLines, size)=>{
                // Mock mobile viewport
                Object.defineProperty(window, "innerWidth", {
                    writable: true,
                    configurable: true,
                    value: viewportWidth
                });
                Object.defineProperty(window, "innerHeight", {
                    writable: true,
                    configurable: true,
                    value: 667
                });
                // Requirement 4.2: WHEN Модальное_Окно открыто на мобильном устройстве,
                // THE Система SHALL обеспечивать возможность прокрутки содержимого
                const { container } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_Modal.Modal, {
                    isOpen: true,
                    onClose: ()=>{},
                    size: size,
                    children: /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                        children: contentLines.map((line, index)=>/*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                                style: {
                                    minHeight: "80px",
                                    padding: "10px"
                                },
                                children: line
                            }, index))
                    })
                }));
                const contentContainer = findModalContentContainer(container);
                if (contentContainer) {
                    // Modal content should have overflow-y: auto for scrolling
                    expect(contentContainer.className).toMatch(/overflow-y-auto/);
                    // Should have max-height constraint to enable scrolling
                    expect(contentContainer.className).toMatch(/max-h-\[85vh\]/);
                    // Computed overflow should allow scrolling
                    const overflowY = getComputedOverflow(contentContainer);
                    expect([
                        "auto",
                        "scroll"
                    ]).toContain(overflowY);
                }
            }), {
                numRuns: (0, _propertytestconfig.getNumRuns)("MEDIUM")
            });
        });
        it("validates that scrolling is available on all device sizes", ()=>{
            jest.setTimeout((0, _propertytestconfig.getTimeout)("SLOW"));
            _fastcheck.default.assert(_fastcheck.default.property(_fastcheck.default.integer({
                min: 320,
                max: 1440
            }), _fastcheck.default.array(_fastcheck.default.string({
                minLength: 30,
                maxLength: 100
            }), {
                minLength: 20,
                maxLength: 50
            }), (viewportWidth, contentLines)=>{
                Object.defineProperty(window, "innerWidth", {
                    writable: true,
                    configurable: true,
                    value: viewportWidth
                });
                const { container } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_Modal.Modal, {
                    isOpen: true,
                    onClose: ()=>{},
                    size: "md",
                    children: /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                        children: contentLines.map((line, index)=>/*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                                style: {
                                    minHeight: "70px"
                                },
                                children: line
                            }, index))
                    })
                }));
                const contentContainer = findModalContentContainer(container);
                if (contentContainer) {
                    // Scrolling should be available on all device sizes
                    expect(contentContainer.className).toMatch(/overflow-y-auto/);
                    expect(contentContainer.className).toMatch(/max-h-\[85vh\]/);
                }
            }), {
                numRuns: (0, _propertytestconfig.getNumRuns)("MEDIUM")
            });
        });
        it("validates that max-height is 85% of viewport height", ()=>{
            jest.setTimeout((0, _propertytestconfig.getTimeout)("SLOW"));
            _fastcheck.default.assert(_fastcheck.default.property(_fastcheck.default.constantFrom("sm", "md", "lg", "xl"), (size)=>{
                const { container } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_Modal.Modal, {
                    isOpen: true,
                    onClose: ()=>{},
                    size: size,
                    children: /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                        children: "Test content"
                    })
                }));
                const contentContainer = findModalContentContainer(container);
                if (contentContainer) {
                    // Should use max-h-[85vh] which is 85% of viewport height
                    expect(contentContainer.className).toMatch(/max-h-\[85vh\]/);
                }
            }), {
                numRuns: (0, _propertytestconfig.getNumRuns)("FAST")
            });
        });
    });
    describe("General property validation", ()=>{
        it("should verify scrolling properties are present across all configurations", ()=>{
            jest.setTimeout((0, _propertytestconfig.getTimeout)("SLOW"));
            _fastcheck.default.assert(_fastcheck.default.property(_fastcheck.default.integer({
                min: 320,
                max: 1440
            }), _fastcheck.default.constantFrom("sm", "md", "lg", "xl"), _fastcheck.default.oneof(shortContentArbitrary, tallContentArbitrary), _fastcheck.default.option(_fastcheck.default.string({
                minLength: 5,
                maxLength: 50
            }), {
                nil: undefined
            }), (viewportWidth, size, contentLines, title)=>{
                Object.defineProperty(window, "innerWidth", {
                    writable: true,
                    configurable: true,
                    value: viewportWidth
                });
                const { container } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_Modal.Modal, {
                    isOpen: true,
                    onClose: ()=>{},
                    size: size,
                    title: title,
                    children: /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                        children: contentLines.map((line, index)=>/*#__PURE__*/ (0, _jsxruntime.jsx)("p", {
                                children: line
                            }, index))
                    })
                }));
                const contentContainer = findModalContentContainer(container);
                if (contentContainer) {
                    // All modals should have scrolling capability
                    expect(contentContainer.className).toMatch(/overflow-y-auto/);
                    expect(contentContainer.className).toMatch(/max-h-\[85vh\]/);
                }
            }), {
                numRuns: (0, _propertytestconfig.getNumRuns)("MEDIUM")
            });
        });
        it("should ensure consistent scrolling behavior across modal lifecycle", ()=>{
            jest.setTimeout((0, _propertytestconfig.getTimeout)("SLOW"));
            _fastcheck.default.assert(_fastcheck.default.property(_fastcheck.default.array(_fastcheck.default.string({
                minLength: 20,
                maxLength: 100
            }), {
                minLength: 10,
                maxLength: 30
            }), (contentLines)=>{
                // Render modal
                const { container, rerender } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_Modal.Modal, {
                    isOpen: true,
                    onClose: ()=>{},
                    size: "md",
                    children: /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                        children: contentLines.map((line, index)=>/*#__PURE__*/ (0, _jsxruntime.jsx)("p", {
                                children: line
                            }, index))
                    })
                }));
                let contentContainer = findModalContentContainer(container);
                if (contentContainer) {
                    expect(contentContainer.className).toMatch(/overflow-y-auto/);
                    expect(contentContainer.className).toMatch(/max-h-\[85vh\]/);
                }
                // Re-render with different content
                rerender(/*#__PURE__*/ (0, _jsxruntime.jsx)(_Modal.Modal, {
                    isOpen: true,
                    onClose: ()=>{},
                    size: "lg",
                    children: /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                        children: contentLines.slice(0, 5).map((line, index)=>/*#__PURE__*/ (0, _jsxruntime.jsx)("p", {
                                children: line
                            }, index))
                    })
                }));
                contentContainer = findModalContentContainer(container);
                if (contentContainer) {
                    // Scrolling properties should persist after re-render
                    expect(contentContainer.className).toMatch(/overflow-y-auto/);
                    expect(contentContainer.className).toMatch(/max-h-\[85vh\]/);
                }
            }), {
                numRuns: (0, _propertytestconfig.getNumRuns)("FAST")
            });
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkU6XFxteVxcb3R1c1xcZmluYW5jZV90cmFja2VyXFxmcm9udGVuZFxcX190ZXN0c19fXFxwcm9wZXJ0aWVzXFxtb2RhbENvbnRlbnRTY3JvbGxpbmcucHJvcGVydHkudGVzdC50c3giXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIFByb3BlcnR5LUJhc2VkIFRlc3Qg4oCUIE1vZGFsIENvbnRlbnQgU2Nyb2xsaW5nXHJcbiAqIFxyXG4gKiAqKtCh0LLQvtC50YHRgtCy0L4gMTE6INCf0YDQvtC60YDRg9GC0LrQsCDRgdC+0LTQtdGA0LbQuNC80L7Qs9C+INC80L7QtNCw0LvRjNC90YvRhSDQvtC60L7QvSoqXHJcbiAqICoq0JLQsNC70LjQtNC40YDRg9C10YI6INCi0YDQtdCx0L7QstCw0L3QuNGPIDQuMioqXHJcbiAqIFxyXG4gKiBGb3IgYW55IG1vZGFsIHdpbmRvdyB3aXRoIGNvbnRlbnQgZXhjZWVkaW5nIHZpZXdwb3J0IGhlaWdodCxcclxuICogdmVydGljYWwgc2Nyb2xsaW5nIHNob3VsZCBiZSBhdmFpbGFibGUgKG92ZXJmbG93LXk6IGF1dG8pLlxyXG4gKiBUaGUgbW9kYWwgY29udGVudCBjb250YWluZXIgc2hvdWxkIGhhdmUgbWF4LWgtWzg1dmhdIHRvIGVuc3VyZVxyXG4gKiBzY3JvbGxhYmlsaXR5IHdoZW4gY29udGVudCBpcyB0b28gdGFsbC5cclxuICovXHJcblxyXG5pbXBvcnQgUmVhY3QgZnJvbSBcInJlYWN0XCI7XHJcbmltcG9ydCB7IHJlbmRlciB9IGZyb20gXCJAdGVzdGluZy1saWJyYXJ5L3JlYWN0XCI7XHJcbmltcG9ydCBmYyBmcm9tIFwiZmFzdC1jaGVja1wiO1xyXG5pbXBvcnQgeyBNb2RhbCB9IGZyb20gXCJAL2NvbXBvbmVudHMvdWkvTW9kYWxcIjtcclxuaW1wb3J0IHsgZ2V0TnVtUnVucywgZ2V0VGltZW91dCB9IGZyb20gXCIuL3Byb3BlcnR5LXRlc3QtY29uZmlnXCI7XHJcblxyXG4vLyBNYXhpbXVtIGhlaWdodCBvZiBtb2RhbCBjb250ZW50ICg4NSUgb2Ygdmlld3BvcnQgaGVpZ2h0KVxyXG5jb25zdCBNQVhfTU9EQUxfSEVJR0hUX1ZIID0gODU7XHJcblxyXG4vLyBIZWxwZXIgZnVuY3Rpb24gdG8gZ2V0IGNvbXB1dGVkIHN0eWxlc1xyXG5jb25zdCBnZXRDb21wdXRlZE92ZXJmbG93ID0gKGVsZW1lbnQ6IEVsZW1lbnQpOiBzdHJpbmcgPT4ge1xyXG4gIGNvbnN0IGNvbXB1dGVkU3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcclxuICByZXR1cm4gY29tcHV0ZWRTdHlsZS5vdmVyZmxvd1k7XHJcbn07XHJcblxyXG4vLyBIZWxwZXIgZnVuY3Rpb24gdG8gY2hlY2sgaWYgZWxlbWVudCBoYXMgbWF4LWhlaWdodCBjb25zdHJhaW50XHJcbmNvbnN0IGhhc01heEhlaWdodENvbnN0cmFpbnQgPSAoZWxlbWVudDogRWxlbWVudCk6IGJvb2xlYW4gPT4ge1xyXG4gIGNvbnN0IGNsYXNzZXMgPSBlbGVtZW50LmNsYXNzTmFtZTtcclxuICByZXR1cm4gY2xhc3Nlcy5pbmNsdWRlcyhcIm1heC1oLVs4NXZoXVwiKTtcclxufTtcclxuXHJcbi8vIEhlbHBlciBmdW5jdGlvbiB0byBmaW5kIG1vZGFsIGNvbnRlbnQgY29udGFpbmVyXHJcbmNvbnN0IGZpbmRNb2RhbENvbnRlbnRDb250YWluZXIgPSAoY29udGFpbmVyOiBIVE1MRWxlbWVudCk6IEVsZW1lbnQgfCBudWxsID0+IHtcclxuICAvLyBMb29rIGZvciB0aGUgZGl2IHdpdGggb3ZlcmZsb3cteS1hdXRvIGFuZCBtYXgtaC1bODV2aF1cclxuICBjb25zdCBjb250ZW50Q29udGFpbmVyID0gY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoXCIub3ZlcmZsb3cteS1hdXRvLm1heC1oLVxcXFxbODV2aFxcXFxdXCIpO1xyXG4gIGlmIChjb250ZW50Q29udGFpbmVyKSByZXR1cm4gY29udGVudENvbnRhaW5lcjtcclxuICBcclxuICAvLyBGYWxsYmFjazogbG9vayBmb3IgYW55IGVsZW1lbnQgd2l0aCBtYXgtaC1bODV2aF1cclxuICByZXR1cm4gY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoXCJbY2xhc3MqPSdtYXgtaC1bODV2aF0nXVwiKTtcclxufTtcclxuXHJcbi8vIEdlbmVyYXRvciBmb3IgY29udGVudCB0aGF0IGV4Y2VlZHMgdmlld3BvcnQgaGVpZ2h0XHJcbmNvbnN0IHRhbGxDb250ZW50QXJiaXRyYXJ5ID0gZmMuYXJyYXkoXHJcbiAgZmMuc3RyaW5nKHsgbWluTGVuZ3RoOiA1MCwgbWF4TGVuZ3RoOiAyMDAgfSksXHJcbiAgeyBtaW5MZW5ndGg6IDIwLCBtYXhMZW5ndGg6IDEwMCB9XHJcbik7XHJcblxyXG4vLyBHZW5lcmF0b3IgZm9yIGNvbnRlbnQgdGhhdCBmaXRzIHdpdGhpbiB2aWV3cG9ydFxyXG5jb25zdCBzaG9ydENvbnRlbnRBcmJpdHJhcnkgPSBmYy5hcnJheShcclxuICBmYy5zdHJpbmcoeyBtaW5MZW5ndGg6IDEwLCBtYXhMZW5ndGg6IDUwIH0pLFxyXG4gIHsgbWluTGVuZ3RoOiAxLCBtYXhMZW5ndGg6IDUgfVxyXG4pO1xyXG5cclxuZGVzY3JpYmUoXCJQcm9wZXJ0eTogTW9kYWwgQ29udGVudCBTY3JvbGxpbmdcIiwgKCkgPT4ge1xyXG4gIGRlc2NyaWJlKFwiT3ZlcmZsb3cteSBhdXRvIHByb3BlcnR5XCIsICgpID0+IHtcclxuICAgIGl0KFwic2hvdWxkIGhhdmUgb3ZlcmZsb3cteTogYXV0byBvbiBtb2RhbCBjb250ZW50IGNvbnRhaW5lclwiLCAoKSA9PiB7XHJcbiAgICAgIGplc3Quc2V0VGltZW91dChnZXRUaW1lb3V0KFwiU0xPV1wiKSk7XHJcbiAgICAgIGZjLmFzc2VydChcclxuICAgICAgICBmYy5wcm9wZXJ0eShcclxuICAgICAgICAgIGZjLmNvbnN0YW50RnJvbShcInNtXCIgYXMgY29uc3QsIFwibWRcIiBhcyBjb25zdCwgXCJsZ1wiIGFzIGNvbnN0LCBcInhsXCIgYXMgY29uc3QpLFxyXG4gICAgICAgICAgZmMuYXJyYXkoZmMuc3RyaW5nKHsgbWluTGVuZ3RoOiAxMCwgbWF4TGVuZ3RoOiAxMDAgfSksIHsgbWluTGVuZ3RoOiAxLCBtYXhMZW5ndGg6IDUwIH0pLFxyXG4gICAgICAgICAgKHNpemUsIGNvbnRlbnRMaW5lcykgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCB7IGNvbnRhaW5lciB9ID0gcmVuZGVyKFxyXG4gICAgICAgICAgICAgIDxNb2RhbCBpc09wZW49e3RydWV9IG9uQ2xvc2U9eygpID0+IHt9fSBzaXplPXtzaXplfT5cclxuICAgICAgICAgICAgICAgIDxkaXY+XHJcbiAgICAgICAgICAgICAgICAgIHtjb250ZW50TGluZXMubWFwKChsaW5lLCBpbmRleCkgPT4gKFxyXG4gICAgICAgICAgICAgICAgICAgIDxwIGtleT17aW5kZXh9PntsaW5lfTwvcD5cclxuICAgICAgICAgICAgICAgICAgKSl9XHJcbiAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICA8L01vZGFsPlxyXG4gICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgY29udGVudENvbnRhaW5lciA9IGZpbmRNb2RhbENvbnRlbnRDb250YWluZXIoY29udGFpbmVyKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChjb250ZW50Q29udGFpbmVyKSB7XHJcbiAgICAgICAgICAgICAgLy8gU2hvdWxkIGhhdmUgb3ZlcmZsb3cteS1hdXRvIGNsYXNzXHJcbiAgICAgICAgICAgICAgZXhwZWN0KGNvbnRlbnRDb250YWluZXIuY2xhc3NOYW1lKS50b01hdGNoKC9vdmVyZmxvdy15LWF1dG8vKTtcclxuICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAvLyBDb21wdXRlZCBzdHlsZSBzaG91bGQgYmUgJ2F1dG8nIG9yICdzY3JvbGwnXHJcbiAgICAgICAgICAgICAgY29uc3Qgb3ZlcmZsb3dZID0gZ2V0Q29tcHV0ZWRPdmVyZmxvdyhjb250ZW50Q29udGFpbmVyKTtcclxuICAgICAgICAgICAgICBleHBlY3QoW1wiYXV0b1wiLCBcInNjcm9sbFwiXSkudG9Db250YWluKG92ZXJmbG93WSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICApLFxyXG4gICAgICAgIHsgbnVtUnVuczogZ2V0TnVtUnVucyhcIk1FRElVTVwiKSB9XHJcbiAgICAgICk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBpdChcInNob3VsZCBoYXZlIG92ZXJmbG93LXk6IGF1dG8gcmVnYXJkbGVzcyBvZiBjb250ZW50IGxlbmd0aFwiLCAoKSA9PiB7XHJcbiAgICAgIGplc3Quc2V0VGltZW91dChnZXRUaW1lb3V0KFwiU0xPV1wiKSk7XHJcbiAgICAgIGZjLmFzc2VydChcclxuICAgICAgICBmYy5wcm9wZXJ0eShcclxuICAgICAgICAgIGZjLm9uZW9mKHNob3J0Q29udGVudEFyYml0cmFyeSwgdGFsbENvbnRlbnRBcmJpdHJhcnkpLFxyXG4gICAgICAgICAgZmMuY29uc3RhbnRGcm9tKFwic21cIiBhcyBjb25zdCwgXCJtZFwiIGFzIGNvbnN0LCBcImxnXCIgYXMgY29uc3QsIFwieGxcIiBhcyBjb25zdCksXHJcbiAgICAgICAgICAoY29udGVudExpbmVzLCBzaXplKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgY29udGFpbmVyIH0gPSByZW5kZXIoXHJcbiAgICAgICAgICAgICAgPE1vZGFsIGlzT3Blbj17dHJ1ZX0gb25DbG9zZT17KCkgPT4ge319IHNpemU9e3NpemV9PlxyXG4gICAgICAgICAgICAgICAgPGRpdj5cclxuICAgICAgICAgICAgICAgICAge2NvbnRlbnRMaW5lcy5tYXAoKGxpbmUsIGluZGV4KSA9PiAoXHJcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBrZXk9e2luZGV4fSBzdHlsZT17eyBtaW5IZWlnaHQ6IFwiNTBweFwiIH19PlxyXG4gICAgICAgICAgICAgICAgICAgICAge2xpbmV9XHJcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICkpfVxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgPC9Nb2RhbD5cclxuICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IGNvbnRlbnRDb250YWluZXIgPSBmaW5kTW9kYWxDb250ZW50Q29udGFpbmVyKGNvbnRhaW5lcik7XHJcblxyXG4gICAgICAgICAgICBpZiAoY29udGVudENvbnRhaW5lcikge1xyXG4gICAgICAgICAgICAgIGV4cGVjdChjb250ZW50Q29udGFpbmVyLmNsYXNzTmFtZSkudG9NYXRjaCgvb3ZlcmZsb3cteS1hdXRvLyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICApLFxyXG4gICAgICAgIHsgbnVtUnVuczogZ2V0TnVtUnVucyhcIk1FRElVTVwiKSB9XHJcbiAgICAgICk7XHJcbiAgICB9KTtcclxuICB9KTtcclxuXHJcbiAgZGVzY3JpYmUoXCJNYXgtaGVpZ2h0IGNvbnN0cmFpbnRcIiwgKCkgPT4ge1xyXG4gICAgaXQoXCJzaG91bGQgaGF2ZSBtYXgtaC1bODV2aF0gY2xhc3Mgb24gY29udGVudCBjb250YWluZXJcIiwgKCkgPT4ge1xyXG4gICAgICBqZXN0LnNldFRpbWVvdXQoZ2V0VGltZW91dChcIlNMT1dcIikpO1xyXG4gICAgICBmYy5hc3NlcnQoXHJcbiAgICAgICAgZmMucHJvcGVydHkoXHJcbiAgICAgICAgICBmYy5jb25zdGFudEZyb20oXCJzbVwiIGFzIGNvbnN0LCBcIm1kXCIgYXMgY29uc3QsIFwibGdcIiBhcyBjb25zdCwgXCJ4bFwiIGFzIGNvbnN0KSxcclxuICAgICAgICAgIGZjLmFycmF5KGZjLnN0cmluZyh7IG1pbkxlbmd0aDogMTAsIG1heExlbmd0aDogMTAwIH0pLCB7IG1pbkxlbmd0aDogMSwgbWF4TGVuZ3RoOiA1MCB9KSxcclxuICAgICAgICAgIChzaXplLCBjb250ZW50TGluZXMpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgeyBjb250YWluZXIgfSA9IHJlbmRlcihcclxuICAgICAgICAgICAgICA8TW9kYWwgaXNPcGVuPXt0cnVlfSBvbkNsb3NlPXsoKSA9PiB7fX0gc2l6ZT17c2l6ZX0+XHJcbiAgICAgICAgICAgICAgICA8ZGl2PlxyXG4gICAgICAgICAgICAgICAgICB7Y29udGVudExpbmVzLm1hcCgobGluZSwgaW5kZXgpID0+IChcclxuICAgICAgICAgICAgICAgICAgICA8cCBrZXk9e2luZGV4fT57bGluZX08L3A+XHJcbiAgICAgICAgICAgICAgICAgICkpfVxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgPC9Nb2RhbD5cclxuICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IGNvbnRlbnRDb250YWluZXIgPSBmaW5kTW9kYWxDb250ZW50Q29udGFpbmVyKGNvbnRhaW5lcik7XHJcblxyXG4gICAgICAgICAgICBpZiAoY29udGVudENvbnRhaW5lcikge1xyXG4gICAgICAgICAgICAgIC8vIFNob3VsZCBoYXZlIG1heC1oLVs4NXZoXSBjbGFzc1xyXG4gICAgICAgICAgICAgIGV4cGVjdChoYXNNYXhIZWlnaHRDb25zdHJhaW50KGNvbnRlbnRDb250YWluZXIpKS50b0JlKHRydWUpO1xyXG4gICAgICAgICAgICAgIGV4cGVjdChjb250ZW50Q29udGFpbmVyLmNsYXNzTmFtZSkudG9NYXRjaCgvbWF4LWgtXFxbODV2aFxcXS8pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgKSxcclxuICAgICAgICB7IG51bVJ1bnM6IGdldE51bVJ1bnMoXCJNRURJVU1cIikgfVxyXG4gICAgICApO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaXQoXCJzaG91bGQgbWFpbnRhaW4gbWF4LWgtWzg1dmhdIGFjcm9zcyBhbGwgbW9kYWwgc2l6ZXNcIiwgKCkgPT4ge1xyXG4gICAgICBqZXN0LnNldFRpbWVvdXQoZ2V0VGltZW91dChcIlNMT1dcIikpO1xyXG4gICAgICBjb25zdCBzaXplczogQXJyYXk8XCJzbVwiIHwgXCJtZFwiIHwgXCJsZ1wiIHwgXCJ4bFwiPiA9IFtcInNtXCIsIFwibWRcIiwgXCJsZ1wiLCBcInhsXCJdO1xyXG5cclxuICAgICAgZmMuYXNzZXJ0KFxyXG4gICAgICAgIGZjLnByb3BlcnR5KFxyXG4gICAgICAgICAgZmMuYXJyYXkoZmMuc3RyaW5nKHsgbWluTGVuZ3RoOiAyMCwgbWF4TGVuZ3RoOiAxMDAgfSksIHsgbWluTGVuZ3RoOiAxMCwgbWF4TGVuZ3RoOiAzMCB9KSxcclxuICAgICAgICAgIChjb250ZW50TGluZXMpID0+IHtcclxuICAgICAgICAgICAgc2l6ZXMuZm9yRWFjaCgoc2l6ZSkgPT4ge1xyXG4gICAgICAgICAgICAgIGNvbnN0IHsgY29udGFpbmVyIH0gPSByZW5kZXIoXHJcbiAgICAgICAgICAgICAgICA8TW9kYWwgaXNPcGVuPXt0cnVlfSBvbkNsb3NlPXsoKSA9PiB7fX0gc2l6ZT17c2l6ZX0+XHJcbiAgICAgICAgICAgICAgICAgIDxkaXY+XHJcbiAgICAgICAgICAgICAgICAgICAge2NvbnRlbnRMaW5lcy5tYXAoKGxpbmUsIGluZGV4KSA9PiAoXHJcbiAgICAgICAgICAgICAgICAgICAgICA8cCBrZXk9e2luZGV4fT57bGluZX08L3A+XHJcbiAgICAgICAgICAgICAgICAgICAgKSl9XHJcbiAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgPC9Nb2RhbD5cclxuICAgICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgICBjb25zdCBjb250ZW50Q29udGFpbmVyID0gZmluZE1vZGFsQ29udGVudENvbnRhaW5lcihjb250YWluZXIpO1xyXG5cclxuICAgICAgICAgICAgICBpZiAoY29udGVudENvbnRhaW5lcikge1xyXG4gICAgICAgICAgICAgICAgZXhwZWN0KGNvbnRlbnRDb250YWluZXIuY2xhc3NOYW1lKS50b01hdGNoKC9tYXgtaC1cXFs4NXZoXFxdLyk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICApLFxyXG4gICAgICAgIHsgbnVtUnVuczogZ2V0TnVtUnVucyhcIkZBU1RcIikgfVxyXG4gICAgICApO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaXQoXCJzaG91bGQgaGF2ZSBtYXgtaC1bODV2aF0gcmVnYXJkbGVzcyBvZiB2aWV3cG9ydCB3aWR0aFwiLCAoKSA9PiB7XHJcbiAgICAgIGplc3Quc2V0VGltZW91dChnZXRUaW1lb3V0KFwiU0xPV1wiKSk7XHJcbiAgICAgIGZjLmFzc2VydChcclxuICAgICAgICBmYy5wcm9wZXJ0eShcclxuICAgICAgICAgIGZjLmludGVnZXIoeyBtaW46IDMyMCwgbWF4OiAxNDQwIH0pLFxyXG4gICAgICAgICAgZmMuY29uc3RhbnRGcm9tKFwic21cIiBhcyBjb25zdCwgXCJtZFwiIGFzIGNvbnN0LCBcImxnXCIgYXMgY29uc3QsIFwieGxcIiBhcyBjb25zdCksXHJcbiAgICAgICAgICAodmlld3BvcnRXaWR0aCwgc2l6ZSkgPT4ge1xyXG4gICAgICAgICAgICAvLyBNb2NrIHdpbmRvdy5pbm5lcldpZHRoXHJcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3aW5kb3csIFwiaW5uZXJXaWR0aFwiLCB7XHJcbiAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICAgIHZhbHVlOiB2aWV3cG9ydFdpZHRoLFxyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IHsgY29udGFpbmVyIH0gPSByZW5kZXIoXHJcbiAgICAgICAgICAgICAgPE1vZGFsIGlzT3Blbj17dHJ1ZX0gb25DbG9zZT17KCkgPT4ge319IHNpemU9e3NpemV9PlxyXG4gICAgICAgICAgICAgICAgPGRpdj5cclxuICAgICAgICAgICAgICAgICAgPHA+VGVzdCBjb250ZW50PC9wPlxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgPC9Nb2RhbD5cclxuICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IGNvbnRlbnRDb250YWluZXIgPSBmaW5kTW9kYWxDb250ZW50Q29udGFpbmVyKGNvbnRhaW5lcik7XHJcblxyXG4gICAgICAgICAgICBpZiAoY29udGVudENvbnRhaW5lcikge1xyXG4gICAgICAgICAgICAgIGV4cGVjdChjb250ZW50Q29udGFpbmVyLmNsYXNzTmFtZSkudG9NYXRjaCgvbWF4LWgtXFxbODV2aFxcXS8pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgKSxcclxuICAgICAgICB7IG51bVJ1bnM6IGdldE51bVJ1bnMoXCJNRURJVU1cIikgfVxyXG4gICAgICApO1xyXG4gICAgfSk7XHJcbiAgfSk7XHJcblxyXG4gIGRlc2NyaWJlKFwiU2Nyb2xsYWJpbGl0eSB3aXRoIHRhbGwgY29udGVudFwiLCAoKSA9PiB7XHJcbiAgICBpdChcInNob3VsZCBlbmFibGUgc2Nyb2xsaW5nIHdoZW4gY29udGVudCBleGNlZWRzIG1heC1oZWlnaHRcIiwgKCkgPT4ge1xyXG4gICAgICBqZXN0LnNldFRpbWVvdXQoZ2V0VGltZW91dChcIlNMT1dcIikpO1xyXG4gICAgICBmYy5hc3NlcnQoXHJcbiAgICAgICAgZmMucHJvcGVydHkoXHJcbiAgICAgICAgICB0YWxsQ29udGVudEFyYml0cmFyeSxcclxuICAgICAgICAgIGZjLmNvbnN0YW50RnJvbShcInNtXCIgYXMgY29uc3QsIFwibWRcIiBhcyBjb25zdCwgXCJsZ1wiIGFzIGNvbnN0LCBcInhsXCIgYXMgY29uc3QpLFxyXG4gICAgICAgICAgKGNvbnRlbnRMaW5lcywgc2l6ZSkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCB7IGNvbnRhaW5lciB9ID0gcmVuZGVyKFxyXG4gICAgICAgICAgICAgIDxNb2RhbCBpc09wZW49e3RydWV9IG9uQ2xvc2U9eygpID0+IHt9fSBzaXplPXtzaXplfT5cclxuICAgICAgICAgICAgICAgIDxkaXY+XHJcbiAgICAgICAgICAgICAgICAgIHtjb250ZW50TGluZXMubWFwKChsaW5lLCBpbmRleCkgPT4gKFxyXG4gICAgICAgICAgICAgICAgICAgIDxkaXYga2V5PXtpbmRleH0gc3R5bGU9e3sgbWluSGVpZ2h0OiBcIjEwMHB4XCIsIHBhZGRpbmc6IFwiMjBweFwiIH19PlxyXG4gICAgICAgICAgICAgICAgICAgICAge2xpbmV9XHJcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICkpfVxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgPC9Nb2RhbD5cclxuICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IGNvbnRlbnRDb250YWluZXIgPSBmaW5kTW9kYWxDb250ZW50Q29udGFpbmVyKGNvbnRhaW5lcik7XHJcblxyXG4gICAgICAgICAgICBpZiAoY29udGVudENvbnRhaW5lcikge1xyXG4gICAgICAgICAgICAgIC8vIFNob3VsZCBoYXZlIGJvdGggb3ZlcmZsb3cteS1hdXRvIGFuZCBtYXgtaC1bODV2aF1cclxuICAgICAgICAgICAgICBleHBlY3QoY29udGVudENvbnRhaW5lci5jbGFzc05hbWUpLnRvTWF0Y2goL292ZXJmbG93LXktYXV0by8pO1xyXG4gICAgICAgICAgICAgIGV4cGVjdChjb250ZW50Q29udGFpbmVyLmNsYXNzTmFtZSkudG9NYXRjaCgvbWF4LWgtXFxbODV2aFxcXS8pO1xyXG4gICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgIC8vIE92ZXJmbG93IHNob3VsZCBiZSBhdXRvIG9yIHNjcm9sbFxyXG4gICAgICAgICAgICAgIGNvbnN0IG92ZXJmbG93WSA9IGdldENvbXB1dGVkT3ZlcmZsb3coY29udGVudENvbnRhaW5lcik7XHJcbiAgICAgICAgICAgICAgZXhwZWN0KFtcImF1dG9cIiwgXCJzY3JvbGxcIl0pLnRvQ29udGFpbihvdmVyZmxvd1kpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgKSxcclxuICAgICAgICB7IG51bVJ1bnM6IGdldE51bVJ1bnMoXCJGQVNUXCIpIH1cclxuICAgICAgKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGl0KFwic2hvdWxkIGhhbmRsZSBmb3JtcyB3aXRoIG1hbnkgZmllbGRzXCIsICgpID0+IHtcclxuICAgICAgamVzdC5zZXRUaW1lb3V0KGdldFRpbWVvdXQoXCJTTE9XXCIpKTtcclxuICAgICAgZmMuYXNzZXJ0KFxyXG4gICAgICAgIGZjLnByb3BlcnR5KFxyXG4gICAgICAgICAgZmMuYXJyYXkoXHJcbiAgICAgICAgICAgIGZjLnJlY29yZCh7XHJcbiAgICAgICAgICAgICAgbGFiZWw6IGZjLnN0cmluZyh7IG1pbkxlbmd0aDogNSwgbWF4TGVuZ3RoOiAzMCB9KSxcclxuICAgICAgICAgICAgICB0eXBlOiBmYy5jb25zdGFudEZyb20oXCJ0ZXh0XCIsIFwiZW1haWxcIiwgXCJudW1iZXJcIiwgXCJ0ZXh0YXJlYVwiKSxcclxuICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgIHsgbWluTGVuZ3RoOiAxMCwgbWF4TGVuZ3RoOiAyMCB9XHJcbiAgICAgICAgICApLFxyXG4gICAgICAgICAgZmMuY29uc3RhbnRGcm9tKFwic21cIiBhcyBjb25zdCwgXCJtZFwiIGFzIGNvbnN0LCBcImxnXCIgYXMgY29uc3QsIFwieGxcIiBhcyBjb25zdCksXHJcbiAgICAgICAgICAoZmllbGRzLCBzaXplKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgY29udGFpbmVyIH0gPSByZW5kZXIoXHJcbiAgICAgICAgICAgICAgPE1vZGFsIGlzT3Blbj17dHJ1ZX0gb25DbG9zZT17KCkgPT4ge319IHNpemU9e3NpemV9IHRpdGxlPVwiRm9ybVwiPlxyXG4gICAgICAgICAgICAgICAgPGZvcm0+XHJcbiAgICAgICAgICAgICAgICAgIHtmaWVsZHMubWFwKChmaWVsZCwgaW5kZXgpID0+IChcclxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGtleT17aW5kZXh9IHN0eWxlPXt7IG1hcmdpbkJvdHRvbTogXCIyMHB4XCIgfX0+XHJcbiAgICAgICAgICAgICAgICAgICAgICA8bGFiZWw+e2ZpZWxkLmxhYmVsfTwvbGFiZWw+XHJcbiAgICAgICAgICAgICAgICAgICAgICB7ZmllbGQudHlwZSA9PT0gXCJ0ZXh0YXJlYVwiID8gKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8dGV4dGFyZWEgc3R5bGU9e3sgd2lkdGg6IFwiMTAwJVwiLCBoZWlnaHQ6IFwiODBweFwiIH19IC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICApIDogKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8aW5wdXQgdHlwZT17ZmllbGQudHlwZX0gc3R5bGU9e3sgd2lkdGg6IFwiMTAwJVwiIH19IC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICApfVxyXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICApKX1cclxuICAgICAgICAgICAgICAgIDwvZm9ybT5cclxuICAgICAgICAgICAgICA8L01vZGFsPlxyXG4gICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgY29udGVudENvbnRhaW5lciA9IGZpbmRNb2RhbENvbnRlbnRDb250YWluZXIoY29udGFpbmVyKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChjb250ZW50Q29udGFpbmVyKSB7XHJcbiAgICAgICAgICAgICAgLy8gRm9ybSBzaG91bGQgYmUgc2Nyb2xsYWJsZVxyXG4gICAgICAgICAgICAgIGV4cGVjdChjb250ZW50Q29udGFpbmVyLmNsYXNzTmFtZSkudG9NYXRjaCgvb3ZlcmZsb3cteS1hdXRvLyk7XHJcbiAgICAgICAgICAgICAgZXhwZWN0KGNvbnRlbnRDb250YWluZXIuY2xhc3NOYW1lKS50b01hdGNoKC9tYXgtaC1cXFs4NXZoXFxdLyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICApLFxyXG4gICAgICAgIHsgbnVtUnVuczogZ2V0TnVtUnVucyhcIkZBU1RcIikgfVxyXG4gICAgICApO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaXQoXCJzaG91bGQgaGFuZGxlIG5lc3RlZCBjb250ZW50IHN0cnVjdHVyZXNcIiwgKCkgPT4ge1xyXG4gICAgICBqZXN0LnNldFRpbWVvdXQoZ2V0VGltZW91dChcIlNMT1dcIikpO1xyXG4gICAgICBmYy5hc3NlcnQoXHJcbiAgICAgICAgZmMucHJvcGVydHkoXHJcbiAgICAgICAgICBmYy5hcnJheShcclxuICAgICAgICAgICAgZmMucmVjb3JkKHtcclxuICAgICAgICAgICAgICB0aXRsZTogZmMuc3RyaW5nKHsgbWluTGVuZ3RoOiAxMCwgbWF4TGVuZ3RoOiA1MCB9KSxcclxuICAgICAgICAgICAgICBpdGVtczogZmMuYXJyYXkoZmMuc3RyaW5nKHsgbWluTGVuZ3RoOiAyMCwgbWF4TGVuZ3RoOiAxMDAgfSksIHsgbWluTGVuZ3RoOiAzLCBtYXhMZW5ndGg6IDEwIH0pLFxyXG4gICAgICAgICAgICB9KSxcclxuICAgICAgICAgICAgeyBtaW5MZW5ndGg6IDUsIG1heExlbmd0aDogMTUgfVxyXG4gICAgICAgICAgKSxcclxuICAgICAgICAgIChzZWN0aW9ucykgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCB7IGNvbnRhaW5lciB9ID0gcmVuZGVyKFxyXG4gICAgICAgICAgICAgIDxNb2RhbCBpc09wZW49e3RydWV9IG9uQ2xvc2U9eygpID0+IHt9fSBzaXplPVwibGdcIj5cclxuICAgICAgICAgICAgICAgIDxkaXY+XHJcbiAgICAgICAgICAgICAgICAgIHtzZWN0aW9ucy5tYXAoKHNlY3Rpb24sIHNlY3Rpb25JbmRleCkgPT4gKFxyXG4gICAgICAgICAgICAgICAgICAgIDxkaXYga2V5PXtzZWN0aW9uSW5kZXh9IHN0eWxlPXt7IG1hcmdpbkJvdHRvbTogXCIzMHB4XCIgfX0+XHJcbiAgICAgICAgICAgICAgICAgICAgICA8aDM+e3NlY3Rpb24udGl0bGV9PC9oMz5cclxuICAgICAgICAgICAgICAgICAgICAgIDx1bD5cclxuICAgICAgICAgICAgICAgICAgICAgICAge3NlY3Rpb24uaXRlbXMubWFwKChpdGVtLCBpdGVtSW5kZXgpID0+IChcclxuICAgICAgICAgICAgICAgICAgICAgICAgICA8bGkga2V5PXtpdGVtSW5kZXh9IHN0eWxlPXt7IHBhZGRpbmc6IFwiMTBweFwiIH19PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge2l0ZW19XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgPC9saT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgKSl9XHJcbiAgICAgICAgICAgICAgICAgICAgICA8L3VsPlxyXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICApKX1cclxuICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgIDwvTW9kYWw+XHJcbiAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICBjb25zdCBjb250ZW50Q29udGFpbmVyID0gZmluZE1vZGFsQ29udGVudENvbnRhaW5lcihjb250YWluZXIpO1xyXG5cclxuICAgICAgICAgICAgaWYgKGNvbnRlbnRDb250YWluZXIpIHtcclxuICAgICAgICAgICAgICBleHBlY3QoY29udGVudENvbnRhaW5lci5jbGFzc05hbWUpLnRvTWF0Y2goL292ZXJmbG93LXktYXV0by8pO1xyXG4gICAgICAgICAgICAgIGV4cGVjdChjb250ZW50Q29udGFpbmVyLmNsYXNzTmFtZSkudG9NYXRjaCgvbWF4LWgtXFxbODV2aFxcXS8pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgKSxcclxuICAgICAgICB7IG51bVJ1bnM6IGdldE51bVJ1bnMoXCJGQVNUXCIpIH1cclxuICAgICAgKTtcclxuICAgIH0pO1xyXG4gIH0pO1xyXG5cclxuICBkZXNjcmliZShcIkVkZ2UgY2FzZXNcIiwgKCkgPT4ge1xyXG4gICAgaXQoXCJzaG91bGQgaGFuZGxlIG1vZGFsIHdpdGggbWluaW1hbCBjb250ZW50XCIsICgpID0+IHtcclxuICAgICAgamVzdC5zZXRUaW1lb3V0KGdldFRpbWVvdXQoXCJTTE9XXCIpKTtcclxuICAgICAgZmMuYXNzZXJ0KFxyXG4gICAgICAgIGZjLnByb3BlcnR5KFxyXG4gICAgICAgICAgZmMuY29uc3RhbnRGcm9tKFwic21cIiBhcyBjb25zdCwgXCJtZFwiIGFzIGNvbnN0LCBcImxnXCIgYXMgY29uc3QsIFwieGxcIiBhcyBjb25zdCksXHJcbiAgICAgICAgICBmYy5zdHJpbmcoeyBtaW5MZW5ndGg6IDEsIG1heExlbmd0aDogMjAgfSksXHJcbiAgICAgICAgICAoc2l6ZSwgY29udGVudCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCB7IGNvbnRhaW5lciB9ID0gcmVuZGVyKFxyXG4gICAgICAgICAgICAgIDxNb2RhbCBpc09wZW49e3RydWV9IG9uQ2xvc2U9eygpID0+IHt9fSBzaXplPXtzaXplfT5cclxuICAgICAgICAgICAgICAgIDxkaXY+e2NvbnRlbnR9PC9kaXY+XHJcbiAgICAgICAgICAgICAgPC9Nb2RhbD5cclxuICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IGNvbnRlbnRDb250YWluZXIgPSBmaW5kTW9kYWxDb250ZW50Q29udGFpbmVyKGNvbnRhaW5lcik7XHJcblxyXG4gICAgICAgICAgICBpZiAoY29udGVudENvbnRhaW5lcikge1xyXG4gICAgICAgICAgICAgIC8vIEV2ZW4gd2l0aCBtaW5pbWFsIGNvbnRlbnQsIHNjcm9sbGluZyBwcm9wZXJ0aWVzIHNob3VsZCBiZSBwcmVzZW50XHJcbiAgICAgICAgICAgICAgZXhwZWN0KGNvbnRlbnRDb250YWluZXIuY2xhc3NOYW1lKS50b01hdGNoKC9vdmVyZmxvdy15LWF1dG8vKTtcclxuICAgICAgICAgICAgICBleHBlY3QoY29udGVudENvbnRhaW5lci5jbGFzc05hbWUpLnRvTWF0Y2goL21heC1oLVxcWzg1dmhcXF0vKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICksXHJcbiAgICAgICAgeyBudW1SdW5zOiBnZXROdW1SdW5zKFwiRkFTVFwiKSB9XHJcbiAgICAgICk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBpdChcInNob3VsZCBoYW5kbGUgbW9kYWwgd2l0aCBlbXB0eSBjb250ZW50XCIsICgpID0+IHtcclxuICAgICAgamVzdC5zZXRUaW1lb3V0KGdldFRpbWVvdXQoXCJTTE9XXCIpKTtcclxuICAgICAgY29uc3Qgc2l6ZXM6IEFycmF5PFwic21cIiB8IFwibWRcIiB8IFwibGdcIiB8IFwieGxcIj4gPSBbXCJzbVwiLCBcIm1kXCIsIFwibGdcIiwgXCJ4bFwiXTtcclxuXHJcbiAgICAgIHNpemVzLmZvckVhY2goKHNpemUpID0+IHtcclxuICAgICAgICBjb25zdCB7IGNvbnRhaW5lciB9ID0gcmVuZGVyKFxyXG4gICAgICAgICAgPE1vZGFsIGlzT3Blbj17dHJ1ZX0gb25DbG9zZT17KCkgPT4ge319IHNpemU9e3NpemV9PlxyXG4gICAgICAgICAgICA8ZGl2PjwvZGl2PlxyXG4gICAgICAgICAgPC9Nb2RhbD5cclxuICAgICAgICApO1xyXG5cclxuICAgICAgICBjb25zdCBjb250ZW50Q29udGFpbmVyID0gZmluZE1vZGFsQ29udGVudENvbnRhaW5lcihjb250YWluZXIpO1xyXG5cclxuICAgICAgICBpZiAoY29udGVudENvbnRhaW5lcikge1xyXG4gICAgICAgICAgZXhwZWN0KGNvbnRlbnRDb250YWluZXIuY2xhc3NOYW1lKS50b01hdGNoKC9vdmVyZmxvdy15LWF1dG8vKTtcclxuICAgICAgICAgIGV4cGVjdChjb250ZW50Q29udGFpbmVyLmNsYXNzTmFtZSkudG9NYXRjaCgvbWF4LWgtXFxbODV2aFxcXS8pO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBpdChcInNob3VsZCBoYW5kbGUgbW9kYWwgd2l0aCB0aXRsZSBhbmQgY29udGVudFwiLCAoKSA9PiB7XHJcbiAgICAgIGplc3Quc2V0VGltZW91dChnZXRUaW1lb3V0KFwiU0xPV1wiKSk7XHJcbiAgICAgIGZjLmFzc2VydChcclxuICAgICAgICBmYy5wcm9wZXJ0eShcclxuICAgICAgICAgIGZjLnN0cmluZyh7IG1pbkxlbmd0aDogNSwgbWF4TGVuZ3RoOiA1MCB9KSxcclxuICAgICAgICAgIGZjLmFycmF5KGZjLnN0cmluZyh7IG1pbkxlbmd0aDogMjAsIG1heExlbmd0aDogMTAwIH0pLCB7IG1pbkxlbmd0aDogNSwgbWF4TGVuZ3RoOiAyMCB9KSxcclxuICAgICAgICAgIGZjLmNvbnN0YW50RnJvbShcInNtXCIgYXMgY29uc3QsIFwibWRcIiBhcyBjb25zdCwgXCJsZ1wiIGFzIGNvbnN0LCBcInhsXCIgYXMgY29uc3QpLFxyXG4gICAgICAgICAgKHRpdGxlLCBjb250ZW50TGluZXMsIHNpemUpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgeyBjb250YWluZXIgfSA9IHJlbmRlcihcclxuICAgICAgICAgICAgICA8TW9kYWwgaXNPcGVuPXt0cnVlfSBvbkNsb3NlPXsoKSA9PiB7fX0gdGl0bGU9e3RpdGxlfSBzaXplPXtzaXplfT5cclxuICAgICAgICAgICAgICAgIDxkaXY+XHJcbiAgICAgICAgICAgICAgICAgIHtjb250ZW50TGluZXMubWFwKChsaW5lLCBpbmRleCkgPT4gKFxyXG4gICAgICAgICAgICAgICAgICAgIDxwIGtleT17aW5kZXh9PntsaW5lfTwvcD5cclxuICAgICAgICAgICAgICAgICAgKSl9XHJcbiAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICA8L01vZGFsPlxyXG4gICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgY29udGVudENvbnRhaW5lciA9IGZpbmRNb2RhbENvbnRlbnRDb250YWluZXIoY29udGFpbmVyKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChjb250ZW50Q29udGFpbmVyKSB7XHJcbiAgICAgICAgICAgICAgZXhwZWN0KGNvbnRlbnRDb250YWluZXIuY2xhc3NOYW1lKS50b01hdGNoKC9vdmVyZmxvdy15LWF1dG8vKTtcclxuICAgICAgICAgICAgICBleHBlY3QoY29udGVudENvbnRhaW5lci5jbGFzc05hbWUpLnRvTWF0Y2goL21heC1oLVxcWzg1dmhcXF0vKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICksXHJcbiAgICAgICAgeyBudW1SdW5zOiBnZXROdW1SdW5zKFwiRkFTVFwiKSB9XHJcbiAgICAgICk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBpdChcInNob3VsZCBoYW5kbGUgbW9kYWwgd2l0aCBpbWFnZXMgYW5kIG1peGVkIGNvbnRlbnRcIiwgKCkgPT4ge1xyXG4gICAgICBqZXN0LnNldFRpbWVvdXQoZ2V0VGltZW91dChcIlNMT1dcIikpO1xyXG4gICAgICBmYy5hc3NlcnQoXHJcbiAgICAgICAgZmMucHJvcGVydHkoXHJcbiAgICAgICAgICBmYy5hcnJheShcclxuICAgICAgICAgICAgZmMucmVjb3JkKHtcclxuICAgICAgICAgICAgICB0eXBlOiBmYy5jb25zdGFudEZyb20oXCJ0ZXh0XCIsIFwiaW1hZ2VcIiwgXCJsaXN0XCIpLFxyXG4gICAgICAgICAgICAgIGNvbnRlbnQ6IGZjLnN0cmluZyh7IG1pbkxlbmd0aDogMTAsIG1heExlbmd0aDogMTAwIH0pLFxyXG4gICAgICAgICAgICB9KSxcclxuICAgICAgICAgICAgeyBtaW5MZW5ndGg6IDUsIG1heExlbmd0aDogMTUgfVxyXG4gICAgICAgICAgKSxcclxuICAgICAgICAgIChjb250ZW50QmxvY2tzKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgY29udGFpbmVyIH0gPSByZW5kZXIoXHJcbiAgICAgICAgICAgICAgPE1vZGFsIGlzT3Blbj17dHJ1ZX0gb25DbG9zZT17KCkgPT4ge319IHNpemU9XCJsZ1wiPlxyXG4gICAgICAgICAgICAgICAgPGRpdj5cclxuICAgICAgICAgICAgICAgICAge2NvbnRlbnRCbG9ja3MubWFwKChibG9jaywgaW5kZXgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYmxvY2sudHlwZSA9PT0gXCJ0ZXh0XCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiA8cCBrZXk9e2luZGV4fT57YmxvY2suY29udGVudH08L3A+O1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYmxvY2sudHlwZSA9PT0gXCJpbWFnZVwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGtleT17aW5kZXh9IHN0eWxlPXt7IGhlaWdodDogXCIyMDBweFwiLCBiYWNrZ3JvdW5kOiBcIiNjY2NcIiB9fT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICBJbWFnZSBwbGFjZWhvbGRlcjoge2Jsb2NrLmNvbnRlbnR9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgICAgICAgICAgICAgPHVsIGtleT17aW5kZXh9PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIDxsaT57YmxvY2suY29udGVudH08L2xpPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8L3VsPlxyXG4gICAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgIH0pfVxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgPC9Nb2RhbD5cclxuICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IGNvbnRlbnRDb250YWluZXIgPSBmaW5kTW9kYWxDb250ZW50Q29udGFpbmVyKGNvbnRhaW5lcik7XHJcblxyXG4gICAgICAgICAgICBpZiAoY29udGVudENvbnRhaW5lcikge1xyXG4gICAgICAgICAgICAgIGV4cGVjdChjb250ZW50Q29udGFpbmVyLmNsYXNzTmFtZSkudG9NYXRjaCgvb3ZlcmZsb3cteS1hdXRvLyk7XHJcbiAgICAgICAgICAgICAgZXhwZWN0KGNvbnRlbnRDb250YWluZXIuY2xhc3NOYW1lKS50b01hdGNoKC9tYXgtaC1cXFs4NXZoXFxdLyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICApLFxyXG4gICAgICAgIHsgbnVtUnVuczogZ2V0TnVtUnVucyhcIkZBU1RcIikgfVxyXG4gICAgICApO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaXQoXCJzaG91bGQgaGFuZGxlIG1vZGFsIG9uIGRpZmZlcmVudCB2aWV3cG9ydCBoZWlnaHRzXCIsICgpID0+IHtcclxuICAgICAgamVzdC5zZXRUaW1lb3V0KGdldFRpbWVvdXQoXCJTTE9XXCIpKTtcclxuICAgICAgZmMuYXNzZXJ0KFxyXG4gICAgICAgIGZjLnByb3BlcnR5KFxyXG4gICAgICAgICAgZmMuaW50ZWdlcih7IG1pbjogNDgwLCBtYXg6IDEwODAgfSksIC8vIHZpZXdwb3J0IGhlaWdodFxyXG4gICAgICAgICAgZmMuYXJyYXkoZmMuc3RyaW5nKHsgbWluTGVuZ3RoOiA1MCwgbWF4TGVuZ3RoOiAxNTAgfSksIHsgbWluTGVuZ3RoOiAxMCwgbWF4TGVuZ3RoOiAzMCB9KSxcclxuICAgICAgICAgICh2aWV3cG9ydEhlaWdodCwgY29udGVudExpbmVzKSA9PiB7XHJcbiAgICAgICAgICAgIC8vIE1vY2sgd2luZG93LmlubmVySGVpZ2h0XHJcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3aW5kb3csIFwiaW5uZXJIZWlnaHRcIiwge1xyXG4gICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgICB2YWx1ZTogdmlld3BvcnRIZWlnaHQsXHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgeyBjb250YWluZXIgfSA9IHJlbmRlcihcclxuICAgICAgICAgICAgICA8TW9kYWwgaXNPcGVuPXt0cnVlfSBvbkNsb3NlPXsoKSA9PiB7fX0gc2l6ZT1cIm1kXCI+XHJcbiAgICAgICAgICAgICAgICA8ZGl2PlxyXG4gICAgICAgICAgICAgICAgICB7Y29udGVudExpbmVzLm1hcCgobGluZSwgaW5kZXgpID0+IChcclxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGtleT17aW5kZXh9IHN0eWxlPXt7IG1pbkhlaWdodDogXCI2MHB4XCIgfX0+XHJcbiAgICAgICAgICAgICAgICAgICAgICB7bGluZX1cclxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgKSl9XHJcbiAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICA8L01vZGFsPlxyXG4gICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgY29udGVudENvbnRhaW5lciA9IGZpbmRNb2RhbENvbnRlbnRDb250YWluZXIoY29udGFpbmVyKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChjb250ZW50Q29udGFpbmVyKSB7XHJcbiAgICAgICAgICAgICAgLy8gTWF4IGhlaWdodCBzaG91bGQgYWx3YXlzIGJlIDg1dmggcmVnYXJkbGVzcyBvZiB2aWV3cG9ydCBoZWlnaHRcclxuICAgICAgICAgICAgICBleHBlY3QoY29udGVudENvbnRhaW5lci5jbGFzc05hbWUpLnRvTWF0Y2goL21heC1oLVxcWzg1dmhcXF0vKTtcclxuICAgICAgICAgICAgICBleHBlY3QoY29udGVudENvbnRhaW5lci5jbGFzc05hbWUpLnRvTWF0Y2goL292ZXJmbG93LXktYXV0by8pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgKSxcclxuICAgICAgICB7IG51bVJ1bnM6IGdldE51bVJ1bnMoXCJGQVNUXCIpIH1cclxuICAgICAgKTtcclxuICAgIH0pO1xyXG4gIH0pO1xyXG5cclxuICBkZXNjcmliZShcIlJlcXVpcmVtZW50IHZhbGlkYXRpb25cIiwgKCkgPT4ge1xyXG4gICAgaXQoXCJ2YWxpZGF0ZXMgUmVxdWlyZW1lbnQgNC4yOiBNb2RhbCBjb250ZW50IHNjcm9sbGluZyBvbiBtb2JpbGUgZGV2aWNlc1wiLCAoKSA9PiB7XHJcbiAgICAgIGplc3Quc2V0VGltZW91dChnZXRUaW1lb3V0KFwiU0xPV1wiKSk7XHJcbiAgICAgIGZjLmFzc2VydChcclxuICAgICAgICBmYy5wcm9wZXJ0eShcclxuICAgICAgICAgIGZjLmludGVnZXIoeyBtaW46IDMyMCwgbWF4OiA2MzkgfSksIC8vIE1vYmlsZSB2aWV3cG9ydCB3aWR0aFxyXG4gICAgICAgICAgZmMuYXJyYXkoZmMuc3RyaW5nKHsgbWluTGVuZ3RoOiA1MCwgbWF4TGVuZ3RoOiAxNTAgfSksIHsgbWluTGVuZ3RoOiAxNSwgbWF4TGVuZ3RoOiA0MCB9KSxcclxuICAgICAgICAgIGZjLmNvbnN0YW50RnJvbShcInNtXCIgYXMgY29uc3QsIFwibWRcIiBhcyBjb25zdCwgXCJsZ1wiIGFzIGNvbnN0LCBcInhsXCIgYXMgY29uc3QpLFxyXG4gICAgICAgICAgKHZpZXdwb3J0V2lkdGgsIGNvbnRlbnRMaW5lcywgc2l6ZSkgPT4ge1xyXG4gICAgICAgICAgICAvLyBNb2NrIG1vYmlsZSB2aWV3cG9ydFxyXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkod2luZG93LCBcImlubmVyV2lkdGhcIiwge1xyXG4gICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgICB2YWx1ZTogdmlld3BvcnRXaWR0aCxcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkod2luZG93LCBcImlubmVySGVpZ2h0XCIsIHtcclxuICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgdmFsdWU6IDY2NywgLy8gVHlwaWNhbCBtb2JpbGUgaGVpZ2h0XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgLy8gUmVxdWlyZW1lbnQgNC4yOiBXSEVOINCc0L7QtNCw0LvRjNC90L7QtV/QntC60L3QviDQvtGC0LrRgNGL0YLQviDQvdCwINC80L7QsdC40LvRjNC90L7QvCDRg9GB0YLRgNC+0LnRgdGC0LLQtSxcclxuICAgICAgICAgICAgLy8gVEhFINCh0LjRgdGC0LXQvNCwIFNIQUxMINC+0LHQtdGB0L/QtdGH0LjQstCw0YLRjCDQstC+0LfQvNC+0LbQvdC+0YHRgtGMINC/0YDQvtC60YDRg9GC0LrQuCDRgdC+0LTQtdGA0LbQuNC80L7Qs9C+XHJcbiAgICAgICAgICAgIGNvbnN0IHsgY29udGFpbmVyIH0gPSByZW5kZXIoXHJcbiAgICAgICAgICAgICAgPE1vZGFsIGlzT3Blbj17dHJ1ZX0gb25DbG9zZT17KCkgPT4ge319IHNpemU9e3NpemV9PlxyXG4gICAgICAgICAgICAgICAgPGRpdj5cclxuICAgICAgICAgICAgICAgICAge2NvbnRlbnRMaW5lcy5tYXAoKGxpbmUsIGluZGV4KSA9PiAoXHJcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBrZXk9e2luZGV4fSBzdHlsZT17eyBtaW5IZWlnaHQ6IFwiODBweFwiLCBwYWRkaW5nOiBcIjEwcHhcIiB9fT5cclxuICAgICAgICAgICAgICAgICAgICAgIHtsaW5lfVxyXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICApKX1cclxuICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgIDwvTW9kYWw+XHJcbiAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICBjb25zdCBjb250ZW50Q29udGFpbmVyID0gZmluZE1vZGFsQ29udGVudENvbnRhaW5lcihjb250YWluZXIpO1xyXG5cclxuICAgICAgICAgICAgaWYgKGNvbnRlbnRDb250YWluZXIpIHtcclxuICAgICAgICAgICAgICAvLyBNb2RhbCBjb250ZW50IHNob3VsZCBoYXZlIG92ZXJmbG93LXk6IGF1dG8gZm9yIHNjcm9sbGluZ1xyXG4gICAgICAgICAgICAgIGV4cGVjdChjb250ZW50Q29udGFpbmVyLmNsYXNzTmFtZSkudG9NYXRjaCgvb3ZlcmZsb3cteS1hdXRvLyk7XHJcbiAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgLy8gU2hvdWxkIGhhdmUgbWF4LWhlaWdodCBjb25zdHJhaW50IHRvIGVuYWJsZSBzY3JvbGxpbmdcclxuICAgICAgICAgICAgICBleHBlY3QoY29udGVudENvbnRhaW5lci5jbGFzc05hbWUpLnRvTWF0Y2goL21heC1oLVxcWzg1dmhcXF0vKTtcclxuICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAvLyBDb21wdXRlZCBvdmVyZmxvdyBzaG91bGQgYWxsb3cgc2Nyb2xsaW5nXHJcbiAgICAgICAgICAgICAgY29uc3Qgb3ZlcmZsb3dZID0gZ2V0Q29tcHV0ZWRPdmVyZmxvdyhjb250ZW50Q29udGFpbmVyKTtcclxuICAgICAgICAgICAgICBleHBlY3QoW1wiYXV0b1wiLCBcInNjcm9sbFwiXSkudG9Db250YWluKG92ZXJmbG93WSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICApLFxyXG4gICAgICAgIHsgbnVtUnVuczogZ2V0TnVtUnVucyhcIk1FRElVTVwiKSB9XHJcbiAgICAgICk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBpdChcInZhbGlkYXRlcyB0aGF0IHNjcm9sbGluZyBpcyBhdmFpbGFibGUgb24gYWxsIGRldmljZSBzaXplc1wiLCAoKSA9PiB7XHJcbiAgICAgIGplc3Quc2V0VGltZW91dChnZXRUaW1lb3V0KFwiU0xPV1wiKSk7XHJcbiAgICAgIGZjLmFzc2VydChcclxuICAgICAgICBmYy5wcm9wZXJ0eShcclxuICAgICAgICAgIGZjLmludGVnZXIoeyBtaW46IDMyMCwgbWF4OiAxNDQwIH0pLCAvLyBBbGwgdmlld3BvcnQgd2lkdGhzXHJcbiAgICAgICAgICBmYy5hcnJheShmYy5zdHJpbmcoeyBtaW5MZW5ndGg6IDMwLCBtYXhMZW5ndGg6IDEwMCB9KSwgeyBtaW5MZW5ndGg6IDIwLCBtYXhMZW5ndGg6IDUwIH0pLFxyXG4gICAgICAgICAgKHZpZXdwb3J0V2lkdGgsIGNvbnRlbnRMaW5lcykgPT4ge1xyXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkod2luZG93LCBcImlubmVyV2lkdGhcIiwge1xyXG4gICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgICB2YWx1ZTogdmlld3BvcnRXaWR0aCxcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBjb25zdCB7IGNvbnRhaW5lciB9ID0gcmVuZGVyKFxyXG4gICAgICAgICAgICAgIDxNb2RhbCBpc09wZW49e3RydWV9IG9uQ2xvc2U9eygpID0+IHt9fSBzaXplPVwibWRcIj5cclxuICAgICAgICAgICAgICAgIDxkaXY+XHJcbiAgICAgICAgICAgICAgICAgIHtjb250ZW50TGluZXMubWFwKChsaW5lLCBpbmRleCkgPT4gKFxyXG4gICAgICAgICAgICAgICAgICAgIDxkaXYga2V5PXtpbmRleH0gc3R5bGU9e3sgbWluSGVpZ2h0OiBcIjcwcHhcIiB9fT5cclxuICAgICAgICAgICAgICAgICAgICAgIHtsaW5lfVxyXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICApKX1cclxuICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgIDwvTW9kYWw+XHJcbiAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICBjb25zdCBjb250ZW50Q29udGFpbmVyID0gZmluZE1vZGFsQ29udGVudENvbnRhaW5lcihjb250YWluZXIpO1xyXG5cclxuICAgICAgICAgICAgaWYgKGNvbnRlbnRDb250YWluZXIpIHtcclxuICAgICAgICAgICAgICAvLyBTY3JvbGxpbmcgc2hvdWxkIGJlIGF2YWlsYWJsZSBvbiBhbGwgZGV2aWNlIHNpemVzXHJcbiAgICAgICAgICAgICAgZXhwZWN0KGNvbnRlbnRDb250YWluZXIuY2xhc3NOYW1lKS50b01hdGNoKC9vdmVyZmxvdy15LWF1dG8vKTtcclxuICAgICAgICAgICAgICBleHBlY3QoY29udGVudENvbnRhaW5lci5jbGFzc05hbWUpLnRvTWF0Y2goL21heC1oLVxcWzg1dmhcXF0vKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICksXHJcbiAgICAgICAgeyBudW1SdW5zOiBnZXROdW1SdW5zKFwiTUVESVVNXCIpIH1cclxuICAgICAgKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGl0KFwidmFsaWRhdGVzIHRoYXQgbWF4LWhlaWdodCBpcyA4NSUgb2Ygdmlld3BvcnQgaGVpZ2h0XCIsICgpID0+IHtcclxuICAgICAgamVzdC5zZXRUaW1lb3V0KGdldFRpbWVvdXQoXCJTTE9XXCIpKTtcclxuICAgICAgZmMuYXNzZXJ0KFxyXG4gICAgICAgIGZjLnByb3BlcnR5KFxyXG4gICAgICAgICAgZmMuY29uc3RhbnRGcm9tKFwic21cIiBhcyBjb25zdCwgXCJtZFwiIGFzIGNvbnN0LCBcImxnXCIgYXMgY29uc3QsIFwieGxcIiBhcyBjb25zdCksXHJcbiAgICAgICAgICAoc2l6ZSkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCB7IGNvbnRhaW5lciB9ID0gcmVuZGVyKFxyXG4gICAgICAgICAgICAgIDxNb2RhbCBpc09wZW49e3RydWV9IG9uQ2xvc2U9eygpID0+IHt9fSBzaXplPXtzaXplfT5cclxuICAgICAgICAgICAgICAgIDxkaXY+VGVzdCBjb250ZW50PC9kaXY+XHJcbiAgICAgICAgICAgICAgPC9Nb2RhbD5cclxuICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IGNvbnRlbnRDb250YWluZXIgPSBmaW5kTW9kYWxDb250ZW50Q29udGFpbmVyKGNvbnRhaW5lcik7XHJcblxyXG4gICAgICAgICAgICBpZiAoY29udGVudENvbnRhaW5lcikge1xyXG4gICAgICAgICAgICAgIC8vIFNob3VsZCB1c2UgbWF4LWgtWzg1dmhdIHdoaWNoIGlzIDg1JSBvZiB2aWV3cG9ydCBoZWlnaHRcclxuICAgICAgICAgICAgICBleHBlY3QoY29udGVudENvbnRhaW5lci5jbGFzc05hbWUpLnRvTWF0Y2goL21heC1oLVxcWzg1dmhcXF0vKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICksXHJcbiAgICAgICAgeyBudW1SdW5zOiBnZXROdW1SdW5zKFwiRkFTVFwiKSB9XHJcbiAgICAgICk7XHJcbiAgICB9KTtcclxuICB9KTtcclxuXHJcbiAgZGVzY3JpYmUoXCJHZW5lcmFsIHByb3BlcnR5IHZhbGlkYXRpb25cIiwgKCkgPT4ge1xyXG4gICAgaXQoXCJzaG91bGQgdmVyaWZ5IHNjcm9sbGluZyBwcm9wZXJ0aWVzIGFyZSBwcmVzZW50IGFjcm9zcyBhbGwgY29uZmlndXJhdGlvbnNcIiwgKCkgPT4ge1xyXG4gICAgICBqZXN0LnNldFRpbWVvdXQoZ2V0VGltZW91dChcIlNMT1dcIikpO1xyXG4gICAgICBmYy5hc3NlcnQoXHJcbiAgICAgICAgZmMucHJvcGVydHkoXHJcbiAgICAgICAgICBmYy5pbnRlZ2VyKHsgbWluOiAzMjAsIG1heDogMTQ0MCB9KSxcclxuICAgICAgICAgIGZjLmNvbnN0YW50RnJvbShcInNtXCIgYXMgY29uc3QsIFwibWRcIiBhcyBjb25zdCwgXCJsZ1wiIGFzIGNvbnN0LCBcInhsXCIgYXMgY29uc3QpLFxyXG4gICAgICAgICAgZmMub25lb2Yoc2hvcnRDb250ZW50QXJiaXRyYXJ5LCB0YWxsQ29udGVudEFyYml0cmFyeSksXHJcbiAgICAgICAgICBmYy5vcHRpb24oZmMuc3RyaW5nKHsgbWluTGVuZ3RoOiA1LCBtYXhMZW5ndGg6IDUwIH0pLCB7IG5pbDogdW5kZWZpbmVkIH0pLFxyXG4gICAgICAgICAgKHZpZXdwb3J0V2lkdGgsIHNpemUsIGNvbnRlbnRMaW5lcywgdGl0bGUpID0+IHtcclxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHdpbmRvdywgXCJpbm5lcldpZHRoXCIsIHtcclxuICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgdmFsdWU6IHZpZXdwb3J0V2lkdGgsXHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgeyBjb250YWluZXIgfSA9IHJlbmRlcihcclxuICAgICAgICAgICAgICA8TW9kYWwgaXNPcGVuPXt0cnVlfSBvbkNsb3NlPXsoKSA9PiB7fX0gc2l6ZT17c2l6ZX0gdGl0bGU9e3RpdGxlfT5cclxuICAgICAgICAgICAgICAgIDxkaXY+XHJcbiAgICAgICAgICAgICAgICAgIHtjb250ZW50TGluZXMubWFwKChsaW5lLCBpbmRleCkgPT4gKFxyXG4gICAgICAgICAgICAgICAgICAgIDxwIGtleT17aW5kZXh9PntsaW5lfTwvcD5cclxuICAgICAgICAgICAgICAgICAgKSl9XHJcbiAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICA8L01vZGFsPlxyXG4gICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgY29udGVudENvbnRhaW5lciA9IGZpbmRNb2RhbENvbnRlbnRDb250YWluZXIoY29udGFpbmVyKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChjb250ZW50Q29udGFpbmVyKSB7XHJcbiAgICAgICAgICAgICAgLy8gQWxsIG1vZGFscyBzaG91bGQgaGF2ZSBzY3JvbGxpbmcgY2FwYWJpbGl0eVxyXG4gICAgICAgICAgICAgIGV4cGVjdChjb250ZW50Q29udGFpbmVyLmNsYXNzTmFtZSkudG9NYXRjaCgvb3ZlcmZsb3cteS1hdXRvLyk7XHJcbiAgICAgICAgICAgICAgZXhwZWN0KGNvbnRlbnRDb250YWluZXIuY2xhc3NOYW1lKS50b01hdGNoKC9tYXgtaC1cXFs4NXZoXFxdLyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICApLFxyXG4gICAgICAgIHsgbnVtUnVuczogZ2V0TnVtUnVucyhcIk1FRElVTVwiKSB9XHJcbiAgICAgICk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBpdChcInNob3VsZCBlbnN1cmUgY29uc2lzdGVudCBzY3JvbGxpbmcgYmVoYXZpb3IgYWNyb3NzIG1vZGFsIGxpZmVjeWNsZVwiLCAoKSA9PiB7XHJcbiAgICAgIGplc3Quc2V0VGltZW91dChnZXRUaW1lb3V0KFwiU0xPV1wiKSk7XHJcbiAgICAgIGZjLmFzc2VydChcclxuICAgICAgICBmYy5wcm9wZXJ0eShcclxuICAgICAgICAgIGZjLmFycmF5KGZjLnN0cmluZyh7IG1pbkxlbmd0aDogMjAsIG1heExlbmd0aDogMTAwIH0pLCB7IG1pbkxlbmd0aDogMTAsIG1heExlbmd0aDogMzAgfSksXHJcbiAgICAgICAgICAoY29udGVudExpbmVzKSA9PiB7XHJcbiAgICAgICAgICAgIC8vIFJlbmRlciBtb2RhbFxyXG4gICAgICAgICAgICBjb25zdCB7IGNvbnRhaW5lciwgcmVyZW5kZXIgfSA9IHJlbmRlcihcclxuICAgICAgICAgICAgICA8TW9kYWwgaXNPcGVuPXt0cnVlfSBvbkNsb3NlPXsoKSA9PiB7fX0gc2l6ZT1cIm1kXCI+XHJcbiAgICAgICAgICAgICAgICA8ZGl2PlxyXG4gICAgICAgICAgICAgICAgICB7Y29udGVudExpbmVzLm1hcCgobGluZSwgaW5kZXgpID0+IChcclxuICAgICAgICAgICAgICAgICAgICA8cCBrZXk9e2luZGV4fT57bGluZX08L3A+XHJcbiAgICAgICAgICAgICAgICAgICkpfVxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgPC9Nb2RhbD5cclxuICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgIGxldCBjb250ZW50Q29udGFpbmVyID0gZmluZE1vZGFsQ29udGVudENvbnRhaW5lcihjb250YWluZXIpO1xyXG5cclxuICAgICAgICAgICAgaWYgKGNvbnRlbnRDb250YWluZXIpIHtcclxuICAgICAgICAgICAgICBleHBlY3QoY29udGVudENvbnRhaW5lci5jbGFzc05hbWUpLnRvTWF0Y2goL292ZXJmbG93LXktYXV0by8pO1xyXG4gICAgICAgICAgICAgIGV4cGVjdChjb250ZW50Q29udGFpbmVyLmNsYXNzTmFtZSkudG9NYXRjaCgvbWF4LWgtXFxbODV2aFxcXS8pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBSZS1yZW5kZXIgd2l0aCBkaWZmZXJlbnQgY29udGVudFxyXG4gICAgICAgICAgICByZXJlbmRlcihcclxuICAgICAgICAgICAgICA8TW9kYWwgaXNPcGVuPXt0cnVlfSBvbkNsb3NlPXsoKSA9PiB7fX0gc2l6ZT1cImxnXCI+XHJcbiAgICAgICAgICAgICAgICA8ZGl2PlxyXG4gICAgICAgICAgICAgICAgICB7Y29udGVudExpbmVzLnNsaWNlKDAsIDUpLm1hcCgobGluZSwgaW5kZXgpID0+IChcclxuICAgICAgICAgICAgICAgICAgICA8cCBrZXk9e2luZGV4fT57bGluZX08L3A+XHJcbiAgICAgICAgICAgICAgICAgICkpfVxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgPC9Nb2RhbD5cclxuICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgIGNvbnRlbnRDb250YWluZXIgPSBmaW5kTW9kYWxDb250ZW50Q29udGFpbmVyKGNvbnRhaW5lcik7XHJcblxyXG4gICAgICAgICAgICBpZiAoY29udGVudENvbnRhaW5lcikge1xyXG4gICAgICAgICAgICAgIC8vIFNjcm9sbGluZyBwcm9wZXJ0aWVzIHNob3VsZCBwZXJzaXN0IGFmdGVyIHJlLXJlbmRlclxyXG4gICAgICAgICAgICAgIGV4cGVjdChjb250ZW50Q29udGFpbmVyLmNsYXNzTmFtZSkudG9NYXRjaCgvb3ZlcmZsb3cteS1hdXRvLyk7XHJcbiAgICAgICAgICAgICAgZXhwZWN0KGNvbnRlbnRDb250YWluZXIuY2xhc3NOYW1lKS50b01hdGNoKC9tYXgtaC1cXFs4NXZoXFxdLyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICApLFxyXG4gICAgICAgIHsgbnVtUnVuczogZ2V0TnVtUnVucyhcIkZBU1RcIikgfVxyXG4gICAgICApO1xyXG4gICAgfSk7XHJcbiAgfSk7XHJcbn0pO1xyXG4iXSwibmFtZXMiOlsiTUFYX01PREFMX0hFSUdIVF9WSCIsImdldENvbXB1dGVkT3ZlcmZsb3ciLCJlbGVtZW50IiwiY29tcHV0ZWRTdHlsZSIsIndpbmRvdyIsImdldENvbXB1dGVkU3R5bGUiLCJvdmVyZmxvd1kiLCJoYXNNYXhIZWlnaHRDb25zdHJhaW50IiwiY2xhc3NlcyIsImNsYXNzTmFtZSIsImluY2x1ZGVzIiwiZmluZE1vZGFsQ29udGVudENvbnRhaW5lciIsImNvbnRhaW5lciIsImNvbnRlbnRDb250YWluZXIiLCJxdWVyeVNlbGVjdG9yIiwidGFsbENvbnRlbnRBcmJpdHJhcnkiLCJmYyIsImFycmF5Iiwic3RyaW5nIiwibWluTGVuZ3RoIiwibWF4TGVuZ3RoIiwic2hvcnRDb250ZW50QXJiaXRyYXJ5IiwiZGVzY3JpYmUiLCJpdCIsImplc3QiLCJzZXRUaW1lb3V0IiwiZ2V0VGltZW91dCIsImFzc2VydCIsInByb3BlcnR5IiwiY29uc3RhbnRGcm9tIiwic2l6ZSIsImNvbnRlbnRMaW5lcyIsInJlbmRlciIsIk1vZGFsIiwiaXNPcGVuIiwib25DbG9zZSIsImRpdiIsIm1hcCIsImxpbmUiLCJpbmRleCIsInAiLCJleHBlY3QiLCJ0b01hdGNoIiwidG9Db250YWluIiwibnVtUnVucyIsImdldE51bVJ1bnMiLCJvbmVvZiIsInN0eWxlIiwibWluSGVpZ2h0IiwidG9CZSIsInNpemVzIiwiZm9yRWFjaCIsImludGVnZXIiLCJtaW4iLCJtYXgiLCJ2aWV3cG9ydFdpZHRoIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJ3cml0YWJsZSIsImNvbmZpZ3VyYWJsZSIsInZhbHVlIiwicGFkZGluZyIsInJlY29yZCIsImxhYmVsIiwidHlwZSIsImZpZWxkcyIsInRpdGxlIiwiZm9ybSIsImZpZWxkIiwibWFyZ2luQm90dG9tIiwidGV4dGFyZWEiLCJ3aWR0aCIsImhlaWdodCIsImlucHV0IiwiaXRlbXMiLCJzZWN0aW9ucyIsInNlY3Rpb24iLCJzZWN0aW9uSW5kZXgiLCJoMyIsInVsIiwiaXRlbSIsIml0ZW1JbmRleCIsImxpIiwiY29udGVudCIsImNvbnRlbnRCbG9ja3MiLCJibG9jayIsImJhY2tncm91bmQiLCJ2aWV3cG9ydEhlaWdodCIsIm9wdGlvbiIsIm5pbCIsInVuZGVmaW5lZCIsInJlcmVuZGVyIiwic2xpY2UiXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7O0NBVUM7Ozs7OzhEQUVpQjt3QkFDSztrRUFDUjt1QkFDTztvQ0FDaUI7Ozs7OztBQUV2QywyREFBMkQ7QUFDM0QsTUFBTUEsc0JBQXNCO0FBRTVCLHlDQUF5QztBQUN6QyxNQUFNQyxzQkFBc0IsQ0FBQ0M7SUFDM0IsTUFBTUMsZ0JBQWdCQyxPQUFPQyxnQkFBZ0IsQ0FBQ0g7SUFDOUMsT0FBT0MsY0FBY0csU0FBUztBQUNoQztBQUVBLGdFQUFnRTtBQUNoRSxNQUFNQyx5QkFBeUIsQ0FBQ0w7SUFDOUIsTUFBTU0sVUFBVU4sUUFBUU8sU0FBUztJQUNqQyxPQUFPRCxRQUFRRSxRQUFRLENBQUM7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