7da3ae7d24599427bf14e274d615daa8
/**
 * Property-Based Test — Minimum Padding/Margins
 * 
 * **Property 3: Минимальные отступы контейнеров**
 * **Validates: Requirements 1.4, 6.3**
 * 
 * For any container on the page, when viewport width is in range 320px-480px,
 * minimum padding of 16px (1rem) is ensured on edges.
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _jsxruntime = require("react/jsx-runtime");
const _react = /*#__PURE__*/ _interop_require_default(require("react"));
const _react1 = require("@testing-library/react");
const _fastcheck = /*#__PURE__*/ _interop_require_default(require("fast-check"));
const _BalanceCards = require("../../src/components/dashboard/BalanceCards");
const _propertytestconfig = require("./property-test-config");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
// Helper function to get computed padding from an element
const getPaddingValues = (element)=>{
    const computedStyle = window.getComputedStyle(element);
    return {
        paddingLeft: parseFloat(computedStyle.paddingLeft) || 0,
        paddingRight: parseFloat(computedStyle.paddingRight) || 0,
        paddingTop: parseFloat(computedStyle.paddingTop) || 0,
        paddingBottom: parseFloat(computedStyle.paddingBottom) || 0
    };
};
// Helper function to check if element has minimum padding classes
const hasMinimumPaddingClasses = (element)=>{
    const classList = Array.from(element.classList);
    // Check for p-2 (8px padding on all sides) or px-2/py-2 (8px horizontal/vertical)
    const hasPadding2 = classList.some((cls)=>cls === "p-2" || cls === "px-2" || cls === "py-2" || cls === "p-0");
    // Check for responsive padding classes (sm:p-3, md:p-4, etc.)
    const hasResponsivePadding = classList.some((cls)=>/^(sm|md|lg|xl|2xl):p(x|y)?-\d+$/.test(cls));
    return hasPadding2 || hasResponsivePadding;
};
// Mock window.innerWidth for viewport testing
const setViewportWidth = (width)=>{
    Object.defineProperty(window, "innerWidth", {
        writable: true,
        configurable: true,
        value: width
    });
    // Trigger resize event
    window.dispatchEvent(new Event("resize"));
};
describe("Property: Minimum Padding/Margins", ()=>{
    describe("BalanceCards minimum padding on mobile viewports", ()=>{
        it("should ensure minimum 8px padding on card containers for any viewport width in 320px-480px range", ()=>{
            _fastcheck.default.assert(_fastcheck.default.property(_fastcheck.default.integer({
                min: 320,
                max: 480
            }), _fastcheck.default.integer({
                min: 0,
                max: 1000000
            }), _fastcheck.default.integer({
                min: 0,
                max: 1000000
            }), (viewportWidth, income, expense)=>{
                const balance = income - expense;
                // Set viewport width
                setViewportWidth(viewportWidth);
                const { container } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_BalanceCards.BalanceCards, {
                    totalIncome: income,
                    totalExpense: expense,
                    balance: balance
                }));
                // Find all Card elements (containers with padding)
                const cards = container.querySelectorAll(".p-2, .sm\\:p-3, .md\\:p-4");
                expect(cards.length).toBeGreaterThan(0);
                // Verify each card has minimum padding classes
                cards.forEach((card)=>{
                    // Check for p-2 class (8px padding on mobile)
                    expect(card).toHaveClass("p-2");
                    // Verify the card has responsive padding classes
                    expect(hasMinimumPaddingClasses(card)).toBe(true);
                });
            }), {
                numRuns: (0, _propertytestconfig.getNumRuns)("MEDIUM")
            });
        });
        it("should maintain minimum 8px padding regardless of content size", ()=>{
            _fastcheck.default.assert(_fastcheck.default.property(_fastcheck.default.integer({
                min: 320,
                max: 480
            }), _fastcheck.default.integer({
                min: 0,
                max: 999999999
            }), _fastcheck.default.integer({
                min: 0,
                max: 999999999
            }), (viewportWidth, income, expense)=>{
                const balance = income - expense;
                setViewportWidth(viewportWidth);
                const { container } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_BalanceCards.BalanceCards, {
                    totalIncome: income,
                    totalExpense: expense,
                    balance: balance
                }));
                const cards = container.querySelectorAll(".p-2");
                expect(cards.length).toBeGreaterThan(0);
                // All cards should have p-2 class (8px minimum padding on mobile)
                cards.forEach((card)=>{
                    expect(card).toHaveClass("p-2");
                });
            }), {
                numRuns: (0, _propertytestconfig.getNumRuns)("MEDIUM")
            });
        });
        it("should have progressive padding classes: p-2 sm:p-3 md:p-4", ()=>{
            _fastcheck.default.assert(_fastcheck.default.property(_fastcheck.default.integer({
                min: 320,
                max: 480
            }), _fastcheck.default.integer({
                min: 0,
                max: 1000000
            }), _fastcheck.default.integer({
                min: 0,
                max: 1000000
            }), (viewportWidth, income, expense)=>{
                const balance = income - expense;
                setViewportWidth(viewportWidth);
                const { container } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_BalanceCards.BalanceCards, {
                    totalIncome: income,
                    totalExpense: expense,
                    balance: balance
                }));
                const cards = container.querySelectorAll(".p-2");
                expect(cards.length).toBeGreaterThan(0);
                // Verify progressive padding classes
                cards.forEach((card)=>{
                    expect(card).toHaveClass("p-2");
                    expect(card).toHaveClass("sm:p-3");
                    expect(card).toHaveClass("md:p-4");
                });
            }), {
                numRuns: (0, _propertytestconfig.getNumRuns)("MEDIUM")
            });
        });
    });
    describe("Container padding at viewport boundaries", ()=>{
        it("should maintain minimum padding at lower boundary (320px)", ()=>{
            const { container } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_BalanceCards.BalanceCards, {
                totalIncome: 50000,
                totalExpense: 30000,
                balance: 20000
            }));
            setViewportWidth(320);
            const cards = container.querySelectorAll(".p-2");
            expect(cards.length).toBeGreaterThan(0);
            cards.forEach((card)=>{
                expect(card).toHaveClass("p-2");
            });
        });
        it("should maintain minimum padding at upper boundary (480px)", ()=>{
            const { container } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_BalanceCards.BalanceCards, {
                totalIncome: 50000,
                totalExpense: 30000,
                balance: 20000
            }));
            setViewportWidth(480);
            const cards = container.querySelectorAll(".p-2");
            expect(cards.length).toBeGreaterThan(0);
            cards.forEach((card)=>{
                expect(card).toHaveClass("p-2");
            });
        });
        it("should have consistent padding classes across all three balance cards", ()=>{
            _fastcheck.default.assert(_fastcheck.default.property(_fastcheck.default.integer({
                min: 320,
                max: 480
            }), _fastcheck.default.integer({
                min: 0,
                max: 1000000
            }), _fastcheck.default.integer({
                min: 0,
                max: 1000000
            }), (viewportWidth, income, expense)=>{
                const balance = income - expense;
                setViewportWidth(viewportWidth);
                const { container } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_BalanceCards.BalanceCards, {
                    totalIncome: income,
                    totalExpense: expense,
                    balance: balance
                }));
                const cards = container.querySelectorAll(".p-2");
                // Should have exactly 3 cards
                expect(cards.length).toBe(3);
                // All three cards should have identical padding classes
                const firstCardClasses = Array.from(cards[0].classList).filter((cls)=>cls.startsWith("p-") || cls.includes(":p-")).sort();
                cards.forEach((card)=>{
                    const cardPaddingClasses = Array.from(card.classList).filter((cls)=>cls.startsWith("p-") || cls.includes(":p-")).sort();
                    expect(cardPaddingClasses).toEqual(firstCardClasses);
                });
            }), {
                numRuns: (0, _propertytestconfig.getNumRuns)("MEDIUM")
            });
        });
    });
    describe("Edge cases", ()=>{
        it("should maintain padding with empty currency data", ()=>{
            _fastcheck.default.assert(_fastcheck.default.property(_fastcheck.default.integer({
                min: 320,
                max: 480
            }), (viewportWidth)=>{
                setViewportWidth(viewportWidth);
                const { container } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_BalanceCards.BalanceCards, {
                    totalIncome: 0,
                    totalExpense: 0,
                    balance: 0,
                    byCurrency: []
                }));
                const cards = container.querySelectorAll(".p-2");
                expect(cards.length).toBeGreaterThan(0);
                cards.forEach((card)=>{
                    expect(card).toHaveClass("p-2");
                });
            }), {
                numRuns: (0, _propertytestconfig.getNumRuns)("MEDIUM")
            });
        });
        it("should maintain padding with multiple currencies", ()=>{
            _fastcheck.default.assert(_fastcheck.default.property(_fastcheck.default.integer({
                min: 320,
                max: 480
            }), (viewportWidth)=>{
                setViewportWidth(viewportWidth);
                const { container } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_BalanceCards.BalanceCards, {
                    totalIncome: 50000,
                    totalExpense: 30000,
                    balance: 20000,
                    byCurrency: [
                        {
                            currency: "RUB",
                            totalIncome: 30000,
                            totalExpense: 20000,
                            balance: 10000
                        },
                        {
                            currency: "USD",
                            totalIncome: 20000,
                            totalExpense: 10000,
                            balance: 10000
                        }
                    ]
                }));
                const cards = container.querySelectorAll(".p-2");
                expect(cards.length).toBeGreaterThan(0);
                cards.forEach((card)=>{
                    expect(card).toHaveClass("p-2");
                    expect(card).toHaveClass("sm:p-3");
                    expect(card).toHaveClass("md:p-4");
                });
            }), {
                numRuns: (0, _propertytestconfig.getNumRuns)("MEDIUM")
            });
        });
        it("should maintain padding in loading state", ()=>{
            _fastcheck.default.assert(_fastcheck.default.property(_fastcheck.default.integer({
                min: 320,
                max: 480
            }), (viewportWidth)=>{
                setViewportWidth(viewportWidth);
                const { container } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_BalanceCards.BalanceCards, {
                    totalIncome: 0,
                    totalExpense: 0,
                    balance: 0,
                    loading: true
                }));
                // In loading state, CardContent has padding classes
                const cardContents = container.querySelectorAll(".p-4, .sm\\:p-6, .md\\:p-8");
                expect(cardContents.length).toBeGreaterThan(0);
                // Verify at least some elements have padding
                const elementsWithPadding = container.querySelectorAll(".p-4");
                expect(elementsWithPadding.length).toBeGreaterThan(0);
            }), {
                numRuns: (0, _propertytestconfig.getNumRuns)("MEDIUM")
            });
        });
        it("should ensure minimum padding is never less than 8px", ()=>{
            _fastcheck.default.assert(_fastcheck.default.property(_fastcheck.default.integer({
                min: 320,
                max: 480
            }), _fastcheck.default.integer({
                min: 0,
                max: 1000000
            }), _fastcheck.default.integer({
                min: 0,
                max: 1000000
            }), (viewportWidth, income, expense)=>{
                const balance = income - expense;
                setViewportWidth(viewportWidth);
                const { container } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_BalanceCards.BalanceCards, {
                    totalIncome: income,
                    totalExpense: expense,
                    balance: balance
                }));
                const cards = container.querySelectorAll(".p-2");
                // Verify that p-2 class is present (which equals 8px in Tailwind)
                // This ensures minimum padding is at least 8px
                cards.forEach((card)=>{
                    expect(card).toHaveClass("p-2");
                // p-2 in Tailwind = 0.5rem = 8px (at default font size)
                // This is the minimum required padding
                });
            }), {
                numRuns: (0, _propertytestconfig.getNumRuns)("MEDIUM")
            });
        });
    });
    describe("Viewport width variations", ()=>{
        it("should maintain minimum padding across entire mobile range", ()=>{
            const testViewports = [
                320,
                360,
                375,
                390,
                414,
                428,
                480
            ];
            testViewports.forEach((viewportWidth)=>{
                setViewportWidth(viewportWidth);
                const { container } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_BalanceCards.BalanceCards, {
                    totalIncome: 50000,
                    totalExpense: 30000,
                    balance: 20000
                }));
                const cards = container.querySelectorAll(".p-2");
                expect(cards.length).toBeGreaterThan(0);
                cards.forEach((card)=>{
                    expect(card).toHaveClass("p-2");
                });
            });
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkU6XFxteVxcb3R1c1xcZmluYW5jZV90cmFja2VyXFxmcm9udGVuZFxcX190ZXN0c19fXFxwcm9wZXJ0aWVzXFxtaW5pbXVtUGFkZGluZy5wcm9wZXJ0eS50ZXN0LnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogUHJvcGVydHktQmFzZWQgVGVzdCDigJQgTWluaW11bSBQYWRkaW5nL01hcmdpbnNcclxuICogXHJcbiAqICoqUHJvcGVydHkgMzog0JzQuNC90LjQvNCw0LvRjNC90YvQtSDQvtGC0YHRgtGD0L/RiyDQutC+0L3RgtC10LnQvdC10YDQvtCyKipcclxuICogKipWYWxpZGF0ZXM6IFJlcXVpcmVtZW50cyAxLjQsIDYuMyoqXHJcbiAqIFxyXG4gKiBGb3IgYW55IGNvbnRhaW5lciBvbiB0aGUgcGFnZSwgd2hlbiB2aWV3cG9ydCB3aWR0aCBpcyBpbiByYW5nZSAzMjBweC00ODBweCxcclxuICogbWluaW11bSBwYWRkaW5nIG9mIDE2cHggKDFyZW0pIGlzIGVuc3VyZWQgb24gZWRnZXMuXHJcbiAqL1xyXG5cclxuaW1wb3J0IFJlYWN0IGZyb20gXCJyZWFjdFwiO1xyXG5pbXBvcnQgeyByZW5kZXIgfSBmcm9tIFwiQHRlc3RpbmctbGlicmFyeS9yZWFjdFwiO1xyXG5pbXBvcnQgZmMgZnJvbSBcImZhc3QtY2hlY2tcIjtcclxuaW1wb3J0IHsgQmFsYW5jZUNhcmRzIH0gZnJvbSBcIkAvY29tcG9uZW50cy9kYXNoYm9hcmQvQmFsYW5jZUNhcmRzXCI7XHJcbmltcG9ydCB7IGdldE51bVJ1bnMsIGdldFRpbWVvdXQgfSBmcm9tIFwiLi9wcm9wZXJ0eS10ZXN0LWNvbmZpZ1wiO1xyXG5cclxuLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGdldCBjb21wdXRlZCBwYWRkaW5nIGZyb20gYW4gZWxlbWVudFxyXG5jb25zdCBnZXRQYWRkaW5nVmFsdWVzID0gKGVsZW1lbnQ6IEVsZW1lbnQpOiB7XHJcbiAgcGFkZGluZ0xlZnQ6IG51bWJlcjtcclxuICBwYWRkaW5nUmlnaHQ6IG51bWJlcjtcclxuICBwYWRkaW5nVG9wOiBudW1iZXI7XHJcbiAgcGFkZGluZ0JvdHRvbTogbnVtYmVyO1xyXG59ID0+IHtcclxuICBjb25zdCBjb21wdXRlZFN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XHJcbiAgXHJcbiAgcmV0dXJuIHtcclxuICAgIHBhZGRpbmdMZWZ0OiBwYXJzZUZsb2F0KGNvbXB1dGVkU3R5bGUucGFkZGluZ0xlZnQpIHx8IDAsXHJcbiAgICBwYWRkaW5nUmlnaHQ6IHBhcnNlRmxvYXQoY29tcHV0ZWRTdHlsZS5wYWRkaW5nUmlnaHQpIHx8IDAsXHJcbiAgICBwYWRkaW5nVG9wOiBwYXJzZUZsb2F0KGNvbXB1dGVkU3R5bGUucGFkZGluZ1RvcCkgfHwgMCxcclxuICAgIHBhZGRpbmdCb3R0b206IHBhcnNlRmxvYXQoY29tcHV0ZWRTdHlsZS5wYWRkaW5nQm90dG9tKSB8fCAwLFxyXG4gIH07XHJcbn07XHJcblxyXG4vLyBIZWxwZXIgZnVuY3Rpb24gdG8gY2hlY2sgaWYgZWxlbWVudCBoYXMgbWluaW11bSBwYWRkaW5nIGNsYXNzZXNcclxuY29uc3QgaGFzTWluaW11bVBhZGRpbmdDbGFzc2VzID0gKGVsZW1lbnQ6IEVsZW1lbnQpOiBib29sZWFuID0+IHtcclxuICBjb25zdCBjbGFzc0xpc3QgPSBBcnJheS5mcm9tKGVsZW1lbnQuY2xhc3NMaXN0KTtcclxuICBcclxuICAvLyBDaGVjayBmb3IgcC0yICg4cHggcGFkZGluZyBvbiBhbGwgc2lkZXMpIG9yIHB4LTIvcHktMiAoOHB4IGhvcml6b250YWwvdmVydGljYWwpXHJcbiAgY29uc3QgaGFzUGFkZGluZzIgPSBjbGFzc0xpc3Quc29tZShjbHMgPT4gXHJcbiAgICBjbHMgPT09IFwicC0yXCIgfHwgY2xzID09PSBcInB4LTJcIiB8fCBjbHMgPT09IFwicHktMlwiIHx8IGNscyA9PT0gXCJwLTBcIlxyXG4gICk7XHJcbiAgXHJcbiAgLy8gQ2hlY2sgZm9yIHJlc3BvbnNpdmUgcGFkZGluZyBjbGFzc2VzIChzbTpwLTMsIG1kOnAtNCwgZXRjLilcclxuICBjb25zdCBoYXNSZXNwb25zaXZlUGFkZGluZyA9IGNsYXNzTGlzdC5zb21lKGNscyA9PiBcclxuICAgIC9eKHNtfG1kfGxnfHhsfDJ4bCk6cCh4fHkpPy1cXGQrJC8udGVzdChjbHMpXHJcbiAgKTtcclxuICBcclxuICByZXR1cm4gaGFzUGFkZGluZzIgfHwgaGFzUmVzcG9uc2l2ZVBhZGRpbmc7XHJcbn07XHJcblxyXG4vLyBNb2NrIHdpbmRvdy5pbm5lcldpZHRoIGZvciB2aWV3cG9ydCB0ZXN0aW5nXHJcbmNvbnN0IHNldFZpZXdwb3J0V2lkdGggPSAod2lkdGg6IG51bWJlcikgPT4ge1xyXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3aW5kb3csIFwiaW5uZXJXaWR0aFwiLCB7XHJcbiAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgIHZhbHVlOiB3aWR0aCxcclxuICB9KTtcclxuICBcclxuICAvLyBUcmlnZ2VyIHJlc2l6ZSBldmVudFxyXG4gIHdpbmRvdy5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChcInJlc2l6ZVwiKSk7XHJcbn07XHJcblxyXG5kZXNjcmliZShcIlByb3BlcnR5OiBNaW5pbXVtIFBhZGRpbmcvTWFyZ2luc1wiLCAoKSA9PiB7XHJcbiAgZGVzY3JpYmUoXCJCYWxhbmNlQ2FyZHMgbWluaW11bSBwYWRkaW5nIG9uIG1vYmlsZSB2aWV3cG9ydHNcIiwgKCkgPT4ge1xyXG4gICAgaXQoXCJzaG91bGQgZW5zdXJlIG1pbmltdW0gOHB4IHBhZGRpbmcgb24gY2FyZCBjb250YWluZXJzIGZvciBhbnkgdmlld3BvcnQgd2lkdGggaW4gMzIwcHgtNDgwcHggcmFuZ2VcIiwgKCkgPT4ge1xyXG4gICAgICBmYy5hc3NlcnQoXHJcbiAgICAgICAgZmMucHJvcGVydHkoXHJcbiAgICAgICAgICBmYy5pbnRlZ2VyKHsgbWluOiAzMjAsIG1heDogNDgwIH0pLCAvLyBNb2JpbGUgdmlld3BvcnQgcmFuZ2VcclxuICAgICAgICAgIGZjLmludGVnZXIoeyBtaW46IDAsIG1heDogMTAwMDAwMCB9KSwgLy8gSW5jb21lXHJcbiAgICAgICAgICBmYy5pbnRlZ2VyKHsgbWluOiAwLCBtYXg6IDEwMDAwMDAgfSksIC8vIEV4cGVuc2VcclxuICAgICAgICAgICh2aWV3cG9ydFdpZHRoLCBpbmNvbWUsIGV4cGVuc2UpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgYmFsYW5jZSA9IGluY29tZSAtIGV4cGVuc2U7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAvLyBTZXQgdmlld3BvcnQgd2lkdGhcclxuICAgICAgICAgICAgc2V0Vmlld3BvcnRXaWR0aCh2aWV3cG9ydFdpZHRoKTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGNvbnN0IHsgY29udGFpbmVyIH0gPSByZW5kZXIoXHJcbiAgICAgICAgICAgICAgPEJhbGFuY2VDYXJkc1xyXG4gICAgICAgICAgICAgICAgdG90YWxJbmNvbWU9e2luY29tZX1cclxuICAgICAgICAgICAgICAgIHRvdGFsRXhwZW5zZT17ZXhwZW5zZX1cclxuICAgICAgICAgICAgICAgIGJhbGFuY2U9e2JhbGFuY2V9XHJcbiAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIC8vIEZpbmQgYWxsIENhcmQgZWxlbWVudHMgKGNvbnRhaW5lcnMgd2l0aCBwYWRkaW5nKVxyXG4gICAgICAgICAgICBjb25zdCBjYXJkcyA9IGNvbnRhaW5lci5xdWVyeVNlbGVjdG9yQWxsKFwiLnAtMiwgLnNtXFxcXDpwLTMsIC5tZFxcXFw6cC00XCIpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgZXhwZWN0KGNhcmRzLmxlbmd0aCkudG9CZUdyZWF0ZXJUaGFuKDApO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgLy8gVmVyaWZ5IGVhY2ggY2FyZCBoYXMgbWluaW11bSBwYWRkaW5nIGNsYXNzZXNcclxuICAgICAgICAgICAgY2FyZHMuZm9yRWFjaCgoY2FyZCkgPT4ge1xyXG4gICAgICAgICAgICAgIC8vIENoZWNrIGZvciBwLTIgY2xhc3MgKDhweCBwYWRkaW5nIG9uIG1vYmlsZSlcclxuICAgICAgICAgICAgICBleHBlY3QoY2FyZCkudG9IYXZlQ2xhc3MoXCJwLTJcIik7XHJcbiAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgLy8gVmVyaWZ5IHRoZSBjYXJkIGhhcyByZXNwb25zaXZlIHBhZGRpbmcgY2xhc3Nlc1xyXG4gICAgICAgICAgICAgIGV4cGVjdChoYXNNaW5pbXVtUGFkZGluZ0NsYXNzZXMoY2FyZCkpLnRvQmUodHJ1ZSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICksXHJcbiAgICAgICAgeyBudW1SdW5zOiBnZXROdW1SdW5zKFwiTUVESVVNXCIpIH1cclxuICAgICAgKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGl0KFwic2hvdWxkIG1haW50YWluIG1pbmltdW0gOHB4IHBhZGRpbmcgcmVnYXJkbGVzcyBvZiBjb250ZW50IHNpemVcIiwgKCkgPT4ge1xyXG4gICAgICBmYy5hc3NlcnQoXHJcbiAgICAgICAgZmMucHJvcGVydHkoXHJcbiAgICAgICAgICBmYy5pbnRlZ2VyKHsgbWluOiAzMjAsIG1heDogNDgwIH0pLFxyXG4gICAgICAgICAgZmMuaW50ZWdlcih7IG1pbjogMCwgbWF4OiA5OTk5OTk5OTkgfSksIC8vIEV4dHJlbWUgdmFsdWVzXHJcbiAgICAgICAgICBmYy5pbnRlZ2VyKHsgbWluOiAwLCBtYXg6IDk5OTk5OTk5OSB9KSxcclxuICAgICAgICAgICh2aWV3cG9ydFdpZHRoLCBpbmNvbWUsIGV4cGVuc2UpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgYmFsYW5jZSA9IGluY29tZSAtIGV4cGVuc2U7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBzZXRWaWV3cG9ydFdpZHRoKHZpZXdwb3J0V2lkdGgpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgY29uc3QgeyBjb250YWluZXIgfSA9IHJlbmRlcihcclxuICAgICAgICAgICAgICA8QmFsYW5jZUNhcmRzXHJcbiAgICAgICAgICAgICAgICB0b3RhbEluY29tZT17aW5jb21lfVxyXG4gICAgICAgICAgICAgICAgdG90YWxFeHBlbnNlPXtleHBlbnNlfVxyXG4gICAgICAgICAgICAgICAgYmFsYW5jZT17YmFsYW5jZX1cclxuICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgY29uc3QgY2FyZHMgPSBjb250YWluZXIucXVlcnlTZWxlY3RvckFsbChcIi5wLTJcIik7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBleHBlY3QoY2FyZHMubGVuZ3RoKS50b0JlR3JlYXRlclRoYW4oMCk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAvLyBBbGwgY2FyZHMgc2hvdWxkIGhhdmUgcC0yIGNsYXNzICg4cHggbWluaW11bSBwYWRkaW5nIG9uIG1vYmlsZSlcclxuICAgICAgICAgICAgY2FyZHMuZm9yRWFjaCgoY2FyZCkgPT4ge1xyXG4gICAgICAgICAgICAgIGV4cGVjdChjYXJkKS50b0hhdmVDbGFzcyhcInAtMlwiKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgKSxcclxuICAgICAgICB7IG51bVJ1bnM6IGdldE51bVJ1bnMoXCJNRURJVU1cIikgfVxyXG4gICAgICApO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaXQoXCJzaG91bGQgaGF2ZSBwcm9ncmVzc2l2ZSBwYWRkaW5nIGNsYXNzZXM6IHAtMiBzbTpwLTMgbWQ6cC00XCIsICgpID0+IHtcclxuICAgICAgZmMuYXNzZXJ0KFxyXG4gICAgICAgIGZjLnByb3BlcnR5KFxyXG4gICAgICAgICAgZmMuaW50ZWdlcih7IG1pbjogMzIwLCBtYXg6IDQ4MCB9KSxcclxuICAgICAgICAgIGZjLmludGVnZXIoeyBtaW46IDAsIG1heDogMTAwMDAwMCB9KSxcclxuICAgICAgICAgIGZjLmludGVnZXIoeyBtaW46IDAsIG1heDogMTAwMDAwMCB9KSxcclxuICAgICAgICAgICh2aWV3cG9ydFdpZHRoLCBpbmNvbWUsIGV4cGVuc2UpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgYmFsYW5jZSA9IGluY29tZSAtIGV4cGVuc2U7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBzZXRWaWV3cG9ydFdpZHRoKHZpZXdwb3J0V2lkdGgpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgY29uc3QgeyBjb250YWluZXIgfSA9IHJlbmRlcihcclxuICAgICAgICAgICAgICA8QmFsYW5jZUNhcmRzXHJcbiAgICAgICAgICAgICAgICB0b3RhbEluY29tZT17aW5jb21lfVxyXG4gICAgICAgICAgICAgICAgdG90YWxFeHBlbnNlPXtleHBlbnNlfVxyXG4gICAgICAgICAgICAgICAgYmFsYW5jZT17YmFsYW5jZX1cclxuICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgY29uc3QgY2FyZHMgPSBjb250YWluZXIucXVlcnlTZWxlY3RvckFsbChcIi5wLTJcIik7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBleHBlY3QoY2FyZHMubGVuZ3RoKS50b0JlR3JlYXRlclRoYW4oMCk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAvLyBWZXJpZnkgcHJvZ3Jlc3NpdmUgcGFkZGluZyBjbGFzc2VzXHJcbiAgICAgICAgICAgIGNhcmRzLmZvckVhY2goKGNhcmQpID0+IHtcclxuICAgICAgICAgICAgICBleHBlY3QoY2FyZCkudG9IYXZlQ2xhc3MoXCJwLTJcIik7XHJcbiAgICAgICAgICAgICAgZXhwZWN0KGNhcmQpLnRvSGF2ZUNsYXNzKFwic206cC0zXCIpO1xyXG4gICAgICAgICAgICAgIGV4cGVjdChjYXJkKS50b0hhdmVDbGFzcyhcIm1kOnAtNFwiKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgKSxcclxuICAgICAgICB7IG51bVJ1bnM6IGdldE51bVJ1bnMoXCJNRURJVU1cIikgfVxyXG4gICAgICApO1xyXG4gICAgfSk7XHJcbiAgfSk7XHJcblxyXG4gIGRlc2NyaWJlKFwiQ29udGFpbmVyIHBhZGRpbmcgYXQgdmlld3BvcnQgYm91bmRhcmllc1wiLCAoKSA9PiB7XHJcbiAgICBpdChcInNob3VsZCBtYWludGFpbiBtaW5pbXVtIHBhZGRpbmcgYXQgbG93ZXIgYm91bmRhcnkgKDMyMHB4KVwiLCAoKSA9PiB7XHJcbiAgICAgIGNvbnN0IHsgY29udGFpbmVyIH0gPSByZW5kZXIoXHJcbiAgICAgICAgPEJhbGFuY2VDYXJkc1xyXG4gICAgICAgICAgdG90YWxJbmNvbWU9ezUwMDAwfVxyXG4gICAgICAgICAgdG90YWxFeHBlbnNlPXszMDAwMH1cclxuICAgICAgICAgIGJhbGFuY2U9ezIwMDAwfVxyXG4gICAgICAgIC8+XHJcbiAgICAgICk7XHJcbiAgICAgIFxyXG4gICAgICBzZXRWaWV3cG9ydFdpZHRoKDMyMCk7XHJcbiAgICAgIFxyXG4gICAgICBjb25zdCBjYXJkcyA9IGNvbnRhaW5lci5xdWVyeVNlbGVjdG9yQWxsKFwiLnAtMlwiKTtcclxuICAgICAgXHJcbiAgICAgIGV4cGVjdChjYXJkcy5sZW5ndGgpLnRvQmVHcmVhdGVyVGhhbigwKTtcclxuICAgICAgXHJcbiAgICAgIGNhcmRzLmZvckVhY2goKGNhcmQpID0+IHtcclxuICAgICAgICBleHBlY3QoY2FyZCkudG9IYXZlQ2xhc3MoXCJwLTJcIik7XHJcbiAgICAgIH0pO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaXQoXCJzaG91bGQgbWFpbnRhaW4gbWluaW11bSBwYWRkaW5nIGF0IHVwcGVyIGJvdW5kYXJ5ICg0ODBweClcIiwgKCkgPT4ge1xyXG4gICAgICBjb25zdCB7IGNvbnRhaW5lciB9ID0gcmVuZGVyKFxyXG4gICAgICAgIDxCYWxhbmNlQ2FyZHNcclxuICAgICAgICAgIHRvdGFsSW5jb21lPXs1MDAwMH1cclxuICAgICAgICAgIHRvdGFsRXhwZW5zZT17MzAwMDB9XHJcbiAgICAgICAgICBiYWxhbmNlPXsyMDAwMH1cclxuICAgICAgICAvPlxyXG4gICAgICApO1xyXG4gICAgICBcclxuICAgICAgc2V0Vmlld3BvcnRXaWR0aCg0ODApO1xyXG4gICAgICBcclxuICAgICAgY29uc3QgY2FyZHMgPSBjb250YWluZXIucXVlcnlTZWxlY3RvckFsbChcIi5wLTJcIik7XHJcbiAgICAgIFxyXG4gICAgICBleHBlY3QoY2FyZHMubGVuZ3RoKS50b0JlR3JlYXRlclRoYW4oMCk7XHJcbiAgICAgIFxyXG4gICAgICBjYXJkcy5mb3JFYWNoKChjYXJkKSA9PiB7XHJcbiAgICAgICAgZXhwZWN0KGNhcmQpLnRvSGF2ZUNsYXNzKFwicC0yXCIpO1xyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG5cclxuICAgIGl0KFwic2hvdWxkIGhhdmUgY29uc2lzdGVudCBwYWRkaW5nIGNsYXNzZXMgYWNyb3NzIGFsbCB0aHJlZSBiYWxhbmNlIGNhcmRzXCIsICgpID0+IHtcclxuICAgICAgZmMuYXNzZXJ0KFxyXG4gICAgICAgIGZjLnByb3BlcnR5KFxyXG4gICAgICAgICAgZmMuaW50ZWdlcih7IG1pbjogMzIwLCBtYXg6IDQ4MCB9KSxcclxuICAgICAgICAgIGZjLmludGVnZXIoeyBtaW46IDAsIG1heDogMTAwMDAwMCB9KSxcclxuICAgICAgICAgIGZjLmludGVnZXIoeyBtaW46IDAsIG1heDogMTAwMDAwMCB9KSxcclxuICAgICAgICAgICh2aWV3cG9ydFdpZHRoLCBpbmNvbWUsIGV4cGVuc2UpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgYmFsYW5jZSA9IGluY29tZSAtIGV4cGVuc2U7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBzZXRWaWV3cG9ydFdpZHRoKHZpZXdwb3J0V2lkdGgpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgY29uc3QgeyBjb250YWluZXIgfSA9IHJlbmRlcihcclxuICAgICAgICAgICAgICA8QmFsYW5jZUNhcmRzXHJcbiAgICAgICAgICAgICAgICB0b3RhbEluY29tZT17aW5jb21lfVxyXG4gICAgICAgICAgICAgICAgdG90YWxFeHBlbnNlPXtleHBlbnNlfVxyXG4gICAgICAgICAgICAgICAgYmFsYW5jZT17YmFsYW5jZX1cclxuICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgY29uc3QgY2FyZHMgPSBjb250YWluZXIucXVlcnlTZWxlY3RvckFsbChcIi5wLTJcIik7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAvLyBTaG91bGQgaGF2ZSBleGFjdGx5IDMgY2FyZHNcclxuICAgICAgICAgICAgZXhwZWN0KGNhcmRzLmxlbmd0aCkudG9CZSgzKTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIC8vIEFsbCB0aHJlZSBjYXJkcyBzaG91bGQgaGF2ZSBpZGVudGljYWwgcGFkZGluZyBjbGFzc2VzXHJcbiAgICAgICAgICAgIGNvbnN0IGZpcnN0Q2FyZENsYXNzZXMgPSBBcnJheS5mcm9tKGNhcmRzWzBdLmNsYXNzTGlzdCkuZmlsdGVyKGNscyA9PiBcclxuICAgICAgICAgICAgICBjbHMuc3RhcnRzV2l0aChcInAtXCIpIHx8IGNscy5pbmNsdWRlcyhcIjpwLVwiKVxyXG4gICAgICAgICAgICApLnNvcnQoKTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGNhcmRzLmZvckVhY2goKGNhcmQpID0+IHtcclxuICAgICAgICAgICAgICBjb25zdCBjYXJkUGFkZGluZ0NsYXNzZXMgPSBBcnJheS5mcm9tKGNhcmQuY2xhc3NMaXN0KS5maWx0ZXIoY2xzID0+IFxyXG4gICAgICAgICAgICAgICAgY2xzLnN0YXJ0c1dpdGgoXCJwLVwiKSB8fCBjbHMuaW5jbHVkZXMoXCI6cC1cIilcclxuICAgICAgICAgICAgICApLnNvcnQoKTtcclxuICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICBleHBlY3QoY2FyZFBhZGRpbmdDbGFzc2VzKS50b0VxdWFsKGZpcnN0Q2FyZENsYXNzZXMpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICApLFxyXG4gICAgICAgIHsgbnVtUnVuczogZ2V0TnVtUnVucyhcIk1FRElVTVwiKSB9XHJcbiAgICAgICk7XHJcbiAgICB9KTtcclxuICB9KTtcclxuXHJcbiAgZGVzY3JpYmUoXCJFZGdlIGNhc2VzXCIsICgpID0+IHtcclxuICAgIGl0KFwic2hvdWxkIG1haW50YWluIHBhZGRpbmcgd2l0aCBlbXB0eSBjdXJyZW5jeSBkYXRhXCIsICgpID0+IHtcclxuICAgICAgZmMuYXNzZXJ0KFxyXG4gICAgICAgIGZjLnByb3BlcnR5KFxyXG4gICAgICAgICAgZmMuaW50ZWdlcih7IG1pbjogMzIwLCBtYXg6IDQ4MCB9KSxcclxuICAgICAgICAgICh2aWV3cG9ydFdpZHRoKSA9PiB7XHJcbiAgICAgICAgICAgIHNldFZpZXdwb3J0V2lkdGgodmlld3BvcnRXaWR0aCk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBjb25zdCB7IGNvbnRhaW5lciB9ID0gcmVuZGVyKFxyXG4gICAgICAgICAgICAgIDxCYWxhbmNlQ2FyZHNcclxuICAgICAgICAgICAgICAgIHRvdGFsSW5jb21lPXswfVxyXG4gICAgICAgICAgICAgICAgdG90YWxFeHBlbnNlPXswfVxyXG4gICAgICAgICAgICAgICAgYmFsYW5jZT17MH1cclxuICAgICAgICAgICAgICAgIGJ5Q3VycmVuY3k9e1tdfVxyXG4gICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBjb25zdCBjYXJkcyA9IGNvbnRhaW5lci5xdWVyeVNlbGVjdG9yQWxsKFwiLnAtMlwiKTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGV4cGVjdChjYXJkcy5sZW5ndGgpLnRvQmVHcmVhdGVyVGhhbigwKTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGNhcmRzLmZvckVhY2goKGNhcmQpID0+IHtcclxuICAgICAgICAgICAgICBleHBlY3QoY2FyZCkudG9IYXZlQ2xhc3MoXCJwLTJcIik7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICksXHJcbiAgICAgICAgeyBudW1SdW5zOiBnZXROdW1SdW5zKFwiTUVESVVNXCIpIH1cclxuICAgICAgKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGl0KFwic2hvdWxkIG1haW50YWluIHBhZGRpbmcgd2l0aCBtdWx0aXBsZSBjdXJyZW5jaWVzXCIsICgpID0+IHtcclxuICAgICAgZmMuYXNzZXJ0KFxyXG4gICAgICAgIGZjLnByb3BlcnR5KFxyXG4gICAgICAgICAgZmMuaW50ZWdlcih7IG1pbjogMzIwLCBtYXg6IDQ4MCB9KSxcclxuICAgICAgICAgICh2aWV3cG9ydFdpZHRoKSA9PiB7XHJcbiAgICAgICAgICAgIHNldFZpZXdwb3J0V2lkdGgodmlld3BvcnRXaWR0aCk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBjb25zdCB7IGNvbnRhaW5lciB9ID0gcmVuZGVyKFxyXG4gICAgICAgICAgICAgIDxCYWxhbmNlQ2FyZHNcclxuICAgICAgICAgICAgICAgIHRvdGFsSW5jb21lPXs1MDAwMH1cclxuICAgICAgICAgICAgICAgIHRvdGFsRXhwZW5zZT17MzAwMDB9XHJcbiAgICAgICAgICAgICAgICBiYWxhbmNlPXsyMDAwMH1cclxuICAgICAgICAgICAgICAgIGJ5Q3VycmVuY3k9e1tcclxuICAgICAgICAgICAgICAgICAgeyBjdXJyZW5jeTogXCJSVUJcIiwgdG90YWxJbmNvbWU6IDMwMDAwLCB0b3RhbEV4cGVuc2U6IDIwMDAwLCBiYWxhbmNlOiAxMDAwMCB9LFxyXG4gICAgICAgICAgICAgICAgICB7IGN1cnJlbmN5OiBcIlVTRFwiLCB0b3RhbEluY29tZTogMjAwMDAsIHRvdGFsRXhwZW5zZTogMTAwMDAsIGJhbGFuY2U6IDEwMDAwIH0sXHJcbiAgICAgICAgICAgICAgICBdfVxyXG4gICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBjb25zdCBjYXJkcyA9IGNvbnRhaW5lci5xdWVyeVNlbGVjdG9yQWxsKFwiLnAtMlwiKTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGV4cGVjdChjYXJkcy5sZW5ndGgpLnRvQmVHcmVhdGVyVGhhbigwKTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGNhcmRzLmZvckVhY2goKGNhcmQpID0+IHtcclxuICAgICAgICAgICAgICBleHBlY3QoY2FyZCkudG9IYXZlQ2xhc3MoXCJwLTJcIik7XHJcbiAgICAgICAgICAgICAgZXhwZWN0KGNhcmQpLnRvSGF2ZUNsYXNzKFwic206cC0zXCIpO1xyXG4gICAgICAgICAgICAgIGV4cGVjdChjYXJkKS50b0hhdmVDbGFzcyhcIm1kOnAtNFwiKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgKSxcclxuICAgICAgICB7IG51bVJ1bnM6IGdldE51bVJ1bnMoXCJNRURJVU1cIikgfVxyXG4gICAgICApO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaXQoXCJzaG91bGQgbWFpbnRhaW4gcGFkZGluZyBpbiBsb2FkaW5nIHN0YXRlXCIsICgpID0+IHtcclxuICAgICAgZmMuYXNzZXJ0KFxyXG4gICAgICAgIGZjLnByb3BlcnR5KFxyXG4gICAgICAgICAgZmMuaW50ZWdlcih7IG1pbjogMzIwLCBtYXg6IDQ4MCB9KSxcclxuICAgICAgICAgICh2aWV3cG9ydFdpZHRoKSA9PiB7XHJcbiAgICAgICAgICAgIHNldFZpZXdwb3J0V2lkdGgodmlld3BvcnRXaWR0aCk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBjb25zdCB7IGNvbnRhaW5lciB9ID0gcmVuZGVyKFxyXG4gICAgICAgICAgICAgIDxCYWxhbmNlQ2FyZHNcclxuICAgICAgICAgICAgICAgIHRvdGFsSW5jb21lPXswfVxyXG4gICAgICAgICAgICAgICAgdG90YWxFeHBlbnNlPXswfVxyXG4gICAgICAgICAgICAgICAgYmFsYW5jZT17MH1cclxuICAgICAgICAgICAgICAgIGxvYWRpbmc9e3RydWV9XHJcbiAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIC8vIEluIGxvYWRpbmcgc3RhdGUsIENhcmRDb250ZW50IGhhcyBwYWRkaW5nIGNsYXNzZXNcclxuICAgICAgICAgICAgY29uc3QgY2FyZENvbnRlbnRzID0gY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3JBbGwoXCIucC00LCAuc21cXFxcOnAtNiwgLm1kXFxcXDpwLThcIik7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBleHBlY3QoY2FyZENvbnRlbnRzLmxlbmd0aCkudG9CZUdyZWF0ZXJUaGFuKDApO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgLy8gVmVyaWZ5IGF0IGxlYXN0IHNvbWUgZWxlbWVudHMgaGF2ZSBwYWRkaW5nXHJcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnRzV2l0aFBhZGRpbmcgPSBjb250YWluZXIucXVlcnlTZWxlY3RvckFsbChcIi5wLTRcIik7XHJcbiAgICAgICAgICAgIGV4cGVjdChlbGVtZW50c1dpdGhQYWRkaW5nLmxlbmd0aCkudG9CZUdyZWF0ZXJUaGFuKDApO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICksXHJcbiAgICAgICAgeyBudW1SdW5zOiBnZXROdW1SdW5zKFwiTUVESVVNXCIpIH1cclxuICAgICAgKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGl0KFwic2hvdWxkIGVuc3VyZSBtaW5pbXVtIHBhZGRpbmcgaXMgbmV2ZXIgbGVzcyB0aGFuIDhweFwiLCAoKSA9PiB7XHJcbiAgICAgIGZjLmFzc2VydChcclxuICAgICAgICBmYy5wcm9wZXJ0eShcclxuICAgICAgICAgIGZjLmludGVnZXIoeyBtaW46IDMyMCwgbWF4OiA0ODAgfSksXHJcbiAgICAgICAgICBmYy5pbnRlZ2VyKHsgbWluOiAwLCBtYXg6IDEwMDAwMDAgfSksXHJcbiAgICAgICAgICBmYy5pbnRlZ2VyKHsgbWluOiAwLCBtYXg6IDEwMDAwMDAgfSksXHJcbiAgICAgICAgICAodmlld3BvcnRXaWR0aCwgaW5jb21lLCBleHBlbnNlKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGJhbGFuY2UgPSBpbmNvbWUgLSBleHBlbnNlO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgc2V0Vmlld3BvcnRXaWR0aCh2aWV3cG9ydFdpZHRoKTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGNvbnN0IHsgY29udGFpbmVyIH0gPSByZW5kZXIoXHJcbiAgICAgICAgICAgICAgPEJhbGFuY2VDYXJkc1xyXG4gICAgICAgICAgICAgICAgdG90YWxJbmNvbWU9e2luY29tZX1cclxuICAgICAgICAgICAgICAgIHRvdGFsRXhwZW5zZT17ZXhwZW5zZX1cclxuICAgICAgICAgICAgICAgIGJhbGFuY2U9e2JhbGFuY2V9XHJcbiAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGNvbnN0IGNhcmRzID0gY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3JBbGwoXCIucC0yXCIpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgLy8gVmVyaWZ5IHRoYXQgcC0yIGNsYXNzIGlzIHByZXNlbnQgKHdoaWNoIGVxdWFscyA4cHggaW4gVGFpbHdpbmQpXHJcbiAgICAgICAgICAgIC8vIFRoaXMgZW5zdXJlcyBtaW5pbXVtIHBhZGRpbmcgaXMgYXQgbGVhc3QgOHB4XHJcbiAgICAgICAgICAgIGNhcmRzLmZvckVhY2goKGNhcmQpID0+IHtcclxuICAgICAgICAgICAgICBleHBlY3QoY2FyZCkudG9IYXZlQ2xhc3MoXCJwLTJcIik7XHJcbiAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgLy8gcC0yIGluIFRhaWx3aW5kID0gMC41cmVtID0gOHB4IChhdCBkZWZhdWx0IGZvbnQgc2l6ZSlcclxuICAgICAgICAgICAgICAvLyBUaGlzIGlzIHRoZSBtaW5pbXVtIHJlcXVpcmVkIHBhZGRpbmdcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgKSxcclxuICAgICAgICB7IG51bVJ1bnM6IGdldE51bVJ1bnMoXCJNRURJVU1cIikgfVxyXG4gICAgICApO1xyXG4gICAgfSk7XHJcbiAgfSk7XHJcblxyXG4gIGRlc2NyaWJlKFwiVmlld3BvcnQgd2lkdGggdmFyaWF0aW9uc1wiLCAoKSA9PiB7XHJcbiAgICBpdChcInNob3VsZCBtYWludGFpbiBtaW5pbXVtIHBhZGRpbmcgYWNyb3NzIGVudGlyZSBtb2JpbGUgcmFuZ2VcIiwgKCkgPT4ge1xyXG4gICAgICBjb25zdCB0ZXN0Vmlld3BvcnRzID0gWzMyMCwgMzYwLCAzNzUsIDM5MCwgNDE0LCA0MjgsIDQ4MF07XHJcbiAgICAgIFxyXG4gICAgICB0ZXN0Vmlld3BvcnRzLmZvckVhY2goKHZpZXdwb3J0V2lkdGgpID0+IHtcclxuICAgICAgICBzZXRWaWV3cG9ydFdpZHRoKHZpZXdwb3J0V2lkdGgpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGNvbnN0IHsgY29udGFpbmVyIH0gPSByZW5kZXIoXHJcbiAgICAgICAgICA8QmFsYW5jZUNhcmRzXHJcbiAgICAgICAgICAgIHRvdGFsSW5jb21lPXs1MDAwMH1cclxuICAgICAgICAgICAgdG90YWxFeHBlbnNlPXszMDAwMH1cclxuICAgICAgICAgICAgYmFsYW5jZT17MjAwMDB9XHJcbiAgICAgICAgICAvPlxyXG4gICAgICAgICk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgY29uc3QgY2FyZHMgPSBjb250YWluZXIucXVlcnlTZWxlY3RvckFsbChcIi5wLTJcIik7XHJcbiAgICAgICAgXHJcbiAgICAgICAgZXhwZWN0KGNhcmRzLmxlbmd0aCkudG9CZUdyZWF0ZXJUaGFuKDApO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGNhcmRzLmZvckVhY2goKGNhcmQpID0+IHtcclxuICAgICAgICAgIGV4cGVjdChjYXJkKS50b0hhdmVDbGFzcyhcInAtMlwiKTtcclxuICAgICAgICB9KTtcclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuICB9KTtcclxufSk7XHJcbiJdLCJuYW1lcyI6WyJnZXRQYWRkaW5nVmFsdWVzIiwiZWxlbWVudCIsImNvbXB1dGVkU3R5bGUiLCJ3aW5kb3ciLCJnZXRDb21wdXRlZFN0eWxlIiwicGFkZGluZ0xlZnQiLCJwYXJzZUZsb2F0IiwicGFkZGluZ1JpZ2h0IiwicGFkZGluZ1RvcCIsInBhZGRpbmdCb3R0b20iLCJoYXNNaW5pbXVtUGFkZGluZ0NsYXNzZXMiLCJjbGFzc0xpc3QiLCJBcnJheSIsImZyb20iLCJoYXNQYWRkaW5nMiIsInNvbWUiLCJjbHMiLCJoYXNSZXNwb25zaXZlUGFkZGluZyIsInRlc3QiLCJzZXRWaWV3cG9ydFdpZHRoIiwid2lkdGgiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsIndyaXRhYmxlIiwiY29uZmlndXJhYmxlIiwidmFsdWUiLCJkaXNwYXRjaEV2ZW50IiwiRXZlbnQiLCJkZXNjcmliZSIsIml0IiwiZmMiLCJhc3NlcnQiLCJwcm9wZXJ0eSIsImludGVnZXIiLCJtaW4iLCJtYXgiLCJ2aWV3cG9ydFdpZHRoIiwiaW5jb21lIiwiZXhwZW5zZSIsImJhbGFuY2UiLCJjb250YWluZXIiLCJyZW5kZXIiLCJCYWxhbmNlQ2FyZHMiLCJ0b3RhbEluY29tZSIsInRvdGFsRXhwZW5zZSIsImNhcmRzIiwicXVlcnlTZWxlY3RvckFsbCIsImV4cGVjdCIsImxlbmd0aCIsInRvQmVHcmVhdGVyVGhhbiIsImZvckVhY2giLCJjYXJkIiwidG9IYXZlQ2xhc3MiLCJ0b0JlIiwibnVtUnVucyIsImdldE51bVJ1bnMiLCJmaXJzdENhcmRDbGFzc2VzIiwiZmlsdGVyIiwic3RhcnRzV2l0aCIsImluY2x1ZGVzIiwic29ydCIsImNhcmRQYWRkaW5nQ2xhc3NlcyIsInRvRXF1YWwiLCJieUN1cnJlbmN5IiwiY3VycmVuY3kiLCJsb2FkaW5nIiwiY2FyZENvbnRlbnRzIiwiZWxlbWVudHNXaXRoUGFkZGluZyIsInRlc3RWaWV3cG9ydHMiXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7OztDQVFDOzs7Ozs4REFFaUI7d0JBQ0s7a0VBQ1I7OEJBQ2M7b0NBQ1U7Ozs7OztBQUV2QywwREFBMEQ7QUFDMUQsTUFBTUEsbUJBQW1CLENBQUNDO0lBTXhCLE1BQU1DLGdCQUFnQkMsT0FBT0MsZ0JBQWdCLENBQUNIO0lBRTlDLE9BQU87UUFDTEksYUFBYUMsV0FBV0osY0FBY0csV0FBVyxLQUFLO1FBQ3RERSxjQUFjRCxXQUFXSixjQUFjSyxZQUFZLEtBQUs7UUFDeERDLFlBQVlGLFdBQVdKLGNBQWNNLFVBQVUsS0FBSztRQUNwREMsZUFBZUgsV0FBV0osY0FBY08sYUFBYSxLQUFLO0lBQzVEO0FBQ0Y7QUFFQSxrRUFBa0U7QUFDbEUsTUFBTUMsMkJBQTJCLENBQUNUO0lBQ2hDLE1BQU1VLFlBQVlDLE1BQU1DLElBQUksQ0FBQ1osUUFBUVUsU0FBUztJQUU5QyxrRkFBa0Y7SUFDbEYsTUFBTUcsY0FBY0gsVUFBVUksSUFBSSxDQUFDQyxDQUFBQSxNQUNqQ0EsUUFBUSxTQUFTQSxRQUFRLFVBQVVBLFFBQVEsVUFBVUEsUUFBUTtJQUcvRCw4REFBOEQ7SUFDOUQsTUFBTUMsdUJBQXVCTixVQUFVSSxJQUFJLENBQUNDLENBQUFBLE1BQzFDLGtDQUFrQ0UsSUFBSSxDQUFDRjtJQUd6QyxPQUFPRixlQUFlRztBQUN4QjtBQUVBLDhDQUE4QztBQUM5QyxNQUFNRSxtQkFBbUIsQ0FBQ0M7SUFDeEJDLE9BQU9DLGNBQWMsQ0FBQ25CLFFBQVEs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