2f51f3997176e9333e87be1af465c4db
/**
 * Property-Based Test — Modal Window Width
 * 
 * **Свойство 10: Ширина модальных окон**
 * **Валидирует: Требования 4.1**
 * 
 * For any modal window, when viewport width is less than 640px,
 * the modal width should be 95% of viewport width.
 * On desktop (>= 640px), modal should use max-w-{size} classes.
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _jsxruntime = require("react/jsx-runtime");
const _react = /*#__PURE__*/ _interop_require_default(require("react"));
const _react1 = require("@testing-library/react");
const _fastcheck = /*#__PURE__*/ _interop_require_default(require("fast-check"));
const _Modal = require("../../src/components/ui/Modal");
const _propertytestconfig = require("./property-test-config");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
// Mobile breakpoint (sm in Tailwind)
const MOBILE_BREAKPOINT = 640;
// Expected mobile width percentage
const MOBILE_WIDTH_PERCENTAGE = 95;
// Helper function to get computed width of an element
const getElementWidth = (element)=>{
    const rect = element.getBoundingClientRect();
    return rect.width;
};
// Helper function to find modal content containers
const findModalContent = (container)=>{
    // Modal content is rendered in a Dialog component
    // Look for elements with the responsive width classes
    const selectors = [
        "[class*='w-[95%]']",
        "[role='dialog']",
        ".max-w-md",
        ".max-w-lg",
        ".max-w-2xl",
        ".max-w-4xl"
    ];
    for (const selector of selectors){
        const element = container.querySelector(selector);
        if (element) return element;
    }
    return null;
};
describe("Property: Modal Window Width", ()=>{
    describe("Modal width on mobile viewports", ()=>{
        it("should have 95% width on mobile viewports (< 640px)", ()=>{
            jest.setTimeout((0, _propertytestconfig.getTimeout)("SLOW"));
            _fastcheck.default.assert(_fastcheck.default.property(_fastcheck.default.integer({
                min: 320,
                max: 639
            }), _fastcheck.default.constantFrom("sm", "md", "lg", "xl"), _fastcheck.default.string({
                minLength: 5,
                maxLength: 100
            }), (viewportWidth, size, content)=>{
                // Mock window.innerWidth for mobile
                Object.defineProperty(window, "innerWidth", {
                    writable: true,
                    configurable: true,
                    value: viewportWidth
                });
                // Mock matchMedia for Tailwind's sm breakpoint (640px)
                Object.defineProperty(window, "matchMedia", {
                    writable: true,
                    value: jest.fn().mockImplementation((query)=>({
                            matches: query.includes("640px") ? false : true,
                            media: query,
                            onchange: null,
                            addListener: jest.fn(),
                            removeListener: jest.fn(),
                            addEventListener: jest.fn(),
                            removeEventListener: jest.fn(),
                            dispatchEvent: jest.fn()
                        }))
                });
                const { container } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_Modal.Modal, {
                    isOpen: true,
                    onClose: ()=>{},
                    size: size,
                    children: /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                        children: content
                    })
                }));
                // Find modal content
                const modalContent = findModalContent(container);
                if (modalContent) {
                    // Verify the modal has w-[95%] class
                    expect(modalContent.className).toMatch(/w-\[95%\]/);
                }
            }), {
                numRuns: (0, _propertytestconfig.getNumRuns)("MEDIUM")
            });
        });
        it("should verify all modal sizes use 95% width on mobile", ()=>{
            jest.setTimeout((0, _propertytestconfig.getTimeout)("SLOW"));
            const sizes = [
                "sm",
                "md",
                "lg",
                "xl"
            ];
            _fastcheck.default.assert(_fastcheck.default.property(_fastcheck.default.integer({
                min: 320,
                max: 639
            }), _fastcheck.default.constantFrom(...sizes), (viewportWidth, size)=>{
                Object.defineProperty(window, "innerWidth", {
                    writable: true,
                    configurable: true,
                    value: viewportWidth
                });
                Object.defineProperty(window, "matchMedia", {
                    writable: true,
                    value: jest.fn().mockImplementation((query)=>({
                            matches: query.includes("640px") ? false : true,
                            media: query,
                            onchange: null,
                            addListener: jest.fn(),
                            removeListener: jest.fn(),
                            addEventListener: jest.fn(),
                            removeEventListener: jest.fn(),
                            dispatchEvent: jest.fn()
                        }))
                });
                const { container } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_Modal.Modal, {
                    isOpen: true,
                    onClose: ()=>{},
                    size: size,
                    children: /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                        children: "Test content"
                    })
                }));
                const modalContent = findModalContent(container);
                if (modalContent) {
                    // All sizes should have w-[95%] on mobile
                    expect(modalContent.className).toMatch(/w-\[95%\]/);
                }
            }), {
                numRuns: (0, _propertytestconfig.getNumRuns)("MEDIUM")
            });
        });
        it("should maintain 95% width at exactly 320px (minimum supported width)", ()=>{
            jest.setTimeout((0, _propertytestconfig.getTimeout)("SLOW"));
            const viewportWidth = 320;
            Object.defineProperty(window, "innerWidth", {
                writable: true,
                configurable: true,
                value: viewportWidth
            });
            _fastcheck.default.assert(_fastcheck.default.property(_fastcheck.default.constantFrom("sm", "md", "lg", "xl"), (size)=>{
                const { container } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_Modal.Modal, {
                    isOpen: true,
                    onClose: ()=>{},
                    size: size,
                    children: /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                        children: "Test content"
                    })
                }));
                const modalContent = findModalContent(container);
                if (modalContent) {
                    expect(modalContent.className).toMatch(/w-\[95%\]/);
                }
            }), {
                numRuns: (0, _propertytestconfig.getNumRuns)("FAST")
            });
        });
        it("should maintain 95% width at 639px (just below sm breakpoint)", ()=>{
            jest.setTimeout((0, _propertytestconfig.getTimeout)("SLOW"));
            const viewportWidth = 639;
            Object.defineProperty(window, "innerWidth", {
                writable: true,
                configurable: true,
                value: viewportWidth
            });
            _fastcheck.default.assert(_fastcheck.default.property(_fastcheck.default.constantFrom("sm", "md", "lg", "xl"), (size)=>{
                const { container } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_Modal.Modal, {
                    isOpen: true,
                    onClose: ()=>{},
                    size: size,
                    children: /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                        children: "Test content"
                    })
                }));
                const modalContent = findModalContent(container);
                if (modalContent) {
                    expect(modalContent.className).toMatch(/w-\[95%\]/);
                }
            }), {
                numRuns: (0, _propertytestconfig.getNumRuns)("FAST")
            });
        });
    });
    describe("Modal width on desktop viewports", ()=>{
        it("should use max-w-{size} classes on desktop viewports (>= 640px)", ()=>{
            jest.setTimeout((0, _propertytestconfig.getTimeout)("SLOW"));
            _fastcheck.default.assert(_fastcheck.default.property(_fastcheck.default.integer({
                min: 640,
                max: 1440
            }), _fastcheck.default.constantFrom("sm", "md", "lg", "xl"), (viewportWidth, size)=>{
                Object.defineProperty(window, "innerWidth", {
                    writable: true,
                    configurable: true,
                    value: viewportWidth
                });
                Object.defineProperty(window, "matchMedia", {
                    writable: true,
                    value: jest.fn().mockImplementation((query)=>({
                            matches: query.includes("640px") ? true : false,
                            media: query,
                            onchange: null,
                            addListener: jest.fn(),
                            removeListener: jest.fn(),
                            addEventListener: jest.fn(),
                            removeEventListener: jest.fn(),
                            dispatchEvent: jest.fn()
                        }))
                });
                const { container } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_Modal.Modal, {
                    isOpen: true,
                    onClose: ()=>{},
                    size: size,
                    children: /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                        children: "Test content"
                    })
                }));
                const modalContent = findModalContent(container);
                if (modalContent) {
                    // Should still have w-[95%] base class
                    expect(modalContent.className).toMatch(/w-\[95%\]/);
                    // Should also have sm:max-w-{size} responsive class
                    const expectedMaxWidth = {
                        sm: "sm:max-w-md",
                        md: "sm:max-w-lg",
                        lg: "sm:max-w-2xl",
                        xl: "sm:max-w-4xl"
                    }[size];
                    expect(modalContent.className).toMatch(new RegExp(expectedMaxWidth.replace(/:/g, "\\:")));
                }
            }), {
                numRuns: (0, _propertytestconfig.getNumRuns)("MEDIUM")
            });
        });
        it("should verify each modal size has correct max-width class", ()=>{
            jest.setTimeout((0, _propertytestconfig.getTimeout)("SLOW"));
            const sizeToMaxWidth = {
                sm: "sm:max-w-md",
                md: "sm:max-w-lg",
                lg: "sm:max-w-2xl",
                xl: "sm:max-w-4xl"
            };
            Object.defineProperty(window, "innerWidth", {
                writable: true,
                configurable: true,
                value: 1024
            });
            Object.keys(sizeToMaxWidth).forEach((size)=>{
                const { container } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_Modal.Modal, {
                    isOpen: true,
                    onClose: ()=>{},
                    size: size,
                    children: /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                        children: "Test content"
                    })
                }));
                const modalContent = findModalContent(container);
                if (modalContent) {
                    const expectedClass = sizeToMaxWidth[size];
                    expect(modalContent.className).toMatch(new RegExp(expectedClass.replace(/:/g, "\\:")));
                }
            });
        });
        it("should switch to max-width at exactly 640px (sm breakpoint)", ()=>{
            jest.setTimeout((0, _propertytestconfig.getTimeout)("SLOW"));
            const viewportWidth = 640;
            Object.defineProperty(window, "innerWidth", {
                writable: true,
                configurable: true,
                value: viewportWidth
            });
            _fastcheck.default.assert(_fastcheck.default.property(_fastcheck.default.constantFrom("sm", "md", "lg", "xl"), (size)=>{
                const { container } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_Modal.Modal, {
                    isOpen: true,
                    onClose: ()=>{},
                    size: size,
                    children: /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                        children: "Test content"
                    })
                }));
                const modalContent = findModalContent(container);
                if (modalContent) {
                    // Should have both w-[95%] and sm:max-w-{size}
                    expect(modalContent.className).toMatch(/w-\[95%\]/);
                    const expectedMaxWidth = {
                        sm: "sm:max-w-md",
                        md: "sm:max-w-lg",
                        lg: "sm:max-w-2xl",
                        xl: "sm:max-w-4xl"
                    }[size];
                    expect(modalContent.className).toMatch(new RegExp(expectedMaxWidth.replace(/:/g, "\\:")));
                }
            }), {
                numRuns: (0, _propertytestconfig.getNumRuns)("FAST")
            });
        });
    });
    describe("Modal size variants", ()=>{
        it("should verify sm modal has max-w-md on desktop", ()=>{
            jest.setTimeout((0, _propertytestconfig.getTimeout)("SLOW"));
            _fastcheck.default.assert(_fastcheck.default.property(_fastcheck.default.integer({
                min: 640,
                max: 1440
            }), (viewportWidth)=>{
                Object.defineProperty(window, "innerWidth", {
                    writable: true,
                    configurable: true,
                    value: viewportWidth
                });
                const { container } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_Modal.Modal, {
                    isOpen: true,
                    onClose: ()=>{},
                    size: "sm",
                    children: /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                        children: "Small modal"
                    })
                }));
                const modalContent = findModalContent(container);
                if (modalContent) {
                    expect(modalContent.className).toMatch(/sm:max-w-md/);
                }
            }), {
                numRuns: (0, _propertytestconfig.getNumRuns)("FAST")
            });
        });
        it("should verify md modal has max-w-lg on desktop", ()=>{
            jest.setTimeout((0, _propertytestconfig.getTimeout)("SLOW"));
            _fastcheck.default.assert(_fastcheck.default.property(_fastcheck.default.integer({
                min: 640,
                max: 1440
            }), (viewportWidth)=>{
                Object.defineProperty(window, "innerWidth", {
                    writable: true,
                    configurable: true,
                    value: viewportWidth
                });
                const { container } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_Modal.Modal, {
                    isOpen: true,
                    onClose: ()=>{},
                    size: "md",
                    children: /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                        children: "Medium modal"
                    })
                }));
                const modalContent = findModalContent(container);
                if (modalContent) {
                    expect(modalContent.className).toMatch(/sm:max-w-lg/);
                }
            }), {
                numRuns: (0, _propertytestconfig.getNumRuns)("FAST")
            });
        });
        it("should verify lg modal has max-w-2xl on desktop", ()=>{
            jest.setTimeout((0, _propertytestconfig.getTimeout)("SLOW"));
            _fastcheck.default.assert(_fastcheck.default.property(_fastcheck.default.integer({
                min: 640,
                max: 1440
            }), (viewportWidth)=>{
                Object.defineProperty(window, "innerWidth", {
                    writable: true,
                    configurable: true,
                    value: viewportWidth
                });
                const { container } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_Modal.Modal, {
                    isOpen: true,
                    onClose: ()=>{},
                    size: "lg",
                    children: /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                        children: "Large modal"
                    })
                }));
                const modalContent = findModalContent(container);
                if (modalContent) {
                    expect(modalContent.className).toMatch(/sm:max-w-2xl/);
                }
            }), {
                numRuns: (0, _propertytestconfig.getNumRuns)("FAST")
            });
        });
        it("should verify xl modal has max-w-4xl on desktop", ()=>{
            jest.setTimeout((0, _propertytestconfig.getTimeout)("SLOW"));
            _fastcheck.default.assert(_fastcheck.default.property(_fastcheck.default.integer({
                min: 640,
                max: 1440
            }), (viewportWidth)=>{
                Object.defineProperty(window, "innerWidth", {
                    writable: true,
                    configurable: true,
                    value: viewportWidth
                });
                const { container } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_Modal.Modal, {
                    isOpen: true,
                    onClose: ()=>{},
                    size: "xl",
                    children: /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                        children: "Extra large modal"
                    })
                }));
                const modalContent = findModalContent(container);
                if (modalContent) {
                    expect(modalContent.className).toMatch(/sm:max-w-4xl/);
                }
            }), {
                numRuns: (0, _propertytestconfig.getNumRuns)("FAST")
            });
        });
    });
    describe("Edge cases", ()=>{
        it("should handle modal with very long content", ()=>{
            jest.setTimeout((0, _propertytestconfig.getTimeout)("SLOW"));
            _fastcheck.default.assert(_fastcheck.default.property(_fastcheck.default.integer({
                min: 320,
                max: 639
            }), _fastcheck.default.string({
                minLength: 500,
                maxLength: 2000
            }), (viewportWidth, longContent)=>{
                Object.defineProperty(window, "innerWidth", {
                    writable: true,
                    configurable: true,
                    value: viewportWidth
                });
                const { container } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_Modal.Modal, {
                    isOpen: true,
                    onClose: ()=>{},
                    size: "md",
                    children: /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                        children: longContent
                    })
                }));
                const modalContent = findModalContent(container);
                if (modalContent) {
                    // Width should still be 95% on mobile regardless of content length
                    expect(modalContent.className).toMatch(/w-\[95%\]/);
                }
            }), {
                numRuns: (0, _propertytestconfig.getNumRuns)("SLOW")
            });
        });
        it("should handle modal with minimal content", ()=>{
            jest.setTimeout((0, _propertytestconfig.getTimeout)("SLOW"));
            _fastcheck.default.assert(_fastcheck.default.property(_fastcheck.default.integer({
                min: 320,
                max: 1440
            }), _fastcheck.default.constantFrom("sm", "md", "lg", "xl"), (viewportWidth, size)=>{
                Object.defineProperty(window, "innerWidth", {
                    writable: true,
                    configurable: true,
                    value: viewportWidth
                });
                const { container } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_Modal.Modal, {
                    isOpen: true,
                    onClose: ()=>{},
                    size: size,
                    children: /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                        children: "X"
                    })
                }));
                const modalContent = findModalContent(container);
                if (modalContent) {
                    // Width classes should be present regardless of content
                    expect(modalContent.className).toMatch(/w-\[95%\]/);
                }
            }), {
                numRuns: (0, _propertytestconfig.getNumRuns)("SLOW")
            });
        });
        it("should handle modal with nested elements", ()=>{
            jest.setTimeout((0, _propertytestconfig.getTimeout)("SLOW"));
            _fastcheck.default.assert(_fastcheck.default.property(_fastcheck.default.integer({
                min: 320,
                max: 639
            }), _fastcheck.default.array(_fastcheck.default.string({
                minLength: 5,
                maxLength: 50
            }), {
                minLength: 1,
                maxLength: 10
            }), (viewportWidth, items)=>{
                Object.defineProperty(window, "innerWidth", {
                    writable: true,
                    configurable: true,
                    value: viewportWidth
                });
                const { container } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_Modal.Modal, {
                    isOpen: true,
                    onClose: ()=>{},
                    size: "md",
                    children: /*#__PURE__*/ (0, _jsxruntime.jsxs)("div", {
                        children: [
                            /*#__PURE__*/ (0, _jsxruntime.jsx)("h2", {
                                children: "Title"
                            }),
                            /*#__PURE__*/ (0, _jsxruntime.jsx)("ul", {
                                children: items.map((item, index)=>/*#__PURE__*/ (0, _jsxruntime.jsx)("li", {
                                        children: item
                                    }, index))
                            })
                        ]
                    })
                }));
                const modalContent = findModalContent(container);
                if (modalContent) {
                    expect(modalContent.className).toMatch(/w-\[95%\]/);
                }
            }), {
                numRuns: (0, _propertytestconfig.getNumRuns)("SLOW")
            });
        });
        it("should handle modal with title", ()=>{
            jest.setTimeout((0, _propertytestconfig.getTimeout)("SLOW"));
            _fastcheck.default.assert(_fastcheck.default.property(_fastcheck.default.integer({
                min: 320,
                max: 639
            }), _fastcheck.default.string({
                minLength: 5,
                maxLength: 100
            }), _fastcheck.default.constantFrom("sm", "md", "lg", "xl"), (viewportWidth, title, size)=>{
                Object.defineProperty(window, "innerWidth", {
                    writable: true,
                    configurable: true,
                    value: viewportWidth
                });
                const { container } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_Modal.Modal, {
                    isOpen: true,
                    onClose: ()=>{},
                    title: title,
                    size: size,
                    children: /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                        children: "Content"
                    })
                }));
                const modalContent = findModalContent(container);
                if (modalContent) {
                    expect(modalContent.className).toMatch(/w-\[95%\]/);
                }
            }), {
                numRuns: (0, _propertytestconfig.getNumRuns)("SLOW")
            });
        });
        it("should handle modal without title", ()=>{
            jest.setTimeout((0, _propertytestconfig.getTimeout)("SLOW"));
            _fastcheck.default.assert(_fastcheck.default.property(_fastcheck.default.integer({
                min: 320,
                max: 639
            }), _fastcheck.default.constantFrom("sm", "md", "lg", "xl"), (viewportWidth, size)=>{
                Object.defineProperty(window, "innerWidth", {
                    writable: true,
                    configurable: true,
                    value: viewportWidth
                });
                const { container } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_Modal.Modal, {
                    isOpen: true,
                    onClose: ()=>{},
                    size: size,
                    children: /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                        children: "Content without title"
                    })
                }));
                const modalContent = findModalContent(container);
                if (modalContent) {
                    expect(modalContent.className).toMatch(/w-\[95%\]/);
                }
            }), {
                numRuns: (0, _propertytestconfig.getNumRuns)("SLOW")
            });
        });
    });
    describe("Requirement validation", ()=>{
        it("validates Requirement 4.1: Modal occupies 95% width on mobile (< 640px)", ()=>{
            jest.setTimeout((0, _propertytestconfig.getTimeout)("SLOW"));
            _fastcheck.default.assert(_fastcheck.default.property(_fastcheck.default.integer({
                min: 320,
                max: 639
            }), _fastcheck.default.constantFrom("sm", "md", "lg", "xl"), (viewportWidth, size)=>{
                Object.defineProperty(window, "innerWidth", {
                    writable: true,
                    configurable: true,
                    value: viewportWidth
                });
                Object.defineProperty(window, "matchMedia", {
                    writable: true,
                    value: jest.fn().mockImplementation((query)=>({
                            matches: query.includes("640px") ? false : true,
                            media: query,
                            onchange: null,
                            addListener: jest.fn(),
                            removeListener: jest.fn(),
                            addEventListener: jest.fn(),
                            removeEventListener: jest.fn(),
                            dispatchEvent: jest.fn()
                        }))
                });
                // Requirement 4.1: WHEN viewport имеет ширину менее 640px,
                // THE Модальное_Окно SHALL занимать 95% ширины экрана с отступами по 2.5%
                const { container } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_Modal.Modal, {
                    isOpen: true,
                    onClose: ()=>{},
                    size: size,
                    children: /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                        children: "Test content"
                    })
                }));
                const modalContent = findModalContent(container);
                if (modalContent) {
                    // Modal should have w-[95%] class which ensures 95% width
                    // with 2.5% margins on each side (100% - 95% = 5% / 2 = 2.5% per side)
                    expect(modalContent.className).toMatch(/w-\[95%\]/);
                }
            }), {
                numRuns: (0, _propertytestconfig.getNumRuns)("MEDIUM")
            });
        });
        it("validates that modal width is consistent across all sizes on mobile", ()=>{
            jest.setTimeout((0, _propertytestconfig.getTimeout)("SLOW"));
            const sizes = [
                "sm",
                "md",
                "lg",
                "xl"
            ];
            _fastcheck.default.assert(_fastcheck.default.property(_fastcheck.default.integer({
                min: 320,
                max: 639
            }), (viewportWidth)=>{
                Object.defineProperty(window, "innerWidth", {
                    writable: true,
                    configurable: true,
                    value: viewportWidth
                });
                // All modal sizes should have the same width on mobile (95%)
                sizes.forEach((size)=>{
                    const { container } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_Modal.Modal, {
                        isOpen: true,
                        onClose: ()=>{},
                        size: size,
                        children: /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                            children: "Test"
                        })
                    }));
                    const modalContent = findModalContent(container);
                    if (modalContent) {
                        expect(modalContent.className).toMatch(/w-\[95%\]/);
                    }
                });
            }), {
                numRuns: (0, _propertytestconfig.getNumRuns)("FAST")
            });
        });
        it("validates that modal uses max-width constraints on desktop", ()=>{
            jest.setTimeout((0, _propertytestconfig.getTimeout)("SLOW"));
            _fastcheck.default.assert(_fastcheck.default.property(_fastcheck.default.integer({
                min: 640,
                max: 1440
            }), _fastcheck.default.constantFrom("sm", "md", "lg", "xl"), (viewportWidth, size)=>{
                Object.defineProperty(window, "innerWidth", {
                    writable: true,
                    configurable: true,
                    value: viewportWidth
                });
                const { container } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_Modal.Modal, {
                    isOpen: true,
                    onClose: ()=>{},
                    size: size,
                    children: /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                        children: "Test content"
                    })
                }));
                const modalContent = findModalContent(container);
                if (modalContent) {
                    // On desktop, modal should have both base width and max-width
                    expect(modalContent.className).toMatch(/w-\[95%\]/);
                    // Should also have responsive max-width class
                    const hasMaxWidth = modalContent.className.includes("sm:max-w-md") || modalContent.className.includes("sm:max-w-lg") || modalContent.className.includes("sm:max-w-2xl") || modalContent.className.includes("sm:max-w-4xl");
                    expect(hasMaxWidth).toBe(true);
                }
            }), {
                numRuns: (0, _propertytestconfig.getNumRuns)("MEDIUM")
            });
        });
    });
    describe("General property validation", ()=>{
        it("should verify modal width adapts correctly across all viewport sizes", ()=>{
            jest.setTimeout((0, _propertytestconfig.getTimeout)("SLOW"));
            _fastcheck.default.assert(_fastcheck.default.property(_fastcheck.default.integer({
                min: 320,
                max: 1440
            }), _fastcheck.default.constantFrom("sm", "md", "lg", "xl"), (viewportWidth, size)=>{
                Object.defineProperty(window, "innerWidth", {
                    writable: true,
                    configurable: true,
                    value: viewportWidth
                });
                const { container } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_Modal.Modal, {
                    isOpen: true,
                    onClose: ()=>{},
                    size: size,
                    children: /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                        children: "Test content"
                    })
                }));
                const modalContent = findModalContent(container);
                if (modalContent) {
                    // All modals should have base w-[95%] class
                    expect(modalContent.className).toMatch(/w-\[95%\]/);
                    // All modals should have responsive max-width class
                    const hasResponsiveClass = modalContent.className.includes("sm:max-w-");
                    expect(hasResponsiveClass).toBe(true);
                }
            }), {
                numRuns: (0, _propertytestconfig.getNumRuns)("MEDIUM")
            });
        });
        it("should ensure modal follows mobile-first responsive design", ()=>{
            jest.setTimeout((0, _propertytestconfig.getTimeout)("SLOW"));
            _fastcheck.default.assert(_fastcheck.default.property(_fastcheck.default.constantFrom("sm", "md", "lg", "xl"), (size)=>{
                const { container } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_Modal.Modal, {
                    isOpen: true,
                    onClose: ()=>{},
                    size: size,
                    children: /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                        children: "Test content"
                    })
                }));
                const modalContent = findModalContent(container);
                if (modalContent) {
                    const classes = modalContent.className;
                    // Mobile-first: base class (w-[95%]) should always be present
                    expect(classes).toMatch(/w-\[95%\]/);
                    // Responsive classes should be prefixed with sm:
                    expect(classes).toMatch(/sm:max-w-/);
                }
            }), {
                numRuns: (0, _propertytestconfig.getNumRuns)("FAST")
            });
        });
        it("should verify modal width classes are applied consistently", ()=>{
            jest.setTimeout((0, _propertytestconfig.getTimeout)("SLOW"));
            const testCases = [
                {
                    viewport: 320,
                    size: "sm",
                    expectMobile: true
                },
                {
                    viewport: 480,
                    size: "md",
                    expectMobile: true
                },
                {
                    viewport: 639,
                    size: "lg",
                    expectMobile: true
                },
                {
                    viewport: 640,
                    size: "xl",
                    expectMobile: false
                },
                {
                    viewport: 768,
                    size: "sm",
                    expectMobile: false
                },
                {
                    viewport: 1024,
                    size: "md",
                    expectMobile: false
                },
                {
                    viewport: 1440,
                    size: "lg",
                    expectMobile: false
                }
            ];
            testCases.forEach(({ viewport, size, expectMobile })=>{
                Object.defineProperty(window, "innerWidth", {
                    writable: true,
                    configurable: true,
                    value: viewport
                });
                const { container } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_Modal.Modal, {
                    isOpen: true,
                    onClose: ()=>{},
                    size: size,
                    children: /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                        children: "Test"
                    })
                }));
                const modalContent = findModalContent(container);
                if (modalContent) {
                    // All should have w-[95%]
                    expect(modalContent.className).toMatch(/w-\[95%\]/);
                    // All should have responsive max-width
                    expect(modalContent.className).toMatch(/sm:max-w-/);
                }
            });
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkU6XFxteVxcb3R1c1xcZmluYW5jZV90cmFja2VyXFxmcm9udGVuZFxcX190ZXN0c19fXFxwcm9wZXJ0aWVzXFxtb2RhbFdpbmRvd1dpZHRoLnByb3BlcnR5LnRlc3QudHN4Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBQcm9wZXJ0eS1CYXNlZCBUZXN0IOKAlCBNb2RhbCBXaW5kb3cgV2lkdGhcclxuICogXHJcbiAqICoq0KHQstC+0LnRgdGC0LLQviAxMDog0KjQuNGA0LjQvdCwINC80L7QtNCw0LvRjNC90YvRhSDQvtC60L7QvSoqXHJcbiAqICoq0JLQsNC70LjQtNC40YDRg9C10YI6INCi0YDQtdCx0L7QstCw0L3QuNGPIDQuMSoqXHJcbiAqIFxyXG4gKiBGb3IgYW55IG1vZGFsIHdpbmRvdywgd2hlbiB2aWV3cG9ydCB3aWR0aCBpcyBsZXNzIHRoYW4gNjQwcHgsXHJcbiAqIHRoZSBtb2RhbCB3aWR0aCBzaG91bGQgYmUgOTUlIG9mIHZpZXdwb3J0IHdpZHRoLlxyXG4gKiBPbiBkZXNrdG9wICg+PSA2NDBweCksIG1vZGFsIHNob3VsZCB1c2UgbWF4LXcte3NpemV9IGNsYXNzZXMuXHJcbiAqL1xyXG5cclxuaW1wb3J0IFJlYWN0IGZyb20gXCJyZWFjdFwiO1xyXG5pbXBvcnQgeyByZW5kZXIgfSBmcm9tIFwiQHRlc3RpbmctbGlicmFyeS9yZWFjdFwiO1xyXG5pbXBvcnQgZmMgZnJvbSBcImZhc3QtY2hlY2tcIjtcclxuaW1wb3J0IHsgTW9kYWwgfSBmcm9tIFwiQC9jb21wb25lbnRzL3VpL01vZGFsXCI7XHJcbmltcG9ydCB7IGdldE51bVJ1bnMsIGdldFRpbWVvdXQgfSBmcm9tIFwiLi9wcm9wZXJ0eS10ZXN0LWNvbmZpZ1wiO1xyXG5cclxuLy8gTW9iaWxlIGJyZWFrcG9pbnQgKHNtIGluIFRhaWx3aW5kKVxyXG5jb25zdCBNT0JJTEVfQlJFQUtQT0lOVCA9IDY0MDtcclxuXHJcbi8vIEV4cGVjdGVkIG1vYmlsZSB3aWR0aCBwZXJjZW50YWdlXHJcbmNvbnN0IE1PQklMRV9XSURUSF9QRVJDRU5UQUdFID0gOTU7XHJcblxyXG4vLyBIZWxwZXIgZnVuY3Rpb24gdG8gZ2V0IGNvbXB1dGVkIHdpZHRoIG9mIGFuIGVsZW1lbnRcclxuY29uc3QgZ2V0RWxlbWVudFdpZHRoID0gKGVsZW1lbnQ6IEVsZW1lbnQpOiBudW1iZXIgPT4ge1xyXG4gIGNvbnN0IHJlY3QgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gIHJldHVybiByZWN0LndpZHRoO1xyXG59O1xyXG5cclxuLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGZpbmQgbW9kYWwgY29udGVudCBjb250YWluZXJzXHJcbmNvbnN0IGZpbmRNb2RhbENvbnRlbnQgPSAoY29udGFpbmVyOiBIVE1MRWxlbWVudCk6IEVsZW1lbnQgfCBudWxsID0+IHtcclxuICAvLyBNb2RhbCBjb250ZW50IGlzIHJlbmRlcmVkIGluIGEgRGlhbG9nIGNvbXBvbmVudFxyXG4gIC8vIExvb2sgZm9yIGVsZW1lbnRzIHdpdGggdGhlIHJlc3BvbnNpdmUgd2lkdGggY2xhc3Nlc1xyXG4gIGNvbnN0IHNlbGVjdG9ycyA9IFtcclxuICAgIFwiW2NsYXNzKj0ndy1bOTUlXSddXCIsXHJcbiAgICBcIltyb2xlPSdkaWFsb2cnXVwiLFxyXG4gICAgXCIubWF4LXctbWRcIixcclxuICAgIFwiLm1heC13LWxnXCIsXHJcbiAgICBcIi5tYXgtdy0yeGxcIixcclxuICAgIFwiLm1heC13LTR4bFwiLFxyXG4gIF07XHJcbiAgXHJcbiAgZm9yIChjb25zdCBzZWxlY3RvciBvZiBzZWxlY3RvcnMpIHtcclxuICAgIGNvbnN0IGVsZW1lbnQgPSBjb250YWluZXIucXVlcnlTZWxlY3RvcihzZWxlY3Rvcik7XHJcbiAgICBpZiAoZWxlbWVudCkgcmV0dXJuIGVsZW1lbnQ7XHJcbiAgfVxyXG4gIFxyXG4gIHJldHVybiBudWxsO1xyXG59O1xyXG5cclxuZGVzY3JpYmUoXCJQcm9wZXJ0eTogTW9kYWwgV2luZG93IFdpZHRoXCIsICgpID0+IHtcclxuICBkZXNjcmliZShcIk1vZGFsIHdpZHRoIG9uIG1vYmlsZSB2aWV3cG9ydHNcIiwgKCkgPT4ge1xyXG4gICAgaXQoXCJzaG91bGQgaGF2ZSA5NSUgd2lkdGggb24gbW9iaWxlIHZpZXdwb3J0cyAoPCA2NDBweClcIiwgKCkgPT4ge1xyXG4gICAgICBqZXN0LnNldFRpbWVvdXQoZ2V0VGltZW91dChcIlNMT1dcIikpO1xyXG4gICAgICBmYy5hc3NlcnQoXHJcbiAgICAgICAgZmMucHJvcGVydHkoXHJcbiAgICAgICAgICBmYy5pbnRlZ2VyKHsgbWluOiAzMjAsIG1heDogNjM5IH0pLCAvLyBNb2JpbGUgdmlld3BvcnQgcmFuZ2VcclxuICAgICAgICAgIGZjLmNvbnN0YW50RnJvbShcInNtXCIgYXMgY29uc3QsIFwibWRcIiBhcyBjb25zdCwgXCJsZ1wiIGFzIGNvbnN0LCBcInhsXCIgYXMgY29uc3QpLFxyXG4gICAgICAgICAgZmMuc3RyaW5nKHsgbWluTGVuZ3RoOiA1LCBtYXhMZW5ndGg6IDEwMCB9KSxcclxuICAgICAgICAgICh2aWV3cG9ydFdpZHRoLCBzaXplLCBjb250ZW50KSA9PiB7XHJcbiAgICAgICAgICAgIC8vIE1vY2sgd2luZG93LmlubmVyV2lkdGggZm9yIG1vYmlsZVxyXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkod2luZG93LCBcImlubmVyV2lkdGhcIiwge1xyXG4gICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgICB2YWx1ZTogdmlld3BvcnRXaWR0aCxcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAvLyBNb2NrIG1hdGNoTWVkaWEgZm9yIFRhaWx3aW5kJ3Mgc20gYnJlYWtwb2ludCAoNjQwcHgpXHJcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3aW5kb3csIFwibWF0Y2hNZWRpYVwiLCB7XHJcbiAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgdmFsdWU6IGplc3QuZm4oKS5tb2NrSW1wbGVtZW50YXRpb24oKHF1ZXJ5KSA9PiAoe1xyXG4gICAgICAgICAgICAgICAgbWF0Y2hlczogcXVlcnkuaW5jbHVkZXMoXCI2NDBweFwiKSA/IGZhbHNlIDogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIG1lZGlhOiBxdWVyeSxcclxuICAgICAgICAgICAgICAgIG9uY2hhbmdlOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgYWRkTGlzdGVuZXI6IGplc3QuZm4oKSxcclxuICAgICAgICAgICAgICAgIHJlbW92ZUxpc3RlbmVyOiBqZXN0LmZuKCksXHJcbiAgICAgICAgICAgICAgICBhZGRFdmVudExpc3RlbmVyOiBqZXN0LmZuKCksXHJcbiAgICAgICAgICAgICAgICByZW1vdmVFdmVudExpc3RlbmVyOiBqZXN0LmZuKCksXHJcbiAgICAgICAgICAgICAgICBkaXNwYXRjaEV2ZW50OiBqZXN0LmZuKCksXHJcbiAgICAgICAgICAgICAgfSkpLFxyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IHsgY29udGFpbmVyIH0gPSByZW5kZXIoXHJcbiAgICAgICAgICAgICAgPE1vZGFsIGlzT3Blbj17dHJ1ZX0gb25DbG9zZT17KCkgPT4ge319IHNpemU9e3NpemV9PlxyXG4gICAgICAgICAgICAgICAgPGRpdj57Y29udGVudH08L2Rpdj5cclxuICAgICAgICAgICAgICA8L01vZGFsPlxyXG4gICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgLy8gRmluZCBtb2RhbCBjb250ZW50XHJcbiAgICAgICAgICAgIGNvbnN0IG1vZGFsQ29udGVudCA9IGZpbmRNb2RhbENvbnRlbnQoY29udGFpbmVyKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChtb2RhbENvbnRlbnQpIHtcclxuICAgICAgICAgICAgICAvLyBWZXJpZnkgdGhlIG1vZGFsIGhhcyB3LVs5NSVdIGNsYXNzXHJcbiAgICAgICAgICAgICAgZXhwZWN0KG1vZGFsQ29udGVudC5jbGFzc05hbWUpLnRvTWF0Y2goL3ctXFxbOTUlXFxdLyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICApLFxyXG4gICAgICAgIHsgbnVtUnVuczogZ2V0TnVtUnVucyhcIk1FRElVTVwiKSB9XHJcbiAgICAgICk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBpdChcInNob3VsZCB2ZXJpZnkgYWxsIG1vZGFsIHNpemVzIHVzZSA5NSUgd2lkdGggb24gbW9iaWxlXCIsICgpID0+IHtcclxuICAgICAgamVzdC5zZXRUaW1lb3V0KGdldFRpbWVvdXQoXCJTTE9XXCIpKTtcclxuICAgICAgY29uc3Qgc2l6ZXM6IEFycmF5PFwic21cIiB8IFwibWRcIiB8IFwibGdcIiB8IFwieGxcIj4gPSBbXCJzbVwiLCBcIm1kXCIsIFwibGdcIiwgXCJ4bFwiXTtcclxuXHJcbiAgICAgIGZjLmFzc2VydChcclxuICAgICAgICBmYy5wcm9wZXJ0eShcclxuICAgICAgICAgIGZjLmludGVnZXIoeyBtaW46IDMyMCwgbWF4OiA2MzkgfSksXHJcbiAgICAgICAgICBmYy5jb25zdGFudEZyb20oLi4uc2l6ZXMpLFxyXG4gICAgICAgICAgKHZpZXdwb3J0V2lkdGgsIHNpemUpID0+IHtcclxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHdpbmRvdywgXCJpbm5lcldpZHRoXCIsIHtcclxuICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgdmFsdWU6IHZpZXdwb3J0V2lkdGgsXHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHdpbmRvdywgXCJtYXRjaE1lZGlhXCIsIHtcclxuICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgICB2YWx1ZTogamVzdC5mbigpLm1vY2tJbXBsZW1lbnRhdGlvbigocXVlcnkpID0+ICh7XHJcbiAgICAgICAgICAgICAgICBtYXRjaGVzOiBxdWVyeS5pbmNsdWRlcyhcIjY0MHB4XCIpID8gZmFsc2UgOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgbWVkaWE6IHF1ZXJ5LFxyXG4gICAgICAgICAgICAgICAgb25jaGFuZ2U6IG51bGwsXHJcbiAgICAgICAgICAgICAgICBhZGRMaXN0ZW5lcjogamVzdC5mbigpLFxyXG4gICAgICAgICAgICAgICAgcmVtb3ZlTGlzdGVuZXI6IGplc3QuZm4oKSxcclxuICAgICAgICAgICAgICAgIGFkZEV2ZW50TGlzdGVuZXI6IGplc3QuZm4oKSxcclxuICAgICAgICAgICAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXI6IGplc3QuZm4oKSxcclxuICAgICAgICAgICAgICAgIGRpc3BhdGNoRXZlbnQ6IGplc3QuZm4oKSxcclxuICAgICAgICAgICAgICB9KSksXHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgeyBjb250YWluZXIgfSA9IHJlbmRlcihcclxuICAgICAgICAgICAgICA8TW9kYWwgaXNPcGVuPXt0cnVlfSBvbkNsb3NlPXsoKSA9PiB7fX0gc2l6ZT17c2l6ZX0+XHJcbiAgICAgICAgICAgICAgICA8ZGl2PlRlc3QgY29udGVudDwvZGl2PlxyXG4gICAgICAgICAgICAgIDwvTW9kYWw+XHJcbiAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICBjb25zdCBtb2RhbENvbnRlbnQgPSBmaW5kTW9kYWxDb250ZW50KGNvbnRhaW5lcik7XHJcblxyXG4gICAgICAgICAgICBpZiAobW9kYWxDb250ZW50KSB7XHJcbiAgICAgICAgICAgICAgLy8gQWxsIHNpemVzIHNob3VsZCBoYXZlIHctWzk1JV0gb24gbW9iaWxlXHJcbiAgICAgICAgICAgICAgZXhwZWN0KG1vZGFsQ29udGVudC5jbGFzc05hbWUpLnRvTWF0Y2goL3ctXFxbOTUlXFxdLyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICApLFxyXG4gICAgICAgIHsgbnVtUnVuczogZ2V0TnVtUnVucyhcIk1FRElVTVwiKSB9XHJcbiAgICAgICk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBpdChcInNob3VsZCBtYWludGFpbiA5NSUgd2lkdGggYXQgZXhhY3RseSAzMjBweCAobWluaW11bSBzdXBwb3J0ZWQgd2lkdGgpXCIsICgpID0+IHtcclxuICAgICAgamVzdC5zZXRUaW1lb3V0KGdldFRpbWVvdXQoXCJTTE9XXCIpKTtcclxuICAgICAgY29uc3Qgdmlld3BvcnRXaWR0aCA9IDMyMDtcclxuXHJcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3aW5kb3csIFwiaW5uZXJXaWR0aFwiLCB7XHJcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIHZhbHVlOiB2aWV3cG9ydFdpZHRoLFxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGZjLmFzc2VydChcclxuICAgICAgICBmYy5wcm9wZXJ0eShcclxuICAgICAgICAgIGZjLmNvbnN0YW50RnJvbShcInNtXCIgYXMgY29uc3QsIFwibWRcIiBhcyBjb25zdCwgXCJsZ1wiIGFzIGNvbnN0LCBcInhsXCIgYXMgY29uc3QpLFxyXG4gICAgICAgICAgKHNpemUpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgeyBjb250YWluZXIgfSA9IHJlbmRlcihcclxuICAgICAgICAgICAgICA8TW9kYWwgaXNPcGVuPXt0cnVlfSBvbkNsb3NlPXsoKSA9PiB7fX0gc2l6ZT17c2l6ZX0+XHJcbiAgICAgICAgICAgICAgICA8ZGl2PlRlc3QgY29udGVudDwvZGl2PlxyXG4gICAgICAgICAgICAgIDwvTW9kYWw+XHJcbiAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICBjb25zdCBtb2RhbENvbnRlbnQgPSBmaW5kTW9kYWxDb250ZW50KGNvbnRhaW5lcik7XHJcblxyXG4gICAgICAgICAgICBpZiAobW9kYWxDb250ZW50KSB7XHJcbiAgICAgICAgICAgICAgZXhwZWN0KG1vZGFsQ29udGVudC5jbGFzc05hbWUpLnRvTWF0Y2goL3ctXFxbOTUlXFxdLyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICApLFxyXG4gICAgICAgIHsgbnVtUnVuczogZ2V0TnVtUnVucyhcIkZBU1RcIikgfVxyXG4gICAgICApO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaXQoXCJzaG91bGQgbWFpbnRhaW4gOTUlIHdpZHRoIGF0IDYzOXB4IChqdXN0IGJlbG93IHNtIGJyZWFrcG9pbnQpXCIsICgpID0+IHtcclxuICAgICAgamVzdC5zZXRUaW1lb3V0KGdldFRpbWVvdXQoXCJTTE9XXCIpKTtcclxuICAgICAgY29uc3Qgdmlld3BvcnRXaWR0aCA9IDYzOTtcclxuXHJcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3aW5kb3csIFwiaW5uZXJXaWR0aFwiLCB7XHJcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIHZhbHVlOiB2aWV3cG9ydFdpZHRoLFxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGZjLmFzc2VydChcclxuICAgICAgICBmYy5wcm9wZXJ0eShcclxuICAgICAgICAgIGZjLmNvbnN0YW50RnJvbShcInNtXCIgYXMgY29uc3QsIFwibWRcIiBhcyBjb25zdCwgXCJsZ1wiIGFzIGNvbnN0LCBcInhsXCIgYXMgY29uc3QpLFxyXG4gICAgICAgICAgKHNpemUpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgeyBjb250YWluZXIgfSA9IHJlbmRlcihcclxuICAgICAgICAgICAgICA8TW9kYWwgaXNPcGVuPXt0cnVlfSBvbkNsb3NlPXsoKSA9PiB7fX0gc2l6ZT17c2l6ZX0+XHJcbiAgICAgICAgICAgICAgICA8ZGl2PlRlc3QgY29udGVudDwvZGl2PlxyXG4gICAgICAgICAgICAgIDwvTW9kYWw+XHJcbiAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICBjb25zdCBtb2RhbENvbnRlbnQgPSBmaW5kTW9kYWxDb250ZW50KGNvbnRhaW5lcik7XHJcblxyXG4gICAgICAgICAgICBpZiAobW9kYWxDb250ZW50KSB7XHJcbiAgICAgICAgICAgICAgZXhwZWN0KG1vZGFsQ29udGVudC5jbGFzc05hbWUpLnRvTWF0Y2goL3ctXFxbOTUlXFxdLyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICApLFxyXG4gICAgICAgIHsgbnVtUnVuczogZ2V0TnVtUnVucyhcIkZBU1RcIikgfVxyXG4gICAgICApO1xyXG4gICAgfSk7XHJcbiAgfSk7XHJcblxyXG4gIGRlc2NyaWJlKFwiTW9kYWwgd2lkdGggb24gZGVza3RvcCB2aWV3cG9ydHNcIiwgKCkgPT4ge1xyXG4gICAgaXQoXCJzaG91bGQgdXNlIG1heC13LXtzaXplfSBjbGFzc2VzIG9uIGRlc2t0b3Agdmlld3BvcnRzICg+PSA2NDBweClcIiwgKCkgPT4ge1xyXG4gICAgICBqZXN0LnNldFRpbWVvdXQoZ2V0VGltZW91dChcIlNMT1dcIikpO1xyXG4gICAgICBmYy5hc3NlcnQoXHJcbiAgICAgICAgZmMucHJvcGVydHkoXHJcbiAgICAgICAgICBmYy5pbnRlZ2VyKHsgbWluOiA2NDAsIG1heDogMTQ0MCB9KSwgLy8gRGVza3RvcCB2aWV3cG9ydCByYW5nZVxyXG4gICAgICAgICAgZmMuY29uc3RhbnRGcm9tKFwic21cIiBhcyBjb25zdCwgXCJtZFwiIGFzIGNvbnN0LCBcImxnXCIgYXMgY29uc3QsIFwieGxcIiBhcyBjb25zdCksXHJcbiAgICAgICAgICAodmlld3BvcnRXaWR0aCwgc2l6ZSkgPT4ge1xyXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkod2luZG93LCBcImlubmVyV2lkdGhcIiwge1xyXG4gICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgICB2YWx1ZTogdmlld3BvcnRXaWR0aCxcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkod2luZG93LCBcIm1hdGNoTWVkaWFcIiwge1xyXG4gICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICAgIHZhbHVlOiBqZXN0LmZuKCkubW9ja0ltcGxlbWVudGF0aW9uKChxdWVyeSkgPT4gKHtcclxuICAgICAgICAgICAgICAgIG1hdGNoZXM6IHF1ZXJ5LmluY2x1ZGVzKFwiNjQwcHhcIikgPyB0cnVlIDogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBtZWRpYTogcXVlcnksXHJcbiAgICAgICAgICAgICAgICBvbmNoYW5nZTogbnVsbCxcclxuICAgICAgICAgICAgICAgIGFkZExpc3RlbmVyOiBqZXN0LmZuKCksXHJcbiAgICAgICAgICAgICAgICByZW1vdmVMaXN0ZW5lcjogamVzdC5mbigpLFxyXG4gICAgICAgICAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcjogamVzdC5mbigpLFxyXG4gICAgICAgICAgICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcjogamVzdC5mbigpLFxyXG4gICAgICAgICAgICAgICAgZGlzcGF0Y2hFdmVudDogamVzdC5mbigpLFxyXG4gICAgICAgICAgICAgIH0pKSxcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBjb25zdCB7IGNvbnRhaW5lciB9ID0gcmVuZGVyKFxyXG4gICAgICAgICAgICAgIDxNb2RhbCBpc09wZW49e3RydWV9IG9uQ2xvc2U9eygpID0+IHt9fSBzaXplPXtzaXplfT5cclxuICAgICAgICAgICAgICAgIDxkaXY+VGVzdCBjb250ZW50PC9kaXY+XHJcbiAgICAgICAgICAgICAgPC9Nb2RhbD5cclxuICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IG1vZGFsQ29udGVudCA9IGZpbmRNb2RhbENvbnRlbnQoY29udGFpbmVyKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChtb2RhbENvbnRlbnQpIHtcclxuICAgICAgICAgICAgICAvLyBTaG91bGQgc3RpbGwgaGF2ZSB3LVs5NSVdIGJhc2UgY2xhc3NcclxuICAgICAgICAgICAgICBleHBlY3QobW9kYWxDb250ZW50LmNsYXNzTmFtZSkudG9NYXRjaCgvdy1cXFs5NSVcXF0vKTtcclxuICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAvLyBTaG91bGQgYWxzbyBoYXZlIHNtOm1heC13LXtzaXplfSByZXNwb25zaXZlIGNsYXNzXHJcbiAgICAgICAgICAgICAgY29uc3QgZXhwZWN0ZWRNYXhXaWR0aCA9IHtcclxuICAgICAgICAgICAgICAgIHNtOiBcInNtOm1heC13LW1kXCIsXHJcbiAgICAgICAgICAgICAgICBtZDogXCJzbTptYXgtdy1sZ1wiLFxyXG4gICAgICAgICAgICAgICAgbGc6IFwic206bWF4LXctMnhsXCIsXHJcbiAgICAgICAgICAgICAgICB4bDogXCJzbTptYXgtdy00eGxcIixcclxuICAgICAgICAgICAgICB9W3NpemVdO1xyXG4gICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgIGV4cGVjdChtb2RhbENvbnRlbnQuY2xhc3NOYW1lKS50b01hdGNoKG5ldyBSZWdFeHAoZXhwZWN0ZWRNYXhXaWR0aC5yZXBsYWNlKC86L2csIFwiXFxcXDpcIikpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICksXHJcbiAgICAgICAgeyBudW1SdW5zOiBnZXROdW1SdW5zKFwiTUVESVVNXCIpIH1cclxuICAgICAgKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGl0KFwic2hvdWxkIHZlcmlmeSBlYWNoIG1vZGFsIHNpemUgaGFzIGNvcnJlY3QgbWF4LXdpZHRoIGNsYXNzXCIsICgpID0+IHtcclxuICAgICAgamVzdC5zZXRUaW1lb3V0KGdldFRpbWVvdXQoXCJTTE9XXCIpKTtcclxuICAgICAgY29uc3Qgc2l6ZVRvTWF4V2lkdGggPSB7XHJcbiAgICAgICAgc206IFwic206bWF4LXctbWRcIixcclxuICAgICAgICBtZDogXCJzbTptYXgtdy1sZ1wiLFxyXG4gICAgICAgIGxnOiBcInNtOm1heC13LTJ4bFwiLFxyXG4gICAgICAgIHhsOiBcInNtOm1heC13LTR4bFwiLFxyXG4gICAgICB9O1xyXG5cclxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHdpbmRvdywgXCJpbm5lcldpZHRoXCIsIHtcclxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgdmFsdWU6IDEwMjQsXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgT2JqZWN0LmtleXMoc2l6ZVRvTWF4V2lkdGgpLmZvckVhY2goKHNpemUpID0+IHtcclxuICAgICAgICBjb25zdCB7IGNvbnRhaW5lciB9ID0gcmVuZGVyKFxyXG4gICAgICAgICAgPE1vZGFsIGlzT3Blbj17dHJ1ZX0gb25DbG9zZT17KCkgPT4ge319IHNpemU9e3NpemUgYXMgXCJzbVwiIHwgXCJtZFwiIHwgXCJsZ1wiIHwgXCJ4bFwifT5cclxuICAgICAgICAgICAgPGRpdj5UZXN0IGNvbnRlbnQ8L2Rpdj5cclxuICAgICAgICAgIDwvTW9kYWw+XHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgY29uc3QgbW9kYWxDb250ZW50ID0gZmluZE1vZGFsQ29udGVudChjb250YWluZXIpO1xyXG5cclxuICAgICAgICBpZiAobW9kYWxDb250ZW50KSB7XHJcbiAgICAgICAgICBjb25zdCBleHBlY3RlZENsYXNzID0gc2l6ZVRvTWF4V2lkdGhbc2l6ZSBhcyBrZXlvZiB0eXBlb2Ygc2l6ZVRvTWF4V2lkdGhdO1xyXG4gICAgICAgICAgZXhwZWN0KG1vZGFsQ29udGVudC5jbGFzc05hbWUpLnRvTWF0Y2gobmV3IFJlZ0V4cChleHBlY3RlZENsYXNzLnJlcGxhY2UoLzovZywgXCJcXFxcOlwiKSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBpdChcInNob3VsZCBzd2l0Y2ggdG8gbWF4LXdpZHRoIGF0IGV4YWN0bHkgNjQwcHggKHNtIGJyZWFrcG9pbnQpXCIsICgpID0+IHtcclxuICAgICAgamVzdC5zZXRUaW1lb3V0KGdldFRpbWVvdXQoXCJTTE9XXCIpKTtcclxuICAgICAgY29uc3Qgdmlld3BvcnRXaWR0aCA9IDY0MDtcclxuXHJcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3aW5kb3csIFwiaW5uZXJXaWR0aFwiLCB7XHJcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIHZhbHVlOiB2aWV3cG9ydFdpZHRoLFxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGZjLmFzc2VydChcclxuICAgICAgICBmYy5wcm9wZXJ0eShcclxuICAgICAgICAgIGZjLmNvbnN0YW50RnJvbShcInNtXCIgYXMgY29uc3QsIFwibWRcIiBhcyBjb25zdCwgXCJsZ1wiIGFzIGNvbnN0LCBcInhsXCIgYXMgY29uc3QpLFxyXG4gICAgICAgICAgKHNpemUpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgeyBjb250YWluZXIgfSA9IHJlbmRlcihcclxuICAgICAgICAgICAgICA8TW9kYWwgaXNPcGVuPXt0cnVlfSBvbkNsb3NlPXsoKSA9PiB7fX0gc2l6ZT17c2l6ZX0+XHJcbiAgICAgICAgICAgICAgICA8ZGl2PlRlc3QgY29udGVudDwvZGl2PlxyXG4gICAgICAgICAgICAgIDwvTW9kYWw+XHJcbiAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICBjb25zdCBtb2RhbENvbnRlbnQgPSBmaW5kTW9kYWxDb250ZW50KGNvbnRhaW5lcik7XHJcblxyXG4gICAgICAgICAgICBpZiAobW9kYWxDb250ZW50KSB7XHJcbiAgICAgICAgICAgICAgLy8gU2hvdWxkIGhhdmUgYm90aCB3LVs5NSVdIGFuZCBzbTptYXgtdy17c2l6ZX1cclxuICAgICAgICAgICAgICBleHBlY3QobW9kYWxDb250ZW50LmNsYXNzTmFtZSkudG9NYXRjaCgvdy1cXFs5NSVcXF0vKTtcclxuICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICBjb25zdCBleHBlY3RlZE1heFdpZHRoID0ge1xyXG4gICAgICAgICAgICAgICAgc206IFwic206bWF4LXctbWRcIixcclxuICAgICAgICAgICAgICAgIG1kOiBcInNtOm1heC13LWxnXCIsXHJcbiAgICAgICAgICAgICAgICBsZzogXCJzbTptYXgtdy0yeGxcIixcclxuICAgICAgICAgICAgICAgIHhsOiBcInNtOm1heC13LTR4bFwiLFxyXG4gICAgICAgICAgICAgIH1bc2l6ZV07XHJcbiAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgZXhwZWN0KG1vZGFsQ29udGVudC5jbGFzc05hbWUpLnRvTWF0Y2gobmV3IFJlZ0V4cChleHBlY3RlZE1heFdpZHRoLnJlcGxhY2UoLzovZywgXCJcXFxcOlwiKSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgKSxcclxuICAgICAgICB7IG51bVJ1bnM6IGdldE51bVJ1bnMoXCJGQVNUXCIpIH1cclxuICAgICAgKTtcclxuICAgIH0pO1xyXG4gIH0pO1xyXG5cclxuICBkZXNjcmliZShcIk1vZGFsIHNpemUgdmFyaWFudHNcIiwgKCkgPT4ge1xyXG4gICAgaXQoXCJzaG91bGQgdmVyaWZ5IHNtIG1vZGFsIGhhcyBtYXgtdy1tZCBvbiBkZXNrdG9wXCIsICgpID0+IHtcclxuICAgICAgamVzdC5zZXRUaW1lb3V0KGdldFRpbWVvdXQoXCJTTE9XXCIpKTtcclxuICAgICAgZmMuYXNzZXJ0KFxyXG4gICAgICAgIGZjLnByb3BlcnR5KFxyXG4gICAgICAgICAgZmMuaW50ZWdlcih7IG1pbjogNjQwLCBtYXg6IDE0NDAgfSksXHJcbiAgICAgICAgICAodmlld3BvcnRXaWR0aCkgPT4ge1xyXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkod2luZG93LCBcImlubmVyV2lkdGhcIiwge1xyXG4gICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgICB2YWx1ZTogdmlld3BvcnRXaWR0aCxcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBjb25zdCB7IGNvbnRhaW5lciB9ID0gcmVuZGVyKFxyXG4gICAgICAgICAgICAgIDxNb2RhbCBpc09wZW49e3RydWV9IG9uQ2xvc2U9eygpID0+IHt9fSBzaXplPVwic21cIj5cclxuICAgICAgICAgICAgICAgIDxkaXY+U21hbGwgbW9kYWw8L2Rpdj5cclxuICAgICAgICAgICAgICA8L01vZGFsPlxyXG4gICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgbW9kYWxDb250ZW50ID0gZmluZE1vZGFsQ29udGVudChjb250YWluZXIpO1xyXG5cclxuICAgICAgICAgICAgaWYgKG1vZGFsQ29udGVudCkge1xyXG4gICAgICAgICAgICAgIGV4cGVjdChtb2RhbENvbnRlbnQuY2xhc3NOYW1lKS50b01hdGNoKC9zbTptYXgtdy1tZC8pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgKSxcclxuICAgICAgICB7IG51bVJ1bnM6IGdldE51bVJ1bnMoXCJGQVNUXCIpIH1cclxuICAgICAgKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGl0KFwic2hvdWxkIHZlcmlmeSBtZCBtb2RhbCBoYXMgbWF4LXctbGcgb24gZGVza3RvcFwiLCAoKSA9PiB7XHJcbiAgICAgIGplc3Quc2V0VGltZW91dChnZXRUaW1lb3V0KFwiU0xPV1wiKSk7XHJcbiAgICAgIGZjLmFzc2VydChcclxuICAgICAgICBmYy5wcm9wZXJ0eShcclxuICAgICAgICAgIGZjLmludGVnZXIoeyBtaW46IDY0MCwgbWF4OiAxNDQwIH0pLFxyXG4gICAgICAgICAgKHZpZXdwb3J0V2lkdGgpID0+IHtcclxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHdpbmRvdywgXCJpbm5lcldpZHRoXCIsIHtcclxuICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgdmFsdWU6IHZpZXdwb3J0V2lkdGgsXHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgeyBjb250YWluZXIgfSA9IHJlbmRlcihcclxuICAgICAgICAgICAgICA8TW9kYWwgaXNPcGVuPXt0cnVlfSBvbkNsb3NlPXsoKSA9PiB7fX0gc2l6ZT1cIm1kXCI+XHJcbiAgICAgICAgICAgICAgICA8ZGl2Pk1lZGl1bSBtb2RhbDwvZGl2PlxyXG4gICAgICAgICAgICAgIDwvTW9kYWw+XHJcbiAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICBjb25zdCBtb2RhbENvbnRlbnQgPSBmaW5kTW9kYWxDb250ZW50KGNvbnRhaW5lcik7XHJcblxyXG4gICAgICAgICAgICBpZiAobW9kYWxDb250ZW50KSB7XHJcbiAgICAgICAgICAgICAgZXhwZWN0KG1vZGFsQ29udGVudC5jbGFzc05hbWUpLnRvTWF0Y2goL3NtOm1heC13LWxnLyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICApLFxyXG4gICAgICAgIHsgbnVtUnVuczogZ2V0TnVtUnVucyhcIkZBU1RcIikgfVxyXG4gICAgICApO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaXQoXCJzaG91bGQgdmVyaWZ5IGxnIG1vZGFsIGhhcyBtYXgtdy0yeGwgb24gZGVza3RvcFwiLCAoKSA9PiB7XHJcbiAgICAgIGplc3Quc2V0VGltZW91dChnZXRUaW1lb3V0KFwiU0xPV1wiKSk7XHJcbiAgICAgIGZjLmFzc2VydChcclxuICAgICAgICBmYy5wcm9wZXJ0eShcclxuICAgICAgICAgIGZjLmludGVnZXIoeyBtaW46IDY0MCwgbWF4OiAxNDQwIH0pLFxyXG4gICAgICAgICAgKHZpZXdwb3J0V2lkdGgpID0+IHtcclxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHdpbmRvdywgXCJpbm5lcldpZHRoXCIsIHtcclxuICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgdmFsdWU6IHZpZXdwb3J0V2lkdGgsXHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgeyBjb250YWluZXIgfSA9IHJlbmRlcihcclxuICAgICAgICAgICAgICA8TW9kYWwgaXNPcGVuPXt0cnVlfSBvbkNsb3NlPXsoKSA9PiB7fX0gc2l6ZT1cImxnXCI+XHJcbiAgICAgICAgICAgICAgICA8ZGl2PkxhcmdlIG1vZGFsPC9kaXY+XHJcbiAgICAgICAgICAgICAgPC9Nb2RhbD5cclxuICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IG1vZGFsQ29udGVudCA9IGZpbmRNb2RhbENvbnRlbnQoY29udGFpbmVyKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChtb2RhbENvbnRlbnQpIHtcclxuICAgICAgICAgICAgICBleHBlY3QobW9kYWxDb250ZW50LmNsYXNzTmFtZSkudG9NYXRjaCgvc206bWF4LXctMnhsLyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICApLFxyXG4gICAgICAgIHsgbnVtUnVuczogZ2V0TnVtUnVucyhcIkZBU1RcIikgfVxyXG4gICAgICApO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaXQoXCJzaG91bGQgdmVyaWZ5IHhsIG1vZGFsIGhhcyBtYXgtdy00eGwgb24gZGVza3RvcFwiLCAoKSA9PiB7XHJcbiAgICAgIGplc3Quc2V0VGltZW91dChnZXRUaW1lb3V0KFwiU0xPV1wiKSk7XHJcbiAgICAgIGZjLmFzc2VydChcclxuICAgICAgICBmYy5wcm9wZXJ0eShcclxuICAgICAgICAgIGZjLmludGVnZXIoeyBtaW46IDY0MCwgbWF4OiAxNDQwIH0pLFxyXG4gICAgICAgICAgKHZpZXdwb3J0V2lkdGgpID0+IHtcclxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHdpbmRvdywgXCJpbm5lcldpZHRoXCIsIHtcclxuICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgdmFsdWU6IHZpZXdwb3J0V2lkdGgsXHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgeyBjb250YWluZXIgfSA9IHJlbmRlcihcclxuICAgICAgICAgICAgICA8TW9kYWwgaXNPcGVuPXt0cnVlfSBvbkNsb3NlPXsoKSA9PiB7fX0gc2l6ZT1cInhsXCI+XHJcbiAgICAgICAgICAgICAgICA8ZGl2PkV4dHJhIGxhcmdlIG1vZGFsPC9kaXY+XHJcbiAgICAgICAgICAgICAgPC9Nb2RhbD5cclxuICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IG1vZGFsQ29udGVudCA9IGZpbmRNb2RhbENvbnRlbnQoY29udGFpbmVyKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChtb2RhbENvbnRlbnQpIHtcclxuICAgICAgICAgICAgICBleHBlY3QobW9kYWxDb250ZW50LmNsYXNzTmFtZSkudG9NYXRjaCgvc206bWF4LXctNHhsLyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICApLFxyXG4gICAgICAgIHsgbnVtUnVuczogZ2V0TnVtUnVucyhcIkZBU1RcIikgfVxyXG4gICAgICApO1xyXG4gICAgfSk7XHJcbiAgfSk7XHJcblxyXG4gIGRlc2NyaWJlKFwiRWRnZSBjYXNlc1wiLCAoKSA9PiB7XHJcbiAgICBpdChcInNob3VsZCBoYW5kbGUgbW9kYWwgd2l0aCB2ZXJ5IGxvbmcgY29udGVudFwiLCAoKSA9PiB7XHJcbiAgICAgIGplc3Quc2V0VGltZW91dChnZXRUaW1lb3V0KFwiU0xPV1wiKSk7XHJcbiAgICAgIGZjLmFzc2VydChcclxuICAgICAgICBmYy5wcm9wZXJ0eShcclxuICAgICAgICAgIGZjLmludGVnZXIoeyBtaW46IDMyMCwgbWF4OiA2MzkgfSksXHJcbiAgICAgICAgICBmYy5zdHJpbmcoeyBtaW5MZW5ndGg6IDUwMCwgbWF4TGVuZ3RoOiAyMDAwIH0pLFxyXG4gICAgICAgICAgKHZpZXdwb3J0V2lkdGgsIGxvbmdDb250ZW50KSA9PiB7XHJcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3aW5kb3csIFwiaW5uZXJXaWR0aFwiLCB7XHJcbiAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICAgIHZhbHVlOiB2aWV3cG9ydFdpZHRoLFxyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IHsgY29udGFpbmVyIH0gPSByZW5kZXIoXHJcbiAgICAgICAgICAgICAgPE1vZGFsIGlzT3Blbj17dHJ1ZX0gb25DbG9zZT17KCkgPT4ge319IHNpemU9XCJtZFwiPlxyXG4gICAgICAgICAgICAgICAgPGRpdj57bG9uZ0NvbnRlbnR9PC9kaXY+XHJcbiAgICAgICAgICAgICAgPC9Nb2RhbD5cclxuICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IG1vZGFsQ29udGVudCA9IGZpbmRNb2RhbENvbnRlbnQoY29udGFpbmVyKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChtb2RhbENvbnRlbnQpIHtcclxuICAgICAgICAgICAgICAvLyBXaWR0aCBzaG91bGQgc3RpbGwgYmUgOTUlIG9uIG1vYmlsZSByZWdhcmRsZXNzIG9mIGNvbnRlbnQgbGVuZ3RoXHJcbiAgICAgICAgICAgICAgZXhwZWN0KG1vZGFsQ29udGVudC5jbGFzc05hbWUpLnRvTWF0Y2goL3ctXFxbOTUlXFxdLyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICApLFxyXG4gICAgICAgIHsgbnVtUnVuczogZ2V0TnVtUnVucyhcIlNMT1dcIikgfVxyXG4gICAgICApO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaXQoXCJzaG91bGQgaGFuZGxlIG1vZGFsIHdpdGggbWluaW1hbCBjb250ZW50XCIsICgpID0+IHtcclxuICAgICAgamVzdC5zZXRUaW1lb3V0KGdldFRpbWVvdXQoXCJTTE9XXCIpKTtcclxuICAgICAgZmMuYXNzZXJ0KFxyXG4gICAgICAgIGZjLnByb3BlcnR5KFxyXG4gICAgICAgICAgZmMuaW50ZWdlcih7IG1pbjogMzIwLCBtYXg6IDE0NDAgfSksXHJcbiAgICAgICAgICBmYy5jb25zdGFudEZyb20oXCJzbVwiIGFzIGNvbnN0LCBcIm1kXCIgYXMgY29uc3QsIFwibGdcIiBhcyBjb25zdCwgXCJ4bFwiIGFzIGNvbnN0KSxcclxuICAgICAgICAgICh2aWV3cG9ydFdpZHRoLCBzaXplKSA9PiB7XHJcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3aW5kb3csIFwiaW5uZXJXaWR0aFwiLCB7XHJcbiAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICAgIHZhbHVlOiB2aWV3cG9ydFdpZHRoLFxyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IHsgY29udGFpbmVyIH0gPSByZW5kZXIoXHJcbiAgICAgICAgICAgICAgPE1vZGFsIGlzT3Blbj17dHJ1ZX0gb25DbG9zZT17KCkgPT4ge319IHNpemU9e3NpemV9PlxyXG4gICAgICAgICAgICAgICAgPGRpdj5YPC9kaXY+XHJcbiAgICAgICAgICAgICAgPC9Nb2RhbD5cclxuICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IG1vZGFsQ29udGVudCA9IGZpbmRNb2RhbENvbnRlbnQoY29udGFpbmVyKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChtb2RhbENvbnRlbnQpIHtcclxuICAgICAgICAgICAgICAvLyBXaWR0aCBjbGFzc2VzIHNob3VsZCBiZSBwcmVzZW50IHJlZ2FyZGxlc3Mgb2YgY29udGVudFxyXG4gICAgICAgICAgICAgIGV4cGVjdChtb2RhbENvbnRlbnQuY2xhc3NOYW1lKS50b01hdGNoKC93LVxcWzk1JVxcXS8pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgKSxcclxuICAgICAgICB7IG51bVJ1bnM6IGdldE51bVJ1bnMoXCJTTE9XXCIpIH1cclxuICAgICAgKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGl0KFwic2hvdWxkIGhhbmRsZSBtb2RhbCB3aXRoIG5lc3RlZCBlbGVtZW50c1wiLCAoKSA9PiB7XHJcbiAgICAgIGplc3Quc2V0VGltZW91dChnZXRUaW1lb3V0KFwiU0xPV1wiKSk7XHJcbiAgICAgIGZjLmFzc2VydChcclxuICAgICAgICBmYy5wcm9wZXJ0eShcclxuICAgICAgICAgIGZjLmludGVnZXIoeyBtaW46IDMyMCwgbWF4OiA2MzkgfSksXHJcbiAgICAgICAgICBmYy5hcnJheShmYy5zdHJpbmcoeyBtaW5MZW5ndGg6IDUsIG1heExlbmd0aDogNTAgfSksIHsgbWluTGVuZ3RoOiAxLCBtYXhMZW5ndGg6IDEwIH0pLFxyXG4gICAgICAgICAgKHZpZXdwb3J0V2lkdGgsIGl0ZW1zKSA9PiB7XHJcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3aW5kb3csIFwiaW5uZXJXaWR0aFwiLCB7XHJcbiAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICAgIHZhbHVlOiB2aWV3cG9ydFdpZHRoLFxyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IHsgY29udGFpbmVyIH0gPSByZW5kZXIoXHJcbiAgICAgICAgICAgICAgPE1vZGFsIGlzT3Blbj17dHJ1ZX0gb25DbG9zZT17KCkgPT4ge319IHNpemU9XCJtZFwiPlxyXG4gICAgICAgICAgICAgICAgPGRpdj5cclxuICAgICAgICAgICAgICAgICAgPGgyPlRpdGxlPC9oMj5cclxuICAgICAgICAgICAgICAgICAgPHVsPlxyXG4gICAgICAgICAgICAgICAgICAgIHtpdGVtcy5tYXAoKGl0ZW0sIGluZGV4KSA9PiAoXHJcbiAgICAgICAgICAgICAgICAgICAgICA8bGkga2V5PXtpbmRleH0+e2l0ZW19PC9saT5cclxuICAgICAgICAgICAgICAgICAgICApKX1cclxuICAgICAgICAgICAgICAgICAgPC91bD5cclxuICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgIDwvTW9kYWw+XHJcbiAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICBjb25zdCBtb2RhbENvbnRlbnQgPSBmaW5kTW9kYWxDb250ZW50KGNvbnRhaW5lcik7XHJcblxyXG4gICAgICAgICAgICBpZiAobW9kYWxDb250ZW50KSB7XHJcbiAgICAgICAgICAgICAgZXhwZWN0KG1vZGFsQ29udGVudC5jbGFzc05hbWUpLnRvTWF0Y2goL3ctXFxbOTUlXFxdLyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICApLFxyXG4gICAgICAgIHsgbnVtUnVuczogZ2V0TnVtUnVucyhcIlNMT1dcIikgfVxyXG4gICAgICApO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaXQoXCJzaG91bGQgaGFuZGxlIG1vZGFsIHdpdGggdGl0bGVcIiwgKCkgPT4ge1xyXG4gICAgICBqZXN0LnNldFRpbWVvdXQoZ2V0VGltZW91dChcIlNMT1dcIikpO1xyXG4gICAgICBmYy5hc3NlcnQoXHJcbiAgICAgICAgZmMucHJvcGVydHkoXHJcbiAgICAgICAgICBmYy5pbnRlZ2VyKHsgbWluOiAzMjAsIG1heDogNjM5IH0pLFxyXG4gICAgICAgICAgZmMuc3RyaW5nKHsgbWluTGVuZ3RoOiA1LCBtYXhMZW5ndGg6IDEwMCB9KSxcclxuICAgICAgICAgIGZjLmNvbnN0YW50RnJvbShcInNtXCIgYXMgY29uc3QsIFwibWRcIiBhcyBjb25zdCwgXCJsZ1wiIGFzIGNvbnN0LCBcInhsXCIgYXMgY29uc3QpLFxyXG4gICAgICAgICAgKHZpZXdwb3J0V2lkdGgsIHRpdGxlLCBzaXplKSA9PiB7XHJcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3aW5kb3csIFwiaW5uZXJXaWR0aFwiLCB7XHJcbiAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICAgIHZhbHVlOiB2aWV3cG9ydFdpZHRoLFxyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IHsgY29udGFpbmVyIH0gPSByZW5kZXIoXHJcbiAgICAgICAgICAgICAgPE1vZGFsIGlzT3Blbj17dHJ1ZX0gb25DbG9zZT17KCkgPT4ge319IHRpdGxlPXt0aXRsZX0gc2l6ZT17c2l6ZX0+XHJcbiAgICAgICAgICAgICAgICA8ZGl2PkNvbnRlbnQ8L2Rpdj5cclxuICAgICAgICAgICAgICA8L01vZGFsPlxyXG4gICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgbW9kYWxDb250ZW50ID0gZmluZE1vZGFsQ29udGVudChjb250YWluZXIpO1xyXG5cclxuICAgICAgICAgICAgaWYgKG1vZGFsQ29udGVudCkge1xyXG4gICAgICAgICAgICAgIGV4cGVjdChtb2RhbENvbnRlbnQuY2xhc3NOYW1lKS50b01hdGNoKC93LVxcWzk1JVxcXS8pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgKSxcclxuICAgICAgICB7IG51bVJ1bnM6IGdldE51bVJ1bnMoXCJTTE9XXCIpIH1cclxuICAgICAgKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGl0KFwic2hvdWxkIGhhbmRsZSBtb2RhbCB3aXRob3V0IHRpdGxlXCIsICgpID0+IHtcclxuICAgICAgamVzdC5zZXRUaW1lb3V0KGdldFRpbWVvdXQoXCJTTE9XXCIpKTtcclxuICAgICAgZmMuYXNzZXJ0KFxyXG4gICAgICAgIGZjLnByb3BlcnR5KFxyXG4gICAgICAgICAgZmMuaW50ZWdlcih7IG1pbjogMzIwLCBtYXg6IDYzOSB9KSxcclxuICAgICAgICAgIGZjLmNvbnN0YW50RnJvbShcInNtXCIgYXMgY29uc3QsIFwibWRcIiBhcyBjb25zdCwgXCJsZ1wiIGFzIGNvbnN0LCBcInhsXCIgYXMgY29uc3QpLFxyXG4gICAgICAgICAgKHZpZXdwb3J0V2lkdGgsIHNpemUpID0+IHtcclxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHdpbmRvdywgXCJpbm5lcldpZHRoXCIsIHtcclxuICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgdmFsdWU6IHZpZXdwb3J0V2lkdGgsXHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgeyBjb250YWluZXIgfSA9IHJlbmRlcihcclxuICAgICAgICAgICAgICA8TW9kYWwgaXNPcGVuPXt0cnVlfSBvbkNsb3NlPXsoKSA9PiB7fX0gc2l6ZT17c2l6ZX0+XHJcbiAgICAgICAgICAgICAgICA8ZGl2PkNvbnRlbnQgd2l0aG91dCB0aXRsZTwvZGl2PlxyXG4gICAgICAgICAgICAgIDwvTW9kYWw+XHJcbiAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICBjb25zdCBtb2RhbENvbnRlbnQgPSBmaW5kTW9kYWxDb250ZW50KGNvbnRhaW5lcik7XHJcblxyXG4gICAgICAgICAgICBpZiAobW9kYWxDb250ZW50KSB7XHJcbiAgICAgICAgICAgICAgZXhwZWN0KG1vZGFsQ29udGVudC5jbGFzc05hbWUpLnRvTWF0Y2goL3ctXFxbOTUlXFxdLyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICApLFxyXG4gICAgICAgIHsgbnVtUnVuczogZ2V0TnVtUnVucyhcIlNMT1dcIikgfVxyXG4gICAgICApO1xyXG4gICAgfSk7XHJcbiAgfSk7XHJcblxyXG4gIGRlc2NyaWJlKFwiUmVxdWlyZW1lbnQgdmFsaWRhdGlvblwiLCAoKSA9PiB7XHJcbiAgICBpdChcInZhbGlkYXRlcyBSZXF1aXJlbWVudCA0LjE6IE1vZGFsIG9jY3VwaWVzIDk1JSB3aWR0aCBvbiBtb2JpbGUgKDwgNjQwcHgpXCIsICgpID0+IHtcclxuICAgICAgamVzdC5zZXRUaW1lb3V0KGdldFRpbWVvdXQoXCJTTE9XXCIpKTtcclxuICAgICAgZmMuYXNzZXJ0KFxyXG4gICAgICAgIGZjLnByb3BlcnR5KFxyXG4gICAgICAgICAgZmMuaW50ZWdlcih7IG1pbjogMzIwLCBtYXg6IDYzOSB9KSwgLy8gTW9iaWxlIHZpZXdwb3J0ICg8IDY0MHB4IGFzIHBlciByZXF1aXJlbWVudClcclxuICAgICAgICAgIGZjLmNvbnN0YW50RnJvbShcInNtXCIgYXMgY29uc3QsIFwibWRcIiBhcyBjb25zdCwgXCJsZ1wiIGFzIGNvbnN0LCBcInhsXCIgYXMgY29uc3QpLFxyXG4gICAgICAgICAgKHZpZXdwb3J0V2lkdGgsIHNpemUpID0+IHtcclxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHdpbmRvdywgXCJpbm5lcldpZHRoXCIsIHtcclxuICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgdmFsdWU6IHZpZXdwb3J0V2lkdGgsXHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHdpbmRvdywgXCJtYXRjaE1lZGlhXCIsIHtcclxuICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgICB2YWx1ZTogamVzdC5mbigpLm1vY2tJbXBsZW1lbnRhdGlvbigocXVlcnkpID0+ICh7XHJcbiAgICAgICAgICAgICAgICBtYXRjaGVzOiBxdWVyeS5pbmNsdWRlcyhcIjY0MHB4XCIpID8gZmFsc2UgOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgbWVkaWE6IHF1ZXJ5LFxyXG4gICAgICAgICAgICAgICAgb25jaGFuZ2U6IG51bGwsXHJcbiAgICAgICAgICAgICAgICBhZGRMaXN0ZW5lcjogamVzdC5mbigpLFxyXG4gICAgICAgICAgICAgICAgcmVtb3ZlTGlzdGVuZXI6IGplc3QuZm4oKSxcclxuICAgICAgICAgICAgICAgIGFkZEV2ZW50TGlzdGVuZXI6IGplc3QuZm4oKSxcclxuICAgICAgICAgICAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXI6IGplc3QuZm4oKSxcclxuICAgICAgICAgICAgICAgIGRpc3BhdGNoRXZlbnQ6IGplc3QuZm4oKSxcclxuICAgICAgICAgICAgICB9KSksXHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgLy8gUmVxdWlyZW1lbnQgNC4xOiBXSEVOIHZpZXdwb3J0INC40LzQtdC10YIg0YjQuNGA0LjQvdGDINC80LXQvdC10LUgNjQwcHgsXHJcbiAgICAgICAgICAgIC8vIFRIRSDQnNC+0LTQsNC70YzQvdC+0LVf0J7QutC90L4gU0hBTEwg0LfQsNC90LjQvNCw0YLRjCA5NSUg0YjQuNGA0LjQvdGLINGN0LrRgNCw0L3QsCDRgSDQvtGC0YHRgtGD0L/QsNC80Lgg0L/QviAyLjUlXHJcbiAgICAgICAgICAgIGNvbnN0IHsgY29udGFpbmVyIH0gPSByZW5kZXIoXHJcbiAgICAgICAgICAgICAgPE1vZGFsIGlzT3Blbj17dHJ1ZX0gb25DbG9zZT17KCkgPT4ge319IHNpemU9e3NpemV9PlxyXG4gICAgICAgICAgICAgICAgPGRpdj5UZXN0IGNvbnRlbnQ8L2Rpdj5cclxuICAgICAgICAgICAgICA8L01vZGFsPlxyXG4gICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgbW9kYWxDb250ZW50ID0gZmluZE1vZGFsQ29udGVudChjb250YWluZXIpO1xyXG5cclxuICAgICAgICAgICAgaWYgKG1vZGFsQ29udGVudCkge1xyXG4gICAgICAgICAgICAgIC8vIE1vZGFsIHNob3VsZCBoYXZlIHctWzk1JV0gY2xhc3Mgd2hpY2ggZW5zdXJlcyA5NSUgd2lkdGhcclxuICAgICAgICAgICAgICAvLyB3aXRoIDIuNSUgbWFyZ2lucyBvbiBlYWNoIHNpZGUgKDEwMCUgLSA5NSUgPSA1JSAvIDIgPSAyLjUlIHBlciBzaWRlKVxyXG4gICAgICAgICAgICAgIGV4cGVjdChtb2RhbENvbnRlbnQuY2xhc3NOYW1lKS50b01hdGNoKC93LVxcWzk1JVxcXS8pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgKSxcclxuICAgICAgICB7IG51bVJ1bnM6IGdldE51bVJ1bnMoXCJNRURJVU1cIikgfVxyXG4gICAgICApO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaXQoXCJ2YWxpZGF0ZXMgdGhhdCBtb2RhbCB3aWR0aCBpcyBjb25zaXN0ZW50IGFjcm9zcyBhbGwgc2l6ZXMgb24gbW9iaWxlXCIsICgpID0+IHtcclxuICAgICAgamVzdC5zZXRUaW1lb3V0KGdldFRpbWVvdXQoXCJTTE9XXCIpKTtcclxuICAgICAgY29uc3Qgc2l6ZXM6IEFycmF5PFwic21cIiB8IFwibWRcIiB8IFwibGdcIiB8IFwieGxcIj4gPSBbXCJzbVwiLCBcIm1kXCIsIFwibGdcIiwgXCJ4bFwiXTtcclxuXHJcbiAgICAgIGZjLmFzc2VydChcclxuICAgICAgICBmYy5wcm9wZXJ0eShcclxuICAgICAgICAgIGZjLmludGVnZXIoeyBtaW46IDMyMCwgbWF4OiA2MzkgfSksXHJcbiAgICAgICAgICAodmlld3BvcnRXaWR0aCkgPT4ge1xyXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkod2luZG93LCBcImlubmVyV2lkdGhcIiwge1xyXG4gICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgICB2YWx1ZTogdmlld3BvcnRXaWR0aCxcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAvLyBBbGwgbW9kYWwgc2l6ZXMgc2hvdWxkIGhhdmUgdGhlIHNhbWUgd2lkdGggb24gbW9iaWxlICg5NSUpXHJcbiAgICAgICAgICAgIHNpemVzLmZvckVhY2goKHNpemUpID0+IHtcclxuICAgICAgICAgICAgICBjb25zdCB7IGNvbnRhaW5lciB9ID0gcmVuZGVyKFxyXG4gICAgICAgICAgICAgICAgPE1vZGFsIGlzT3Blbj17dHJ1ZX0gb25DbG9zZT17KCkgPT4ge319IHNpemU9e3NpemV9PlxyXG4gICAgICAgICAgICAgICAgICA8ZGl2PlRlc3Q8L2Rpdj5cclxuICAgICAgICAgICAgICAgIDwvTW9kYWw+XHJcbiAgICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgICAgY29uc3QgbW9kYWxDb250ZW50ID0gZmluZE1vZGFsQ29udGVudChjb250YWluZXIpO1xyXG5cclxuICAgICAgICAgICAgICBpZiAobW9kYWxDb250ZW50KSB7XHJcbiAgICAgICAgICAgICAgICBleHBlY3QobW9kYWxDb250ZW50LmNsYXNzTmFtZSkudG9NYXRjaCgvdy1cXFs5NSVcXF0vKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICksXHJcbiAgICAgICAgeyBudW1SdW5zOiBnZXROdW1SdW5zKFwiRkFTVFwiKSB9XHJcbiAgICAgICk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBpdChcInZhbGlkYXRlcyB0aGF0IG1vZGFsIHVzZXMgbWF4LXdpZHRoIGNvbnN0cmFpbnRzIG9uIGRlc2t0b3BcIiwgKCkgPT4ge1xyXG4gICAgICBqZXN0LnNldFRpbWVvdXQoZ2V0VGltZW91dChcIlNMT1dcIikpO1xyXG4gICAgICBmYy5hc3NlcnQoXHJcbiAgICAgICAgZmMucHJvcGVydHkoXHJcbiAgICAgICAgICBmYy5pbnRlZ2VyKHsgbWluOiA2NDAsIG1heDogMTQ0MCB9KSxcclxuICAgICAgICAgIGZjLmNvbnN0YW50RnJvbShcInNtXCIgYXMgY29uc3QsIFwibWRcIiBhcyBjb25zdCwgXCJsZ1wiIGFzIGNvbnN0LCBcInhsXCIgYXMgY29uc3QpLFxyXG4gICAgICAgICAgKHZpZXdwb3J0V2lkdGgsIHNpemUpID0+IHtcclxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHdpbmRvdywgXCJpbm5lcldpZHRoXCIsIHtcclxuICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgdmFsdWU6IHZpZXdwb3J0V2lkdGgsXHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgeyBjb250YWluZXIgfSA9IHJlbmRlcihcclxuICAgICAgICAgICAgICA8TW9kYWwgaXNPcGVuPXt0cnVlfSBvbkNsb3NlPXsoKSA9PiB7fX0gc2l6ZT17c2l6ZX0+XHJcbiAgICAgICAgICAgICAgICA8ZGl2PlRlc3QgY29udGVudDwvZGl2PlxyXG4gICAgICAgICAgICAgIDwvTW9kYWw+XHJcbiAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICBjb25zdCBtb2RhbENvbnRlbnQgPSBmaW5kTW9kYWxDb250ZW50KGNvbnRhaW5lcik7XHJcblxyXG4gICAgICAgICAgICBpZiAobW9kYWxDb250ZW50KSB7XHJcbiAgICAgICAgICAgICAgLy8gT24gZGVza3RvcCwgbW9kYWwgc2hvdWxkIGhhdmUgYm90aCBiYXNlIHdpZHRoIGFuZCBtYXgtd2lkdGhcclxuICAgICAgICAgICAgICBleHBlY3QobW9kYWxDb250ZW50LmNsYXNzTmFtZSkudG9NYXRjaCgvdy1cXFs5NSVcXF0vKTtcclxuICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAvLyBTaG91bGQgYWxzbyBoYXZlIHJlc3BvbnNpdmUgbWF4LXdpZHRoIGNsYXNzXHJcbiAgICAgICAgICAgICAgY29uc3QgaGFzTWF4V2lkdGggPSBcclxuICAgICAgICAgICAgICAgIG1vZGFsQ29udGVudC5jbGFzc05hbWUuaW5jbHVkZXMoXCJzbTptYXgtdy1tZFwiKSB8fFxyXG4gICAgICAgICAgICAgICAgbW9kYWxDb250ZW50LmNsYXNzTmFtZS5pbmNsdWRlcyhcInNtOm1heC13LWxnXCIpIHx8XHJcbiAgICAgICAgICAgICAgICBtb2RhbENvbnRlbnQuY2xhc3NOYW1lLmluY2x1ZGVzKFwic206bWF4LXctMnhsXCIpIHx8XHJcbiAgICAgICAgICAgICAgICBtb2RhbENvbnRlbnQuY2xhc3NOYW1lLmluY2x1ZGVzKFwic206bWF4LXctNHhsXCIpO1xyXG4gICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgIGV4cGVjdChoYXNNYXhXaWR0aCkudG9CZSh0cnVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICksXHJcbiAgICAgICAgeyBudW1SdW5zOiBnZXROdW1SdW5zKFwiTUVESVVNXCIpIH1cclxuICAgICAgKTtcclxuICAgIH0pO1xyXG4gIH0pO1xyXG5cclxuICBkZXNjcmliZShcIkdlbmVyYWwgcHJvcGVydHkgdmFsaWRhdGlvblwiLCAoKSA9PiB7XHJcbiAgICBpdChcInNob3VsZCB2ZXJpZnkgbW9kYWwgd2lkdGggYWRhcHRzIGNvcnJlY3RseSBhY3Jvc3MgYWxsIHZpZXdwb3J0IHNpemVzXCIsICgpID0+IHtcclxuICAgICAgamVzdC5zZXRUaW1lb3V0KGdldFRpbWVvdXQoXCJTTE9XXCIpKTtcclxuICAgICAgZmMuYXNzZXJ0KFxyXG4gICAgICAgIGZjLnByb3BlcnR5KFxyXG4gICAgICAgICAgZmMuaW50ZWdlcih7IG1pbjogMzIwLCBtYXg6IDE0NDAgfSksXHJcbiAgICAgICAgICBmYy5jb25zdGFudEZyb20oXCJzbVwiIGFzIGNvbnN0LCBcIm1kXCIgYXMgY29uc3QsIFwibGdcIiBhcyBjb25zdCwgXCJ4bFwiIGFzIGNvbnN0KSxcclxuICAgICAgICAgICh2aWV3cG9ydFdpZHRoLCBzaXplKSA9PiB7XHJcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3aW5kb3csIFwiaW5uZXJXaWR0aFwiLCB7XHJcbiAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICAgIHZhbHVlOiB2aWV3cG9ydFdpZHRoLFxyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IHsgY29udGFpbmVyIH0gPSByZW5kZXIoXHJcbiAgICAgICAgICAgICAgPE1vZGFsIGlzT3Blbj17dHJ1ZX0gb25DbG9zZT17KCkgPT4ge319IHNpemU9e3NpemV9PlxyXG4gICAgICAgICAgICAgICAgPGRpdj5UZXN0IGNvbnRlbnQ8L2Rpdj5cclxuICAgICAgICAgICAgICA8L01vZGFsPlxyXG4gICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgbW9kYWxDb250ZW50ID0gZmluZE1vZGFsQ29udGVudChjb250YWluZXIpO1xyXG5cclxuICAgICAgICAgICAgaWYgKG1vZGFsQ29udGVudCkge1xyXG4gICAgICAgICAgICAgIC8vIEFsbCBtb2RhbHMgc2hvdWxkIGhhdmUgYmFzZSB3LVs5NSVdIGNsYXNzXHJcbiAgICAgICAgICAgICAgZXhwZWN0KG1vZGFsQ29udGVudC5jbGFzc05hbWUpLnRvTWF0Y2goL3ctXFxbOTUlXFxdLyk7XHJcbiAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgLy8gQWxsIG1vZGFscyBzaG91bGQgaGF2ZSByZXNwb25zaXZlIG1heC13aWR0aCBjbGFzc1xyXG4gICAgICAgICAgICAgIGNvbnN0IGhhc1Jlc3BvbnNpdmVDbGFzcyA9IFxyXG4gICAgICAgICAgICAgICAgbW9kYWxDb250ZW50LmNsYXNzTmFtZS5pbmNsdWRlcyhcInNtOm1heC13LVwiKTtcclxuICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICBleHBlY3QoaGFzUmVzcG9uc2l2ZUNsYXNzKS50b0JlKHRydWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgKSxcclxuICAgICAgICB7IG51bVJ1bnM6IGdldE51bVJ1bnMoXCJNRURJVU1cIikgfVxyXG4gICAgICApO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaXQoXCJzaG91bGQgZW5zdXJlIG1vZGFsIGZvbGxvd3MgbW9iaWxlLWZpcnN0IHJlc3BvbnNpdmUgZGVzaWduXCIsICgpID0+IHtcclxuICAgICAgamVzdC5zZXRUaW1lb3V0KGdldFRpbWVvdXQoXCJTTE9XXCIpKTtcclxuICAgICAgZmMuYXNzZXJ0KFxyXG4gICAgICAgIGZjLnByb3BlcnR5KFxyXG4gICAgICAgICAgZmMuY29uc3RhbnRGcm9tKFwic21cIiBhcyBjb25zdCwgXCJtZFwiIGFzIGNvbnN0LCBcImxnXCIgYXMgY29uc3QsIFwieGxcIiBhcyBjb25zdCksXHJcbiAgICAgICAgICAoc2l6ZSkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCB7IGNvbnRhaW5lciB9ID0gcmVuZGVyKFxyXG4gICAgICAgICAgICAgIDxNb2RhbCBpc09wZW49e3RydWV9IG9uQ2xvc2U9eygpID0+IHt9fSBzaXplPXtzaXplfT5cclxuICAgICAgICAgICAgICAgIDxkaXY+VGVzdCBjb250ZW50PC9kaXY+XHJcbiAgICAgICAgICAgICAgPC9Nb2RhbD5cclxuICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IG1vZGFsQ29udGVudCA9IGZpbmRNb2RhbENvbnRlbnQoY29udGFpbmVyKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChtb2RhbENvbnRlbnQpIHtcclxuICAgICAgICAgICAgICBjb25zdCBjbGFzc2VzID0gbW9kYWxDb250ZW50LmNsYXNzTmFtZTtcclxuICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAvLyBNb2JpbGUtZmlyc3Q6IGJhc2UgY2xhc3MgKHctWzk1JV0pIHNob3VsZCBhbHdheXMgYmUgcHJlc2VudFxyXG4gICAgICAgICAgICAgIGV4cGVjdChjbGFzc2VzKS50b01hdGNoKC93LVxcWzk1JVxcXS8pO1xyXG4gICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgIC8vIFJlc3BvbnNpdmUgY2xhc3NlcyBzaG91bGQgYmUgcHJlZml4ZWQgd2l0aCBzbTpcclxuICAgICAgICAgICAgICBleHBlY3QoY2xhc3NlcykudG9NYXRjaCgvc206bWF4LXctLyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICApLFxyXG4gICAgICAgIHsgbnVtUnVuczogZ2V0TnVtUnVucyhcIkZBU1RcIikgfVxyXG4gICAgICApO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaXQoXCJzaG91bGQgdmVyaWZ5IG1vZGFsIHdpZHRoIGNsYXNzZXMgYXJlIGFwcGxpZWQgY29uc2lzdGVudGx5XCIsICgpID0+IHtcclxuICAgICAgamVzdC5zZXRUaW1lb3V0KGdldFRpbWVvdXQoXCJTTE9XXCIpKTtcclxuICAgICAgY29uc3QgdGVzdENhc2VzID0gW1xyXG4gICAgICAgIHsgdmlld3BvcnQ6IDMyMCwgc2l6ZTogXCJzbVwiIGFzIGNvbnN0LCBleHBlY3RNb2JpbGU6IHRydWUgfSxcclxuICAgICAgICB7IHZpZXdwb3J0OiA0ODAsIHNpemU6IFwibWRcIiBhcyBjb25zdCwgZXhwZWN0TW9iaWxlOiB0cnVlIH0sXHJcbiAgICAgICAgeyB2aWV3cG9ydDogNjM5LCBzaXplOiBcImxnXCIgYXMgY29uc3QsIGV4cGVjdE1vYmlsZTogdHJ1ZSB9LFxyXG4gICAgICAgIHsgdmlld3BvcnQ6IDY0MCwgc2l6ZTogXCJ4bFwiIGFzIGNvbnN0LCBleHBlY3RNb2JpbGU6IGZhbHNlIH0sXHJcbiAgICAgICAgeyB2aWV3cG9ydDogNzY4LCBzaXplOiBcInNtXCIgYXMgY29uc3QsIGV4cGVjdE1vYmlsZTogZmFsc2UgfSxcclxuICAgICAgICB7IHZpZXdwb3J0OiAxMDI0LCBzaXplOiBcIm1kXCIgYXMgY29uc3QsIGV4cGVjdE1vYmlsZTogZmFsc2UgfSxcclxuICAgICAgICB7IHZpZXdwb3J0OiAxNDQwLCBzaXplOiBcImxnXCIgYXMgY29uc3QsIGV4cGVjdE1vYmlsZTogZmFsc2UgfSxcclxuICAgICAgXTtcclxuXHJcbiAgICAgIHRlc3RDYXNlcy5mb3JFYWNoKCh7IHZpZXdwb3J0LCBzaXplLCBleHBlY3RNb2JpbGUgfSkgPT4ge1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3aW5kb3csIFwiaW5uZXJXaWR0aFwiLCB7XHJcbiAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgIHZhbHVlOiB2aWV3cG9ydCxcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgY29uc3QgeyBjb250YWluZXIgfSA9IHJlbmRlcihcclxuICAgICAgICAgIDxNb2RhbCBpc09wZW49e3RydWV9IG9uQ2xvc2U9eygpID0+IHt9fSBzaXplPXtzaXplfT5cclxuICAgICAgICAgICAgPGRpdj5UZXN0PC9kaXY+XHJcbiAgICAgICAgICA8L01vZGFsPlxyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIGNvbnN0IG1vZGFsQ29udGVudCA9IGZpbmRNb2RhbENvbnRlbnQoY29udGFpbmVyKTtcclxuXHJcbiAgICAgICAgaWYgKG1vZGFsQ29udGVudCkge1xyXG4gICAgICAgICAgLy8gQWxsIHNob3VsZCBoYXZlIHctWzk1JV1cclxuICAgICAgICAgIGV4cGVjdChtb2RhbENvbnRlbnQuY2xhc3NOYW1lKS50b01hdGNoKC93LVxcWzk1JVxcXS8pO1xyXG4gICAgICAgICAgXHJcbiAgICAgICAgICAvLyBBbGwgc2hvdWxkIGhhdmUgcmVzcG9uc2l2ZSBtYXgtd2lkdGhcclxuICAgICAgICAgIGV4cGVjdChtb2RhbENvbnRlbnQuY2xhc3NOYW1lKS50b01hdGNoKC9zbTptYXgtdy0vKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfSk7XHJcbiAgfSk7XHJcbn0pO1xyXG4iXSwibmFtZXMiOlsiTU9CSUxFX0JSRUFLUE9JTlQiLCJNT0JJTEVfV0lEVEhfUEVSQ0VOVEFHRSIsImdldEVsZW1lbnRXaWR0aCIsImVsZW1lbnQiLCJyZWN0IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0Iiwid2lkdGgiLCJmaW5kTW9kYWxDb250ZW50IiwiY29udGFpbmVyIiwic2VsZWN0b3JzIiwic2VsZWN0b3IiLCJxdWVyeVNlbGVjdG9yIiwiZGVzY3JpYmUiLCJpdCIsImplc3QiLCJzZXRUaW1lb3V0IiwiZ2V0VGltZW91dCIsImZjIiwiYXNzZXJ0IiwicHJvcGVydHkiLCJpbnRlZ2VyIiwibWluIiwibWF4IiwiY29uc3RhbnRGcm9tIiwic3RyaW5nIiwibWluTGVuZ3RoIiwibWF4TGVuZ3RoIiwidmlld3BvcnRXaWR0aCIsInNpemUiLCJjb250ZW50IiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJ3aW5kb3ciLCJ3cml0YWJsZSIsImNvbmZpZ3VyYWJsZSIsInZhbHVlIiwiZm4iLCJtb2NrSW1wbGVtZW50YXRpb24iLCJxdWVyeSIsIm1hdGNoZXMiLCJpbmNsdWRlcyIsIm1lZGlhIiwib25jaGFuZ2UiLCJhZGRMaXN0ZW5lciIsInJlbW92ZUxpc3RlbmVyIiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJkaXNwYXRjaEV2ZW50IiwicmVuZGVyIiwiTW9kYWwiLCJpc09wZW4iLCJvbkNsb3NlIiwiZGl2IiwibW9kYWxDb250ZW50IiwiZXhwZWN0IiwiY2xhc3NOYW1lIiwidG9NYXRjaCIsIm51bVJ1bnMiLCJnZXROdW1SdW5zIiwic2l6ZXMiLCJleHBlY3RlZE1heFdpZHRoIiwic20iLCJtZCIsImxnIiwieGwiLCJSZWdFeHAiLCJyZXBsYWNlIiwic2l6ZVRvTWF4V2lkdGgiLCJrZXlzIiwiZm9yRWFjaCIsImV4cGVjdGVkQ2xhc3MiLCJsb25nQ29udGVudCIsImFycmF5IiwiaXRlbXMiLCJoMiIsInVsIiwibWFwIiwiaXRlbSIsImluZGV4IiwibGkiLCJ0aXRsZSIsImhhc01heFdpZHRoIiwidG9CZSIsImhhc1Jlc3BvbnNpdmVDbGFzcyIsImNsYXNzZXMiLCJ0ZXN0Q2FzZXMiLCJ2aWV3cG9ydCIsImV4cGVjdE1vYmlsZSJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7OztDQVNDOzs7Ozs4REFFaUI7d0JBQ0s7a0VBQ1I7dUJBQ087b0NBQ2lCOzs7Ozs7QUFFdkMscUNBQXFDO0FBQ3JDLE1BQU1BLG9CQUFvQjtBQUUxQixtQ0FBbUM7QUFDbkMsTUFBTUMsMEJBQTBCO0FBRWhDLHNEQUFzRDtBQUN0RCxNQUFNQyxrQkFBa0IsQ0FBQ0M7SUFDdkIsTUFBTUMsT0FBT0QsUUFBUUUscUJBQXFCO0lBQzFDLE9BQU9ELEtBQUtFLEtBQUs7QUFDbkI7QUFFQSxtREFBbUQ7QUFDbkQsTUFBTUMsbUJBQW1CLENBQUNDO0lBQ3hCLGtEQUFrRDtJQUNsRCxzREFBc0Q7SUFDdEQsTUFBTUMsWUFBWTtRQUNoQjtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7S0FDRDtJQUVELEtBQUssTUFBTUMsWUFBWUQsVUFBVztRQUNoQyxNQUFNTixVQUFVSyxVQUFVRyxhQUFhLENBQUNEO1FBQ3hDLElBQUlQLFNBQVMsT0FBT0E7SUFDdEI7SUFFQSxPQUFPO0FBQ1Q7QUFFQVMsU0FBUyxnQ0FBZ0M7SUFDdkNBLFNBQVMsbUNBQW1DO1FBQzFDQyxHQUFHLHVEQUF1RDtZQUN4REMsS0FBS0MsVUFBVSxDQUFDQyxJQUFBQSw4QkFBVSxFQUFDO1lBQzNCQyxrQkFBRSxDQUFDQyxNQUFN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