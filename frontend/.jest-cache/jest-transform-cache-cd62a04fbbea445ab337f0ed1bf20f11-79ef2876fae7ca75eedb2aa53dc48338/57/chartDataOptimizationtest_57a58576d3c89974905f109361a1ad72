14a3647f9144bcfe205d4d611103af65
/**
 * Unit tests for chart data optimization utilities
 * 
 * Tests the sampling and aggregation functions for optimizing chart data points
 * on mobile devices.
 * 
 * Требование 10.2: Оптимизация количества отрисовываемых точек данных
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _chartDataOptimization = require("../../src/lib/chartDataOptimization");
describe("chartDataOptimization", ()=>{
    describe("sampleDataPoints", ()=>{
        it("should return original data when length is less than maxPoints", ()=>{
            const data = [
                {
                    date: "2024-01-01",
                    amount: 100
                },
                {
                    date: "2024-01-02",
                    amount: 150
                },
                {
                    date: "2024-01-03",
                    amount: 120
                }
            ];
            const result = (0, _chartDataOptimization.sampleDataPoints)(data, 10);
            expect(result).toEqual(data);
            expect(result.length).toBe(3);
        });
        it("should return empty array when data is empty", ()=>{
            const result = (0, _chartDataOptimization.sampleDataPoints)([], 10);
            expect(result).toEqual([]);
        });
        it("should sample data points evenly when length exceeds maxPoints", ()=>{
            const data = Array.from({
                length: 100
            }, (_, i)=>({
                    date: `2024-01-${String(i + 1).padStart(2, "0")}`,
                    amount: i * 10
                }));
            const result = (0, _chartDataOptimization.sampleDataPoints)(data, 20);
            expect(result.length).toBe(20);
            // Should include first point
            expect(result[0]).toEqual(data[0]);
            // Should include last point
            expect(result[result.length - 1]).toEqual(data[data.length - 1]);
        });
        it("should maintain chronological order", ()=>{
            const data = Array.from({
                length: 50
            }, (_, i)=>({
                    date: `2024-01-${String(i + 1).padStart(2, "0")}`,
                    amount: i * 10
                }));
            const result = (0, _chartDataOptimization.sampleDataPoints)(data, 10);
            // Check that dates are in order
            for(let i = 1; i < result.length; i++){
                expect(result[i].date >= result[i - 1].date).toBe(true);
            }
        });
    });
    describe("aggregateDataPoints", ()=>{
        it("should return original data when length is less than maxPoints", ()=>{
            const data = [
                {
                    date: "2024-01-01",
                    amount: 100
                },
                {
                    date: "2024-01-02",
                    amount: 150
                }
            ];
            const result = (0, _chartDataOptimization.aggregateDataPoints)(data, 10);
            expect(result).toEqual(data);
        });
        it("should aggregate data points by averaging", ()=>{
            const data = [
                {
                    date: "2024-01-01",
                    amount: 100
                },
                {
                    date: "2024-01-02",
                    amount: 200
                },
                {
                    date: "2024-01-03",
                    amount: 150
                },
                {
                    date: "2024-01-04",
                    amount: 250
                }
            ];
            const result = (0, _chartDataOptimization.aggregateDataPoints)(data, 2);
            expect(result.length).toBe(2);
            // First bucket: average of 100 and 200 = 150
            expect(result[0].amount).toBe(150);
            expect(result[0].date).toBe("2024-01-01");
            // Second bucket: average of 150 and 250 = 200
            expect(result[1].amount).toBe(200);
            expect(result[1].date).toBe("2024-01-03");
        });
        it("should round aggregated amounts to 2 decimal places", ()=>{
            const data = [
                {
                    date: "2024-01-01",
                    amount: 100.333
                },
                {
                    date: "2024-01-02",
                    amount: 200.666
                },
                {
                    date: "2024-01-03",
                    amount: 150.111
                }
            ];
            const result = (0, _chartDataOptimization.aggregateDataPoints)(data, 1);
            expect(result.length).toBe(1);
            // Average: (100.333 + 200.666 + 150.111) / 3 = 150.37
            expect(result[0].amount).toBe(150.37);
        });
    });
    describe("optimizeChartData", ()=>{
        it("should not optimize when data length is below threshold (50)", ()=>{
            const data = Array.from({
                length: 40
            }, (_, i)=>({
                    date: `2024-01-${String(i + 1).padStart(2, "0")}`,
                    amount: i * 10
                }));
            const result = (0, _chartDataOptimization.optimizeChartData)(data, true, false);
            expect(result).toEqual(data);
            expect(result.length).toBe(40);
        });
        it("should optimize to 20 points on mobile when data exceeds threshold", ()=>{
            const data = Array.from({
                length: 100
            }, (_, i)=>({
                    date: `2024-01-${String(i + 1).padStart(2, "0")}`,
                    amount: i * 10
                }));
            const result = (0, _chartDataOptimization.optimizeChartData)(data, true, false); // isMobile = true
            expect(result.length).toBe(20);
        });
        it("should optimize to 40 points on tablet when data exceeds threshold", ()=>{
            const data = Array.from({
                length: 100
            }, (_, i)=>({
                    date: `2024-01-${String(i + 1).padStart(2, "0")}`,
                    amount: i * 10
                }));
            const result = (0, _chartDataOptimization.optimizeChartData)(data, false, true); // isTablet = true
            expect(result.length).toBe(40);
        });
        it("should not optimize on desktop when data is below 100 points", ()=>{
            const data = Array.from({
                length: 80
            }, (_, i)=>({
                    date: `2024-01-${String(i + 1).padStart(2, "0")}`,
                    amount: i * 10
                }));
            const result = (0, _chartDataOptimization.optimizeChartData)(data, false, false); // desktop
            expect(result).toEqual(data);
            expect(result.length).toBe(80);
        });
        it("should use aggregation when useAggregation is true", ()=>{
            const data = Array.from({
                length: 100
            }, (_, i)=>({
                    date: `2024-01-${String(i + 1).padStart(2, "0")}`,
                    amount: i * 10
                }));
            const sampledResult = (0, _chartDataOptimization.optimizeChartData)(data, true, false, false);
            const aggregatedResult = (0, _chartDataOptimization.optimizeChartData)(data, true, false, true);
            // Both should have same length
            expect(sampledResult.length).toBe(20);
            expect(aggregatedResult.length).toBe(20);
            // But different values (aggregation averages, sampling picks specific points)
            expect(sampledResult[1].amount).not.toBe(aggregatedResult[1].amount);
        });
    });
    describe("optimizeGenericData", ()=>{
        it("should optimize generic data structures", ()=>{
            const data = Array.from({
                length: 100
            }, (_, i)=>({
                    name: `Category ${i}`,
                    value: i * 10
                }));
            const result = (0, _chartDataOptimization.optimizeGenericData)(data, true, false); // mobile
            expect(result.length).toBe(20);
            expect(result[0].name).toBe("Category 0");
            expect(result[result.length - 1].name).toBe("Category 99");
        });
        it("should not optimize when data is below threshold", ()=>{
            const data = Array.from({
                length: 30
            }, (_, i)=>({
                    name: `Category ${i}`,
                    value: i * 10
                }));
            const result = (0, _chartDataOptimization.optimizeGenericData)(data, true, false);
            expect(result).toEqual(data);
        });
        it("should work with different data types", ()=>{
            const data = Array.from({
                length: 100
            }, (_, i)=>({
                    id: `id-${i}`,
                    nested: {
                        value: i
                    },
                    array: [
                        i,
                        i * 2
                    ]
                }));
            const result = (0, _chartDataOptimization.optimizeGenericData)(data, true, false);
            expect(result.length).toBe(20);
            expect(result[0].id).toBe("id-0");
            expect(result[0].nested.value).toBe(0);
        });
    });
    describe("shouldOptimizeData", ()=>{
        it("should return false when data length is below threshold", ()=>{
            expect((0, _chartDataOptimization.shouldOptimizeData)(30, true, false)).toBe(false);
            expect((0, _chartDataOptimization.shouldOptimizeData)(50, true, false)).toBe(false);
        });
        it("should return true on mobile when data exceeds mobile max (20)", ()=>{
            expect((0, _chartDataOptimization.shouldOptimizeData)(60, true, false)).toBe(true);
            expect((0, _chartDataOptimization.shouldOptimizeData)(100, true, false)).toBe(true);
        });
        it("should return true on tablet when data exceeds tablet max (40)", ()=>{
            expect((0, _chartDataOptimization.shouldOptimizeData)(60, false, true)).toBe(true);
            expect((0, _chartDataOptimization.shouldOptimizeData)(100, false, true)).toBe(true);
        });
        it("should return false on tablet when data is below tablet max", ()=>{
            // 55 points is above threshold (50) but above tablet max (40), so it should optimize
            expect((0, _chartDataOptimization.shouldOptimizeData)(55, false, true)).toBe(true);
            // 35 points is below threshold, so no optimization
            expect((0, _chartDataOptimization.shouldOptimizeData)(35, false, true)).toBe(false);
        });
        it("should return true on desktop when data exceeds desktop max (100)", ()=>{
            expect((0, _chartDataOptimization.shouldOptimizeData)(150, false, false)).toBe(true);
        });
        it("should return false on desktop when data is below desktop max", ()=>{
            expect((0, _chartDataOptimization.shouldOptimizeData)(80, false, false)).toBe(false);
        });
    });
    describe("edge cases", ()=>{
        it("should handle null/undefined data gracefully", ()=>{
            expect((0, _chartDataOptimization.sampleDataPoints)(null, 10)).toEqual(null);
            expect((0, _chartDataOptimization.aggregateDataPoints)(undefined, 10)).toEqual(undefined);
            expect((0, _chartDataOptimization.optimizeChartData)(null, true, false)).toEqual(null);
        });
        it("should handle single data point", ()=>{
            const data = [
                {
                    date: "2024-01-01",
                    amount: 100
                }
            ];
            expect((0, _chartDataOptimization.sampleDataPoints)(data, 10)).toEqual(data);
            expect((0, _chartDataOptimization.aggregateDataPoints)(data, 10)).toEqual(data);
            expect((0, _chartDataOptimization.optimizeChartData)(data, true, false)).toEqual(data);
        });
        it("should handle maxPoints of 2", ()=>{
            const data = [
                {
                    date: "2024-01-01",
                    amount: 100
                },
                {
                    date: "2024-01-02",
                    amount: 200
                },
                {
                    date: "2024-01-03",
                    amount: 300
                }
            ];
            const result = (0, _chartDataOptimization.sampleDataPoints)(data, 2);
            expect(result.length).toBe(2);
            // Should include first and last
            expect(result[0]).toEqual(data[0]);
            expect(result[1]).toEqual(data[2]);
        });
        it("should handle data with negative amounts", ()=>{
            const data = [
                {
                    date: "2024-01-01",
                    amount: -100
                },
                {
                    date: "2024-01-02",
                    amount: -200
                },
                {
                    date: "2024-01-03",
                    amount: 150
                },
                {
                    date: "2024-01-04",
                    amount: -50
                }
            ];
            const result = (0, _chartDataOptimization.aggregateDataPoints)(data, 2);
            expect(result.length).toBe(2);
            // First bucket: (-100 + -200) / 2 = -150
            expect(result[0].amount).toBe(-150);
        });
        it("should handle data with zero amounts", ()=>{
            const data = Array.from({
                length: 100
            }, (_, i)=>({
                    date: `2024-01-${String(i + 1).padStart(2, "0")}`,
                    amount: 0
                }));
            const result = (0, _chartDataOptimization.optimizeChartData)(data, true, false);
            expect(result.length).toBe(20);
            expect(result.every((point)=>point.amount === 0)).toBe(true);
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkU6XFxteVxcb3R1c1xcZmluYW5jZV90cmFja2VyXFxmcm9udGVuZFxcX190ZXN0c19fXFxsaWJcXGNoYXJ0RGF0YU9wdGltaXphdGlvbi50ZXN0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBVbml0IHRlc3RzIGZvciBjaGFydCBkYXRhIG9wdGltaXphdGlvbiB1dGlsaXRpZXNcclxuICogXHJcbiAqIFRlc3RzIHRoZSBzYW1wbGluZyBhbmQgYWdncmVnYXRpb24gZnVuY3Rpb25zIGZvciBvcHRpbWl6aW5nIGNoYXJ0IGRhdGEgcG9pbnRzXHJcbiAqIG9uIG1vYmlsZSBkZXZpY2VzLlxyXG4gKiBcclxuICog0KLRgNC10LHQvtCy0LDQvdC40LUgMTAuMjog0J7Qv9GC0LjQvNC40LfQsNGG0LjRjyDQutC+0LvQuNGH0LXRgdGC0LLQsCDQvtGC0YDQuNGB0L7QstGL0LLQsNC10LzRi9GFINGC0L7Rh9C10Log0LTQsNC90L3Ri9GFXHJcbiAqL1xyXG5cclxuaW1wb3J0IHtcclxuICBzYW1wbGVEYXRhUG9pbnRzLFxyXG4gIGFnZ3JlZ2F0ZURhdGFQb2ludHMsXHJcbiAgb3B0aW1pemVDaGFydERhdGEsXHJcbiAgb3B0aW1pemVHZW5lcmljRGF0YSxcclxuICBzaG91bGRPcHRpbWl6ZURhdGEsXHJcbiAgdHlwZSBEYXRhUG9pbnQsXHJcbn0gZnJvbSAnQC9saWIvY2hhcnREYXRhT3B0aW1pemF0aW9uJztcclxuXHJcbmRlc2NyaWJlKCdjaGFydERhdGFPcHRpbWl6YXRpb24nLCAoKSA9PiB7XHJcbiAgZGVzY3JpYmUoJ3NhbXBsZURhdGFQb2ludHMnLCAoKSA9PiB7XHJcbiAgICBpdCgnc2hvdWxkIHJldHVybiBvcmlnaW5hbCBkYXRhIHdoZW4gbGVuZ3RoIGlzIGxlc3MgdGhhbiBtYXhQb2ludHMnLCAoKSA9PiB7XHJcbiAgICAgIGNvbnN0IGRhdGE6IERhdGFQb2ludFtdID0gW1xyXG4gICAgICAgIHsgZGF0ZTogJzIwMjQtMDEtMDEnLCBhbW91bnQ6IDEwMCB9LFxyXG4gICAgICAgIHsgZGF0ZTogJzIwMjQtMDEtMDInLCBhbW91bnQ6IDE1MCB9LFxyXG4gICAgICAgIHsgZGF0ZTogJzIwMjQtMDEtMDMnLCBhbW91bnQ6IDEyMCB9LFxyXG4gICAgICBdO1xyXG5cclxuICAgICAgY29uc3QgcmVzdWx0ID0gc2FtcGxlRGF0YVBvaW50cyhkYXRhLCAxMCk7XHJcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwoZGF0YSk7XHJcbiAgICAgIGV4cGVjdChyZXN1bHQubGVuZ3RoKS50b0JlKDMpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gZW1wdHkgYXJyYXkgd2hlbiBkYXRhIGlzIGVtcHR5JywgKCkgPT4ge1xyXG4gICAgICBjb25zdCByZXN1bHQgPSBzYW1wbGVEYXRhUG9pbnRzKFtdLCAxMCk7XHJcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwoW10pO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaXQoJ3Nob3VsZCBzYW1wbGUgZGF0YSBwb2ludHMgZXZlbmx5IHdoZW4gbGVuZ3RoIGV4Y2VlZHMgbWF4UG9pbnRzJywgKCkgPT4ge1xyXG4gICAgICBjb25zdCBkYXRhOiBEYXRhUG9pbnRbXSA9IEFycmF5LmZyb20oeyBsZW5ndGg6IDEwMCB9LCAoXywgaSkgPT4gKHtcclxuICAgICAgICBkYXRlOiBgMjAyNC0wMS0ke1N0cmluZyhpICsgMSkucGFkU3RhcnQoMiwgJzAnKX1gLFxyXG4gICAgICAgIGFtb3VudDogaSAqIDEwLFxyXG4gICAgICB9KSk7XHJcblxyXG4gICAgICBjb25zdCByZXN1bHQgPSBzYW1wbGVEYXRhUG9pbnRzKGRhdGEsIDIwKTtcclxuICAgICAgXHJcbiAgICAgIGV4cGVjdChyZXN1bHQubGVuZ3RoKS50b0JlKDIwKTtcclxuICAgICAgLy8gU2hvdWxkIGluY2x1ZGUgZmlyc3QgcG9pbnRcclxuICAgICAgZXhwZWN0KHJlc3VsdFswXSkudG9FcXVhbChkYXRhWzBdKTtcclxuICAgICAgLy8gU2hvdWxkIGluY2x1ZGUgbGFzdCBwb2ludFxyXG4gICAgICBleHBlY3QocmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXSkudG9FcXVhbChkYXRhW2RhdGEubGVuZ3RoIC0gMV0pO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaXQoJ3Nob3VsZCBtYWludGFpbiBjaHJvbm9sb2dpY2FsIG9yZGVyJywgKCkgPT4ge1xyXG4gICAgICBjb25zdCBkYXRhOiBEYXRhUG9pbnRbXSA9IEFycmF5LmZyb20oeyBsZW5ndGg6IDUwIH0sIChfLCBpKSA9PiAoe1xyXG4gICAgICAgIGRhdGU6IGAyMDI0LTAxLSR7U3RyaW5nKGkgKyAxKS5wYWRTdGFydCgyLCAnMCcpfWAsXHJcbiAgICAgICAgYW1vdW50OiBpICogMTAsXHJcbiAgICAgIH0pKTtcclxuXHJcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHNhbXBsZURhdGFQb2ludHMoZGF0YSwgMTApO1xyXG4gICAgICBcclxuICAgICAgLy8gQ2hlY2sgdGhhdCBkYXRlcyBhcmUgaW4gb3JkZXJcclxuICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCByZXN1bHQubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBleHBlY3QocmVzdWx0W2ldLmRhdGUgPj0gcmVzdWx0W2kgLSAxXS5kYXRlKS50b0JlKHRydWUpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9KTtcclxuXHJcbiAgZGVzY3JpYmUoJ2FnZ3JlZ2F0ZURhdGFQb2ludHMnLCAoKSA9PiB7XHJcbiAgICBpdCgnc2hvdWxkIHJldHVybiBvcmlnaW5hbCBkYXRhIHdoZW4gbGVuZ3RoIGlzIGxlc3MgdGhhbiBtYXhQb2ludHMnLCAoKSA9PiB7XHJcbiAgICAgIGNvbnN0IGRhdGE6IERhdGFQb2ludFtdID0gW1xyXG4gICAgICAgIHsgZGF0ZTogJzIwMjQtMDEtMDEnLCBhbW91bnQ6IDEwMCB9LFxyXG4gICAgICAgIHsgZGF0ZTogJzIwMjQtMDEtMDInLCBhbW91bnQ6IDE1MCB9LFxyXG4gICAgICBdO1xyXG5cclxuICAgICAgY29uc3QgcmVzdWx0ID0gYWdncmVnYXRlRGF0YVBvaW50cyhkYXRhLCAxMCk7XHJcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwoZGF0YSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBpdCgnc2hvdWxkIGFnZ3JlZ2F0ZSBkYXRhIHBvaW50cyBieSBhdmVyYWdpbmcnLCAoKSA9PiB7XHJcbiAgICAgIGNvbnN0IGRhdGE6IERhdGFQb2ludFtdID0gW1xyXG4gICAgICAgIHsgZGF0ZTogJzIwMjQtMDEtMDEnLCBhbW91bnQ6IDEwMCB9LFxyXG4gICAgICAgIHsgZGF0ZTogJzIwMjQtMDEtMDInLCBhbW91bnQ6IDIwMCB9LFxyXG4gICAgICAgIHsgZGF0ZTogJzIwMjQtMDEtMDMnLCBhbW91bnQ6IDE1MCB9LFxyXG4gICAgICAgIHsgZGF0ZTogJzIwMjQtMDEtMDQnLCBhbW91bnQ6IDI1MCB9LFxyXG4gICAgICBdO1xyXG5cclxuICAgICAgY29uc3QgcmVzdWx0ID0gYWdncmVnYXRlRGF0YVBvaW50cyhkYXRhLCAyKTtcclxuICAgICAgXHJcbiAgICAgIGV4cGVjdChyZXN1bHQubGVuZ3RoKS50b0JlKDIpO1xyXG4gICAgICAvLyBGaXJzdCBidWNrZXQ6IGF2ZXJhZ2Ugb2YgMTAwIGFuZCAyMDAgPSAxNTBcclxuICAgICAgZXhwZWN0KHJlc3VsdFswXS5hbW91bnQpLnRvQmUoMTUwKTtcclxuICAgICAgZXhwZWN0KHJlc3VsdFswXS5kYXRlKS50b0JlKCcyMDI0LTAxLTAxJyk7XHJcbiAgICAgIC8vIFNlY29uZCBidWNrZXQ6IGF2ZXJhZ2Ugb2YgMTUwIGFuZCAyNTAgPSAyMDBcclxuICAgICAgZXhwZWN0KHJlc3VsdFsxXS5hbW91bnQpLnRvQmUoMjAwKTtcclxuICAgICAgZXhwZWN0KHJlc3VsdFsxXS5kYXRlKS50b0JlKCcyMDI0LTAxLTAzJyk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBpdCgnc2hvdWxkIHJvdW5kIGFnZ3JlZ2F0ZWQgYW1vdW50cyB0byAyIGRlY2ltYWwgcGxhY2VzJywgKCkgPT4ge1xyXG4gICAgICBjb25zdCBkYXRhOiBEYXRhUG9pbnRbXSA9IFtcclxuICAgICAgICB7IGRhdGU6ICcyMDI0LTAxLTAxJywgYW1vdW50OiAxMDAuMzMzIH0sXHJcbiAgICAgICAgeyBkYXRlOiAnMjAyNC0wMS0wMicsIGFtb3VudDogMjAwLjY2NiB9LFxyXG4gICAgICAgIHsgZGF0ZTogJzIwMjQtMDEtMDMnLCBhbW91bnQ6IDE1MC4xMTEgfSxcclxuICAgICAgXTtcclxuXHJcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGFnZ3JlZ2F0ZURhdGFQb2ludHMoZGF0YSwgMSk7XHJcbiAgICAgIFxyXG4gICAgICBleHBlY3QocmVzdWx0Lmxlbmd0aCkudG9CZSgxKTtcclxuICAgICAgLy8gQXZlcmFnZTogKDEwMC4zMzMgKyAyMDAuNjY2ICsgMTUwLjExMSkgLyAzID0gMTUwLjM3XHJcbiAgICAgIGV4cGVjdChyZXN1bHRbMF0uYW1vdW50KS50b0JlKDE1MC4zNyk7XHJcbiAgICB9KTtcclxuICB9KTtcclxuXHJcbiAgZGVzY3JpYmUoJ29wdGltaXplQ2hhcnREYXRhJywgKCkgPT4ge1xyXG4gICAgaXQoJ3Nob3VsZCBub3Qgb3B0aW1pemUgd2hlbiBkYXRhIGxlbmd0aCBpcyBiZWxvdyB0aHJlc2hvbGQgKDUwKScsICgpID0+IHtcclxuICAgICAgY29uc3QgZGF0YTogRGF0YVBvaW50W10gPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiA0MCB9LCAoXywgaSkgPT4gKHtcclxuICAgICAgICBkYXRlOiBgMjAyNC0wMS0ke1N0cmluZyhpICsgMSkucGFkU3RhcnQoMiwgJzAnKX1gLFxyXG4gICAgICAgIGFtb3VudDogaSAqIDEwLFxyXG4gICAgICB9KSk7XHJcblxyXG4gICAgICBjb25zdCByZXN1bHQgPSBvcHRpbWl6ZUNoYXJ0RGF0YShkYXRhLCB0cnVlLCBmYWxzZSk7XHJcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwoZGF0YSk7XHJcbiAgICAgIGV4cGVjdChyZXN1bHQubGVuZ3RoKS50b0JlKDQwKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGl0KCdzaG91bGQgb3B0aW1pemUgdG8gMjAgcG9pbnRzIG9uIG1vYmlsZSB3aGVuIGRhdGEgZXhjZWVkcyB0aHJlc2hvbGQnLCAoKSA9PiB7XHJcbiAgICAgIGNvbnN0IGRhdGE6IERhdGFQb2ludFtdID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogMTAwIH0sIChfLCBpKSA9PiAoe1xyXG4gICAgICAgIGRhdGU6IGAyMDI0LTAxLSR7U3RyaW5nKGkgKyAxKS5wYWRTdGFydCgyLCAnMCcpfWAsXHJcbiAgICAgICAgYW1vdW50OiBpICogMTAsXHJcbiAgICAgIH0pKTtcclxuXHJcbiAgICAgIGNvbnN0IHJlc3VsdCA9IG9wdGltaXplQ2hhcnREYXRhKGRhdGEsIHRydWUsIGZhbHNlKTsgLy8gaXNNb2JpbGUgPSB0cnVlXHJcbiAgICAgIGV4cGVjdChyZXN1bHQubGVuZ3RoKS50b0JlKDIwKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGl0KCdzaG91bGQgb3B0aW1pemUgdG8gNDAgcG9pbnRzIG9uIHRhYmxldCB3aGVuIGRhdGEgZXhjZWVkcyB0aHJlc2hvbGQnLCAoKSA9PiB7XHJcbiAgICAgIGNvbnN0IGRhdGE6IERhdGFQb2ludFtdID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogMTAwIH0sIChfLCBpKSA9PiAoe1xyXG4gICAgICAgIGRhdGU6IGAyMDI0LTAxLSR7U3RyaW5nKGkgKyAxKS5wYWRTdGFydCgyLCAnMCcpfWAsXHJcbiAgICAgICAgYW1vdW50OiBpICogMTAsXHJcbiAgICAgIH0pKTtcclxuXHJcbiAgICAgIGNvbnN0IHJlc3VsdCA9IG9wdGltaXplQ2hhcnREYXRhKGRhdGEsIGZhbHNlLCB0cnVlKTsgLy8gaXNUYWJsZXQgPSB0cnVlXHJcbiAgICAgIGV4cGVjdChyZXN1bHQubGVuZ3RoKS50b0JlKDQwKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGl0KCdzaG91bGQgbm90IG9wdGltaXplIG9uIGRlc2t0b3Agd2hlbiBkYXRhIGlzIGJlbG93IDEwMCBwb2ludHMnLCAoKSA9PiB7XHJcbiAgICAgIGNvbnN0IGRhdGE6IERhdGFQb2ludFtdID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogODAgfSwgKF8sIGkpID0+ICh7XHJcbiAgICAgICAgZGF0ZTogYDIwMjQtMDEtJHtTdHJpbmcoaSArIDEpLnBhZFN0YXJ0KDIsICcwJyl9YCxcclxuICAgICAgICBhbW91bnQ6IGkgKiAxMCxcclxuICAgICAgfSkpO1xyXG5cclxuICAgICAgY29uc3QgcmVzdWx0ID0gb3B0aW1pemVDaGFydERhdGEoZGF0YSwgZmFsc2UsIGZhbHNlKTsgLy8gZGVza3RvcFxyXG4gICAgICBleHBlY3QocmVzdWx0KS50b0VxdWFsKGRhdGEpO1xyXG4gICAgICBleHBlY3QocmVzdWx0Lmxlbmd0aCkudG9CZSg4MCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBpdCgnc2hvdWxkIHVzZSBhZ2dyZWdhdGlvbiB3aGVuIHVzZUFnZ3JlZ2F0aW9uIGlzIHRydWUnLCAoKSA9PiB7XHJcbiAgICAgIGNvbnN0IGRhdGE6IERhdGFQb2ludFtdID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogMTAwIH0sIChfLCBpKSA9PiAoe1xyXG4gICAgICAgIGRhdGU6IGAyMDI0LTAxLSR7U3RyaW5nKGkgKyAxKS5wYWRTdGFydCgyLCAnMCcpfWAsXHJcbiAgICAgICAgYW1vdW50OiBpICogMTAsXHJcbiAgICAgIH0pKTtcclxuXHJcbiAgICAgIGNvbnN0IHNhbXBsZWRSZXN1bHQgPSBvcHRpbWl6ZUNoYXJ0RGF0YShkYXRhLCB0cnVlLCBmYWxzZSwgZmFsc2UpO1xyXG4gICAgICBjb25zdCBhZ2dyZWdhdGVkUmVzdWx0ID0gb3B0aW1pemVDaGFydERhdGEoZGF0YSwgdHJ1ZSwgZmFsc2UsIHRydWUpO1xyXG4gICAgICBcclxuICAgICAgLy8gQm90aCBzaG91bGQgaGF2ZSBzYW1lIGxlbmd0aFxyXG4gICAgICBleHBlY3Qoc2FtcGxlZFJlc3VsdC5sZW5ndGgpLnRvQmUoMjApO1xyXG4gICAgICBleHBlY3QoYWdncmVnYXRlZFJlc3VsdC5sZW5ndGgpLnRvQmUoMjApO1xyXG4gICAgICBcclxuICAgICAgLy8gQnV0IGRpZmZlcmVudCB2YWx1ZXMgKGFnZ3JlZ2F0aW9uIGF2ZXJhZ2VzLCBzYW1wbGluZyBwaWNrcyBzcGVjaWZpYyBwb2ludHMpXHJcbiAgICAgIGV4cGVjdChzYW1wbGVkUmVzdWx0WzFdLmFtb3VudCkubm90LnRvQmUoYWdncmVnYXRlZFJlc3VsdFsxXS5hbW91bnQpO1xyXG4gICAgfSk7XHJcbiAgfSk7XHJcblxyXG4gIGRlc2NyaWJlKCdvcHRpbWl6ZUdlbmVyaWNEYXRhJywgKCkgPT4ge1xyXG4gICAgaW50ZXJmYWNlIFRlc3RDYXRlZ29yeSB7XHJcbiAgICAgIG5hbWU6IHN0cmluZztcclxuICAgICAgdmFsdWU6IG51bWJlcjtcclxuICAgIH1cclxuXHJcbiAgICBpdCgnc2hvdWxkIG9wdGltaXplIGdlbmVyaWMgZGF0YSBzdHJ1Y3R1cmVzJywgKCkgPT4ge1xyXG4gICAgICBjb25zdCBkYXRhOiBUZXN0Q2F0ZWdvcnlbXSA9IEFycmF5LmZyb20oeyBsZW5ndGg6IDEwMCB9LCAoXywgaSkgPT4gKHtcclxuICAgICAgICBuYW1lOiBgQ2F0ZWdvcnkgJHtpfWAsXHJcbiAgICAgICAgdmFsdWU6IGkgKiAxMCxcclxuICAgICAgfSkpO1xyXG5cclxuICAgICAgY29uc3QgcmVzdWx0ID0gb3B0aW1pemVHZW5lcmljRGF0YShkYXRhLCB0cnVlLCBmYWxzZSk7IC8vIG1vYmlsZVxyXG4gICAgICBleHBlY3QocmVzdWx0Lmxlbmd0aCkudG9CZSgyMCk7XHJcbiAgICAgIGV4cGVjdChyZXN1bHRbMF0ubmFtZSkudG9CZSgnQ2F0ZWdvcnkgMCcpO1xyXG4gICAgICBleHBlY3QocmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXS5uYW1lKS50b0JlKCdDYXRlZ29yeSA5OScpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaXQoJ3Nob3VsZCBub3Qgb3B0aW1pemUgd2hlbiBkYXRhIGlzIGJlbG93IHRocmVzaG9sZCcsICgpID0+IHtcclxuICAgICAgY29uc3QgZGF0YTogVGVzdENhdGVnb3J5W10gPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiAzMCB9LCAoXywgaSkgPT4gKHtcclxuICAgICAgICBuYW1lOiBgQ2F0ZWdvcnkgJHtpfWAsXHJcbiAgICAgICAgdmFsdWU6IGkgKiAxMCxcclxuICAgICAgfSkpO1xyXG5cclxuICAgICAgY29uc3QgcmVzdWx0ID0gb3B0aW1pemVHZW5lcmljRGF0YShkYXRhLCB0cnVlLCBmYWxzZSk7XHJcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwoZGF0YSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBpdCgnc2hvdWxkIHdvcmsgd2l0aCBkaWZmZXJlbnQgZGF0YSB0eXBlcycsICgpID0+IHtcclxuICAgICAgaW50ZXJmYWNlIENvbXBsZXhEYXRhIHtcclxuICAgICAgICBpZDogc3RyaW5nO1xyXG4gICAgICAgIG5lc3RlZDogeyB2YWx1ZTogbnVtYmVyIH07XHJcbiAgICAgICAgYXJyYXk6IG51bWJlcltdO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCBkYXRhOiBDb21wbGV4RGF0YVtdID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogMTAwIH0sIChfLCBpKSA9PiAoe1xyXG4gICAgICAgIGlkOiBgaWQtJHtpfWAsXHJcbiAgICAgICAgbmVzdGVkOiB7IHZhbHVlOiBpIH0sXHJcbiAgICAgICAgYXJyYXk6IFtpLCBpICogMl0sXHJcbiAgICAgIH0pKTtcclxuXHJcbiAgICAgIGNvbnN0IHJlc3VsdCA9IG9wdGltaXplR2VuZXJpY0RhdGEoZGF0YSwgdHJ1ZSwgZmFsc2UpO1xyXG4gICAgICBleHBlY3QocmVzdWx0Lmxlbmd0aCkudG9CZSgyMCk7XHJcbiAgICAgIGV4cGVjdChyZXN1bHRbMF0uaWQpLnRvQmUoJ2lkLTAnKTtcclxuICAgICAgZXhwZWN0KHJlc3VsdFswXS5uZXN0ZWQudmFsdWUpLnRvQmUoMCk7XHJcbiAgICB9KTtcclxuICB9KTtcclxuXHJcbiAgZGVzY3JpYmUoJ3Nob3VsZE9wdGltaXplRGF0YScsICgpID0+IHtcclxuICAgIGl0KCdzaG91bGQgcmV0dXJuIGZhbHNlIHdoZW4gZGF0YSBsZW5ndGggaXMgYmVsb3cgdGhyZXNob2xkJywgKCkgPT4ge1xyXG4gICAgICBleHBlY3Qoc2hvdWxkT3B0aW1pemVEYXRhKDMwLCB0cnVlLCBmYWxzZSkpLnRvQmUoZmFsc2UpO1xyXG4gICAgICBleHBlY3Qoc2hvdWxkT3B0aW1pemVEYXRhKDUwLCB0cnVlLCBmYWxzZSkpLnRvQmUoZmFsc2UpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gdHJ1ZSBvbiBtb2JpbGUgd2hlbiBkYXRhIGV4Y2VlZHMgbW9iaWxlIG1heCAoMjApJywgKCkgPT4ge1xyXG4gICAgICBleHBlY3Qoc2hvdWxkT3B0aW1pemVEYXRhKDYwLCB0cnVlLCBmYWxzZSkpLnRvQmUodHJ1ZSk7XHJcbiAgICAgIGV4cGVjdChzaG91bGRPcHRpbWl6ZURhdGEoMTAwLCB0cnVlLCBmYWxzZSkpLnRvQmUodHJ1ZSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBpdCgnc2hvdWxkIHJldHVybiB0cnVlIG9uIHRhYmxldCB3aGVuIGRhdGEgZXhjZWVkcyB0YWJsZXQgbWF4ICg0MCknLCAoKSA9PiB7XHJcbiAgICAgIGV4cGVjdChzaG91bGRPcHRpbWl6ZURhdGEoNjAsIGZhbHNlLCB0cnVlKSkudG9CZSh0cnVlKTtcclxuICAgICAgZXhwZWN0KHNob3VsZE9wdGltaXplRGF0YSgxMDAsIGZhbHNlLCB0cnVlKSkudG9CZSh0cnVlKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGl0KCdzaG91bGQgcmV0dXJuIGZhbHNlIG9uIHRhYmxldCB3aGVuIGRhdGEgaXMgYmVsb3cgdGFibGV0IG1heCcsICgpID0+IHtcclxuICAgICAgLy8gNTUgcG9pbnRzIGlzIGFib3ZlIHRocmVzaG9sZCAoNTApIGJ1dCBhYm92ZSB0YWJsZXQgbWF4ICg0MCksIHNvIGl0IHNob3VsZCBvcHRpbWl6ZVxyXG4gICAgICBleHBlY3Qoc2hvdWxkT3B0aW1pemVEYXRhKDU1LCBmYWxzZSwgdHJ1ZSkpLnRvQmUodHJ1ZSk7XHJcbiAgICAgIC8vIDM1IHBvaW50cyBpcyBiZWxvdyB0aHJlc2hvbGQsIHNvIG5vIG9wdGltaXphdGlvblxyXG4gICAgICBleHBlY3Qoc2hvdWxkT3B0aW1pemVEYXRhKDM1LCBmYWxzZSwgdHJ1ZSkpLnRvQmUoZmFsc2UpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gdHJ1ZSBvbiBkZXNrdG9wIHdoZW4gZGF0YSBleGNlZWRzIGRlc2t0b3AgbWF4ICgxMDApJywgKCkgPT4ge1xyXG4gICAgICBleHBlY3Qoc2hvdWxkT3B0aW1pemVEYXRhKDE1MCwgZmFsc2UsIGZhbHNlKSkudG9CZSh0cnVlKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGl0KCdzaG91bGQgcmV0dXJuIGZhbHNlIG9uIGRlc2t0b3Agd2hlbiBkYXRhIGlzIGJlbG93IGRlc2t0b3AgbWF4JywgKCkgPT4ge1xyXG4gICAgICBleHBlY3Qoc2hvdWxkT3B0aW1pemVEYXRhKDgwLCBmYWxzZSwgZmFsc2UpKS50b0JlKGZhbHNlKTtcclxuICAgIH0pO1xyXG4gIH0pO1xyXG5cclxuICBkZXNjcmliZSgnZWRnZSBjYXNlcycsICgpID0+IHtcclxuICAgIGl0KCdzaG91bGQgaGFuZGxlIG51bGwvdW5kZWZpbmVkIGRhdGEgZ3JhY2VmdWxseScsICgpID0+IHtcclxuICAgICAgZXhwZWN0KHNhbXBsZURhdGFQb2ludHMobnVsbCBhcyBhbnksIDEwKSkudG9FcXVhbChudWxsKTtcclxuICAgICAgZXhwZWN0KGFnZ3JlZ2F0ZURhdGFQb2ludHModW5kZWZpbmVkIGFzIGFueSwgMTApKS50b0VxdWFsKHVuZGVmaW5lZCk7XHJcbiAgICAgIGV4cGVjdChvcHRpbWl6ZUNoYXJ0RGF0YShudWxsIGFzIGFueSwgdHJ1ZSwgZmFsc2UpKS50b0VxdWFsKG51bGwpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgc2luZ2xlIGRhdGEgcG9pbnQnLCAoKSA9PiB7XHJcbiAgICAgIGNvbnN0IGRhdGE6IERhdGFQb2ludFtdID0gW3sgZGF0ZTogJzIwMjQtMDEtMDEnLCBhbW91bnQ6IDEwMCB9XTtcclxuICAgICAgXHJcbiAgICAgIGV4cGVjdChzYW1wbGVEYXRhUG9pbnRzKGRhdGEsIDEwKSkudG9FcXVhbChkYXRhKTtcclxuICAgICAgZXhwZWN0KGFnZ3JlZ2F0ZURhdGFQb2ludHMoZGF0YSwgMTApKS50b0VxdWFsKGRhdGEpO1xyXG4gICAgICBleHBlY3Qob3B0aW1pemVDaGFydERhdGEoZGF0YSwgdHJ1ZSwgZmFsc2UpKS50b0VxdWFsKGRhdGEpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgbWF4UG9pbnRzIG9mIDInLCAoKSA9PiB7XHJcbiAgICAgIGNvbnN0IGRhdGE6IERhdGFQb2ludFtdID0gW1xyXG4gICAgICAgIHsgZGF0ZTogJzIwMjQtMDEtMDEnLCBhbW91bnQ6IDEwMCB9LFxyXG4gICAgICAgIHsgZGF0ZTogJzIwMjQtMDEtMDInLCBhbW91bnQ6IDIwMCB9LFxyXG4gICAgICAgIHsgZGF0ZTogJzIwMjQtMDEtMDMnLCBhbW91bnQ6IDMwMCB9LFxyXG4gICAgICBdO1xyXG5cclxuICAgICAgY29uc3QgcmVzdWx0ID0gc2FtcGxlRGF0YVBvaW50cyhkYXRhLCAyKTtcclxuICAgICAgZXhwZWN0KHJlc3VsdC5sZW5ndGgpLnRvQmUoMik7XHJcbiAgICAgIC8vIFNob3VsZCBpbmNsdWRlIGZpcnN0IGFuZCBsYXN0XHJcbiAgICAgIGV4cGVjdChyZXN1bHRbMF0pLnRvRXF1YWwoZGF0YVswXSk7XHJcbiAgICAgIGV4cGVjdChyZXN1bHRbMV0pLnRvRXF1YWwoZGF0YVsyXSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBkYXRhIHdpdGggbmVnYXRpdmUgYW1vdW50cycsICgpID0+IHtcclxuICAgICAgY29uc3QgZGF0YTogRGF0YVBvaW50W10gPSBbXHJcbiAgICAgICAgeyBkYXRlOiAnMjAyNC0wMS0wMScsIGFtb3VudDogLTEwMCB9LFxyXG4gICAgICAgIHsgZGF0ZTogJzIwMjQtMDEtMDInLCBhbW91bnQ6IC0yMDAgfSxcclxuICAgICAgICB7IGRhdGU6ICcyMDI0LTAxLTAzJywgYW1vdW50OiAxNTAgfSxcclxuICAgICAgICB7IGRhdGU6ICcyMDI0LTAxLTA0JywgYW1vdW50OiAtNTAgfSxcclxuICAgICAgXTtcclxuXHJcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGFnZ3JlZ2F0ZURhdGFQb2ludHMoZGF0YSwgMik7XHJcbiAgICAgIGV4cGVjdChyZXN1bHQubGVuZ3RoKS50b0JlKDIpO1xyXG4gICAgICAvLyBGaXJzdCBidWNrZXQ6ICgtMTAwICsgLTIwMCkgLyAyID0gLTE1MFxyXG4gICAgICBleHBlY3QocmVzdWx0WzBdLmFtb3VudCkudG9CZSgtMTUwKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGl0KCdzaG91bGQgaGFuZGxlIGRhdGEgd2l0aCB6ZXJvIGFtb3VudHMnLCAoKSA9PiB7XHJcbiAgICAgIGNvbnN0IGRhdGE6IERhdGFQb2ludFtdID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogMTAwIH0sIChfLCBpKSA9PiAoe1xyXG4gICAgICAgIGRhdGU6IGAyMDI0LTAxLSR7U3RyaW5nKGkgKyAxKS5wYWRTdGFydCgyLCAnMCcpfWAsXHJcbiAgICAgICAgYW1vdW50OiAwLFxyXG4gICAgICB9KSk7XHJcblxyXG4gICAgICBjb25zdCByZXN1bHQgPSBvcHRpbWl6ZUNoYXJ0RGF0YShkYXRhLCB0cnVlLCBmYWxzZSk7XHJcbiAgICAgIGV4cGVjdChyZXN1bHQubGVuZ3RoKS50b0JlKDIwKTtcclxuICAgICAgZXhwZWN0KHJlc3VsdC5ldmVyeShwb2ludCA9PiBwb2ludC5hbW91bnQgPT09IDApKS50b0JlKHRydWUpO1xyXG4gICAgfSk7XHJcbiAgfSk7XHJcbn0pO1xyXG4iXSwibmFtZXMiOlsiZGVzY3JpYmUiLCJpdCIsImRhdGEiLCJkYXRlIiwiYW1vdW50IiwicmVzdWx0Iiwic2FtcGxlRGF0YVBvaW50cyIsImV4cGVjdCIsInRvRXF1YWwiLCJsZW5ndGgiLCJ0b0JlIiwiQXJyYXkiLCJmcm9tIiwiXyIsImkiLCJTdHJpbmciLCJwYWRTdGFydCIsImFnZ3JlZ2F0ZURhdGFQb2ludHMiLCJvcHRpbWl6ZUNoYXJ0RGF0YSIsInNhbXBsZWRSZXN1bHQiLCJhZ2dyZWdhdGVkUmVzdWx0Iiwibm90IiwibmFtZSIsInZhbHVlIiwib3B0aW1pemVHZW5lcmljRGF0YSIsImlkIiwibmVzdGVkIiwiYXJyYXkiLCJzaG91bGRPcHRpbWl6ZURhdGEiLCJ1bmRlZmluZWQiLCJldmVyeSIsInBvaW50Il0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7OztDQU9DOzs7O3VDQVNNO0FBRVBBLFNBQVMseUJBQXlCO0lBQ2hDQSxTQUFTLG9CQUFvQjtRQUMzQkMsR0FBRyxrRUFBa0U7WUFDbkUsTUFBTUMsT0FBb0I7Z0JBQ3hCO29CQUFFQyxNQUFNO29CQUFjQyxRQUFRO2dCQUFJO2dCQUNsQztvQkFBRUQsTUFBTTtvQkFBY0MsUUFBUTtnQkFBSTtnQkFDbEM7b0JBQUVELE1BQU07b0JBQWNDLFFBQVE7Z0JBQUk7YUFDbkM7WUFFRCxNQUFNQyxTQUFTQyxJQUFBQSx1Q0FBZ0IsRUFBQ0osTUFBTTtZQUN0Q0ssT0FBT0YsUUFBUUcsT0FBTyxDQUFDTjtZQUN2QkssT0FBT0YsT0FBT0ksTUFBTSxFQUFFQyxJQUFJLENBQUM7UUFDN0I7UUFFQVQsR0FBRyxnREFBZ0Q7WUFDakQsTUFBTUksU0FBU0MsSUFBQUEsdUNBQWdCLEVBQUMsRUFBRSxFQUFFO1lBQ3BDQyxPQUFPRixRQUFRRyxPQUFPLENBQUMsRUFBRTtRQUMzQjtRQUVBUCxHQUFHLGtFQUFrRTtZQUNuRSxNQUFNQyxPQUFvQlMsTUFBTUMsSUFBSSxDQUFDO2dCQUFFSCxRQUFRO1lBQUksR0FBRyxDQUFDSSxHQUFHQyxJQUFPLENBQUE7b0JBQy9EWCxNQUFNLENBQUMsUUFBUSxFQUFFWSxPQUFPRCxJQUFJLEdBQUdF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