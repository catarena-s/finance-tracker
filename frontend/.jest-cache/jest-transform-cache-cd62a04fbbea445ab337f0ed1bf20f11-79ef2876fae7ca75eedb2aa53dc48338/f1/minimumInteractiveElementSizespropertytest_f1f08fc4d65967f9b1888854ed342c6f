035f839392ef484ccbb209901da0e86c
/**
 * Property-Based Test — Adaptive Font Sizes
 * 
 * **Property 2: Адаптивные размеры шрифтов**
 * **Validates: Requirements 1.2, 6.1**
 * 
 * For any text element with adaptive Tailwind classes, font size should decrease
 * on mobile devices and increase on desktop.
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _jsxruntime = require("react/jsx-runtime");
const _react = /*#__PURE__*/ _interop_require_default(require("react"));
const _react1 = require("@testing-library/react");
const _fastcheck = /*#__PURE__*/ _interop_require_default(require("fast-check"));
const _BalanceCards = require("../../src/components/dashboard/BalanceCards");
const _propertytestconfig = require("./property-test-config");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
// Tailwind font size mappings (in pixels at base 16px)
const tailwindFontSizes = {
    "text-xs": 12,
    "text-sm": 14,
    "text-base": 16,
    "text-lg": 18,
    "text-xl": 20,
    "text-2xl": 24,
    "text-3xl": 30,
    "text-4xl": 36
};
// Helper function to check if element has adaptive font size classes
const hasAdaptiveFontClasses = (element)=>{
    const classList = Array.from(element.classList);
    // Check for pattern: base size + responsive modifiers
    const hasBaseSize = classList.some((cls)=>cls.startsWith("text-"));
    const hasSmModifier = classList.some((cls)=>cls.startsWith("sm:text-"));
    const hasMdModifier = classList.some((cls)=>cls.startsWith("md:text-"));
    return hasBaseSize && (hasSmModifier || hasMdModifier);
};
// Helper function to extract font size class values
const extractFontSizeClasses = (element)=>{
    const classList = Array.from(element.classList);
    const base = classList.find((cls)=>/^text-(xs|sm|base|lg|xl|2xl|3xl|4xl)$/.test(cls)) || null;
    const sm = classList.find((cls)=>/^sm:text-(xs|sm|base|lg|xl|2xl|3xl|4xl)$/.test(cls))?.replace("sm:", "") || null;
    const md = classList.find((cls)=>/^md:text-(xs|sm|base|lg|xl|2xl|3xl|4xl)$/.test(cls))?.replace("md:", "") || null;
    return {
        base,
        sm,
        md
    };
};
// Helper function to get numeric font size from class name
const getFontSizeFromClass = (className)=>{
    if (!className) return 0;
    return tailwindFontSizes[className] || 0;
};
describe("Property: Adaptive Font Sizes", ()=>{
    describe("BalanceCards adaptive font sizes", ()=>{
        it("should have smaller font sizes on mobile than on desktop for amount text", ()=>{
            _fastcheck.default.assert(_fastcheck.default.property(// Generate random financial data
            _fastcheck.default.integer({
                min: 0,
                max: 1000000
            }), _fastcheck.default.integer({
                min: 0,
                max: 1000000
            }), (income, expense)=>{
                const balance = income - expense;
                const { container } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_BalanceCards.BalanceCards, {
                    totalIncome: income,
                    totalExpense: expense,
                    balance: balance
                }));
                // Find amount elements with adaptive classes (text-sm sm:text-base md:text-xl lg:text-2xl)
                const amounts = container.querySelectorAll(".text-sm.sm\\:text-base.md\\:text-xl.lg\\:text-2xl");
                expect(amounts.length).toBeGreaterThan(0);
                // Verify each amount element has progressive font size classes
                amounts.forEach((element)=>{
                    const fontClasses = extractFontSizeClasses(element);
                    // Should have base, sm, and md classes
                    expect(fontClasses.base).toBe("text-sm");
                    expect(fontClasses.sm).toBe("text-base");
                    expect(fontClasses.md).toBe("text-xl");
                    // Verify progressive increase: base < sm < md
                    const baseSize = getFontSizeFromClass(fontClasses.base);
                    const smSize = getFontSizeFromClass(fontClasses.sm);
                    const mdSize = getFontSizeFromClass(fontClasses.md);
                    expect(baseSize).toBe(14); // text-sm
                    expect(smSize).toBe(16); // text-base
                    expect(mdSize).toBe(20); // text-xl
                    expect(smSize).toBeGreaterThan(baseSize);
                    expect(mdSize).toBeGreaterThan(smSize);
                });
            }), {
                numRuns: (0, _propertytestconfig.getNumRuns)("MEDIUM")
            });
        });
        it("should progressively increase font size across breakpoints", ()=>{
            _fastcheck.default.assert(_fastcheck.default.property(_fastcheck.default.integer({
                min: 0,
                max: 1000000
            }), _fastcheck.default.integer({
                min: 0,
                max: 1000000
            }), (income, expense)=>{
                const balance = income - expense;
                const { container } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_BalanceCards.BalanceCards, {
                    totalIncome: income,
                    totalExpense: expense,
                    balance: balance
                }));
                const amounts = container.querySelectorAll(".text-sm.sm\\:text-base.md\\:text-xl.lg\\:text-2xl");
                expect(amounts.length).toBeGreaterThan(0);
                amounts.forEach((element)=>{
                    const fontClasses = extractFontSizeClasses(element);
                    const baseSize = getFontSizeFromClass(fontClasses.base);
                    const smSize = getFontSizeFromClass(fontClasses.sm);
                    const mdSize = getFontSizeFromClass(fontClasses.md);
                    // Verify progressive increase: mobile < tablet < desktop
                    expect(baseSize).toBeGreaterThan(0);
                    expect(smSize).toBeGreaterThan(0);
                    expect(mdSize).toBeGreaterThan(0);
                    expect(smSize).toBeGreaterThan(baseSize);
                    expect(mdSize).toBeGreaterThan(smSize);
                });
            }), {
                numRuns: (0, _propertytestconfig.getNumRuns)("MEDIUM")
            });
        });
    });
    describe("General adaptive font size property", ()=>{
        it("should ensure all elements with responsive font classes have progressive sizing", ()=>{
            _fastcheck.default.assert(_fastcheck.default.property(_fastcheck.default.integer({
                min: 0,
                max: 1000000
            }), _fastcheck.default.integer({
                min: 0,
                max: 1000000
            }), (income, expense)=>{
                const balance = income - expense;
                const { container } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_BalanceCards.BalanceCards, {
                    totalIncome: income,
                    totalExpense: expense,
                    balance: balance
                }));
                // Find all elements with adaptive font size classes
                const adaptiveElements = container.querySelectorAll(".text-sm.sm\\:text-base.md\\:text-xl.lg\\:text-2xl");
                adaptiveElements.forEach((element)=>{
                    const fontClasses = extractFontSizeClasses(element);
                    // Verify element has adaptive classes
                    expect(hasAdaptiveFontClasses(element)).toBe(true);
                    // Verify font sizes are in ascending order
                    const baseSize = getFontSizeFromClass(fontClasses.base);
                    const smSize = getFontSizeFromClass(fontClasses.sm);
                    const mdSize = getFontSizeFromClass(fontClasses.md);
                    if (smSize > 0) {
                        expect(smSize).toBeGreaterThanOrEqual(baseSize);
                    }
                    if (mdSize > 0) {
                        expect(mdSize).toBeGreaterThanOrEqual(smSize || baseSize);
                    }
                });
            }), {
                numRuns: (0, _propertytestconfig.getNumRuns)("MEDIUM")
            });
        });
    });
    describe("Edge cases", ()=>{
        it("should have consistent adaptive classes regardless of data values", ()=>{
            const { container } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_BalanceCards.BalanceCards, {
                totalIncome: 50000,
                totalExpense: 30000,
                balance: 20000
            }));
            const amounts = container.querySelectorAll(".text-sm.sm\\:text-base.md\\:text-xl.lg\\:text-2xl");
            amounts.forEach((element)=>{
                const fontClasses = extractFontSizeClasses(element);
                // Should use mobile size (text-sm) as base
                expect(fontClasses.base).toBe("text-sm");
                expect(fontClasses.sm).toBe("text-base");
                expect(fontClasses.md).toBe("text-xl");
            });
        });
        it("should maintain adaptive font classes with extreme values", ()=>{
            const extremeCases = [
                {
                    income: 0,
                    expense: 0,
                    balance: 0
                },
                {
                    income: 999999999,
                    expense: 0,
                    balance: 999999999
                },
                {
                    income: 0,
                    expense: 999999999,
                    balance: -999999999
                }
            ];
            extremeCases.forEach(({ income, expense, balance })=>{
                const { container } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_BalanceCards.BalanceCards, {
                    totalIncome: income,
                    totalExpense: expense,
                    balance: balance
                }));
                const amounts = container.querySelectorAll(".text-sm.sm\\:text-base.md\\:text-xl.lg\\:text-2xl");
                expect(amounts.length).toBeGreaterThan(0);
                amounts.forEach((element)=>{
                    const fontClasses = extractFontSizeClasses(element);
                    const baseSize = getFontSizeFromClass(fontClasses.base);
                    const smSize = getFontSizeFromClass(fontClasses.sm);
                    const mdSize = getFontSizeFromClass(fontClasses.md);
                    // Verify progressive sizing is maintained
                    expect(baseSize).toBe(14);
                    expect(smSize).toBe(16);
                    expect(mdSize).toBe(20);
                    expect(smSize).toBeGreaterThan(baseSize);
                    expect(mdSize).toBeGreaterThan(smSize);
                });
            });
        });
        it("should apply adaptive font classes to all three balance cards", ()=>{
            _fastcheck.default.assert(_fastcheck.default.property(_fastcheck.default.integer({
                min: 0,
                max: 1000000
            }), _fastcheck.default.integer({
                min: 0,
                max: 1000000
            }), (income, expense)=>{
                const balance = income - expense;
                const { container } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_BalanceCards.BalanceCards, {
                    totalIncome: income,
                    totalExpense: expense,
                    balance: balance
                }));
                const amounts = container.querySelectorAll(".text-sm.sm\\:text-base.md\\:text-xl.lg\\:text-2xl");
                // Should have exactly 3 amount elements (income, expense, balance)
                expect(amounts.length).toBe(3);
                // All three should have the same adaptive font classes
                amounts.forEach((element)=>{
                    expect(element).toHaveClass("text-sm");
                    expect(element).toHaveClass("sm:text-base");
                    expect(element).toHaveClass("md:text-xl");
                    expect(element).toHaveClass("lg:text-2xl");
                });
            }), {
                numRuns: (0, _propertytestconfig.getNumRuns)("MEDIUM")
            });
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkU6XFxteVxcb3R1c1xcZmluYW5jZV90cmFja2VyXFxmcm9udGVuZFxcX190ZXN0c19fXFxwcm9wZXJ0aWVzXFxtaW5pbXVtSW50ZXJhY3RpdmVFbGVtZW50U2l6ZXMucHJvcGVydHkudGVzdC50c3giXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIFByb3BlcnR5LUJhc2VkIFRlc3Qg4oCUIEFkYXB0aXZlIEZvbnQgU2l6ZXNcclxuICogXHJcbiAqICoqUHJvcGVydHkgMjog0JDQtNCw0L/RgtC40LLQvdGL0LUg0YDQsNC30LzQtdGA0Ysg0YjRgNC40YTRgtC+0LIqKlxyXG4gKiAqKlZhbGlkYXRlczogUmVxdWlyZW1lbnRzIDEuMiwgNi4xKipcclxuICogXHJcbiAqIEZvciBhbnkgdGV4dCBlbGVtZW50IHdpdGggYWRhcHRpdmUgVGFpbHdpbmQgY2xhc3NlcywgZm9udCBzaXplIHNob3VsZCBkZWNyZWFzZVxyXG4gKiBvbiBtb2JpbGUgZGV2aWNlcyBhbmQgaW5jcmVhc2Ugb24gZGVza3RvcC5cclxuICovXHJcblxyXG5pbXBvcnQgUmVhY3QgZnJvbSBcInJlYWN0XCI7XHJcbmltcG9ydCB7IHJlbmRlciB9IGZyb20gXCJAdGVzdGluZy1saWJyYXJ5L3JlYWN0XCI7XHJcbmltcG9ydCBmYyBmcm9tIFwiZmFzdC1jaGVja1wiO1xyXG5pbXBvcnQgeyBCYWxhbmNlQ2FyZHMgfSBmcm9tIFwiQC9jb21wb25lbnRzL2Rhc2hib2FyZC9CYWxhbmNlQ2FyZHNcIjtcclxuaW1wb3J0IHsgZ2V0TnVtUnVucywgZ2V0VGltZW91dCB9IGZyb20gXCIuL3Byb3BlcnR5LXRlc3QtY29uZmlnXCI7XHJcblxyXG4vLyBUYWlsd2luZCBmb250IHNpemUgbWFwcGluZ3MgKGluIHBpeGVscyBhdCBiYXNlIDE2cHgpXHJcbmNvbnN0IHRhaWx3aW5kRm9udFNpemVzID0ge1xyXG4gIFwidGV4dC14c1wiOiAxMixcclxuICBcInRleHQtc21cIjogMTQsXHJcbiAgXCJ0ZXh0LWJhc2VcIjogMTYsXHJcbiAgXCJ0ZXh0LWxnXCI6IDE4LFxyXG4gIFwidGV4dC14bFwiOiAyMCxcclxuICBcInRleHQtMnhsXCI6IDI0LFxyXG4gIFwidGV4dC0zeGxcIjogMzAsXHJcbiAgXCJ0ZXh0LTR4bFwiOiAzNixcclxufTtcclxuXHJcbi8vIEhlbHBlciBmdW5jdGlvbiB0byBjaGVjayBpZiBlbGVtZW50IGhhcyBhZGFwdGl2ZSBmb250IHNpemUgY2xhc3Nlc1xyXG5jb25zdCBoYXNBZGFwdGl2ZUZvbnRDbGFzc2VzID0gKGVsZW1lbnQ6IEVsZW1lbnQpOiBib29sZWFuID0+IHtcclxuICBjb25zdCBjbGFzc0xpc3QgPSBBcnJheS5mcm9tKGVsZW1lbnQuY2xhc3NMaXN0KTtcclxuICBcclxuICAvLyBDaGVjayBmb3IgcGF0dGVybjogYmFzZSBzaXplICsgcmVzcG9uc2l2ZSBtb2RpZmllcnNcclxuICBjb25zdCBoYXNCYXNlU2l6ZSA9IGNsYXNzTGlzdC5zb21lKGNscyA9PiBjbHMuc3RhcnRzV2l0aChcInRleHQtXCIpKTtcclxuICBjb25zdCBoYXNTbU1vZGlmaWVyID0gY2xhc3NMaXN0LnNvbWUoY2xzID0+IGNscy5zdGFydHNXaXRoKFwic206dGV4dC1cIikpO1xyXG4gIGNvbnN0IGhhc01kTW9kaWZpZXIgPSBjbGFzc0xpc3Quc29tZShjbHMgPT4gY2xzLnN0YXJ0c1dpdGgoXCJtZDp0ZXh0LVwiKSk7XHJcbiAgXHJcbiAgcmV0dXJuIGhhc0Jhc2VTaXplICYmIChoYXNTbU1vZGlmaWVyIHx8IGhhc01kTW9kaWZpZXIpO1xyXG59O1xyXG5cclxuLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGV4dHJhY3QgZm9udCBzaXplIGNsYXNzIHZhbHVlc1xyXG5jb25zdCBleHRyYWN0Rm9udFNpemVDbGFzc2VzID0gKGVsZW1lbnQ6IEVsZW1lbnQpOiB7XHJcbiAgYmFzZTogc3RyaW5nIHwgbnVsbDtcclxuICBzbTogc3RyaW5nIHwgbnVsbDtcclxuICBtZDogc3RyaW5nIHwgbnVsbDtcclxufSA9PiB7XHJcbiAgY29uc3QgY2xhc3NMaXN0ID0gQXJyYXkuZnJvbShlbGVtZW50LmNsYXNzTGlzdCk7XHJcbiAgXHJcbiAgY29uc3QgYmFzZSA9IGNsYXNzTGlzdC5maW5kKGNscyA9PiAvXnRleHQtKHhzfHNtfGJhc2V8bGd8eGx8MnhsfDN4bHw0eGwpJC8udGVzdChjbHMpKSB8fCBudWxsO1xyXG4gIGNvbnN0IHNtID0gY2xhc3NMaXN0LmZpbmQoY2xzID0+IC9ec206dGV4dC0oeHN8c218YmFzZXxsZ3x4bHwyeGx8M3hsfDR4bCkkLy50ZXN0KGNscykpPy5yZXBsYWNlKFwic206XCIsIFwiXCIpIHx8IG51bGw7XHJcbiAgY29uc3QgbWQgPSBjbGFzc0xpc3QuZmluZChjbHMgPT4gL15tZDp0ZXh0LSh4c3xzbXxiYXNlfGxnfHhsfDJ4bHwzeGx8NHhsKSQvLnRlc3QoY2xzKSk/LnJlcGxhY2UoXCJtZDpcIiwgXCJcIikgfHwgbnVsbDtcclxuICBcclxuICByZXR1cm4geyBiYXNlLCBzbSwgbWQgfTtcclxufTtcclxuXHJcbi8vIEhlbHBlciBmdW5jdGlvbiB0byBnZXQgbnVtZXJpYyBmb250IHNpemUgZnJvbSBjbGFzcyBuYW1lXHJcbmNvbnN0IGdldEZvbnRTaXplRnJvbUNsYXNzID0gKGNsYXNzTmFtZTogc3RyaW5nIHwgbnVsbCk6IG51bWJlciA9PiB7XHJcbiAgaWYgKCFjbGFzc05hbWUpIHJldHVybiAwO1xyXG4gIHJldHVybiB0YWlsd2luZEZvbnRTaXplc1tjbGFzc05hbWUgYXMga2V5b2YgdHlwZW9mIHRhaWx3aW5kRm9udFNpemVzXSB8fCAwO1xyXG59O1xyXG5cclxuZGVzY3JpYmUoXCJQcm9wZXJ0eTogQWRhcHRpdmUgRm9udCBTaXplc1wiLCAoKSA9PiB7XHJcbiAgZGVzY3JpYmUoXCJCYWxhbmNlQ2FyZHMgYWRhcHRpdmUgZm9udCBzaXplc1wiLCAoKSA9PiB7XHJcbiAgICBpdChcInNob3VsZCBoYXZlIHNtYWxsZXIgZm9udCBzaXplcyBvbiBtb2JpbGUgdGhhbiBvbiBkZXNrdG9wIGZvciBhbW91bnQgdGV4dFwiLCAoKSA9PiB7XHJcbiAgICAgIGZjLmFzc2VydChcclxuICAgICAgICBmYy5wcm9wZXJ0eShcclxuICAgICAgICAgIC8vIEdlbmVyYXRlIHJhbmRvbSBmaW5hbmNpYWwgZGF0YVxyXG4gICAgICAgICAgZmMuaW50ZWdlcih7IG1pbjogMCwgbWF4OiAxMDAwMDAwIH0pLFxyXG4gICAgICAgICAgZmMuaW50ZWdlcih7IG1pbjogMCwgbWF4OiAxMDAwMDAwIH0pLFxyXG4gICAgICAgICAgKGluY29tZSwgZXhwZW5zZSkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBiYWxhbmNlID0gaW5jb21lIC0gZXhwZW5zZTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGNvbnN0IHsgY29udGFpbmVyIH0gPSByZW5kZXIoXHJcbiAgICAgICAgICAgICAgPEJhbGFuY2VDYXJkc1xyXG4gICAgICAgICAgICAgICAgdG90YWxJbmNvbWU9e2luY29tZX1cclxuICAgICAgICAgICAgICAgIHRvdGFsRXhwZW5zZT17ZXhwZW5zZX1cclxuICAgICAgICAgICAgICAgIGJhbGFuY2U9e2JhbGFuY2V9XHJcbiAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIC8vIEZpbmQgYW1vdW50IGVsZW1lbnRzIHdpdGggYWRhcHRpdmUgY2xhc3NlcyAodGV4dC1zbSBzbTp0ZXh0LWJhc2UgbWQ6dGV4dC14bCBsZzp0ZXh0LTJ4bClcclxuICAgICAgICAgICAgY29uc3QgYW1vdW50cyA9IGNvbnRhaW5lci5xdWVyeVNlbGVjdG9yQWxsKFxyXG4gICAgICAgICAgICAgIFwiLnRleHQtc20uc21cXFxcOnRleHQtYmFzZS5tZFxcXFw6dGV4dC14bC5sZ1xcXFw6dGV4dC0yeGxcIlxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgZXhwZWN0KGFtb3VudHMubGVuZ3RoKS50b0JlR3JlYXRlclRoYW4oMCk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAvLyBWZXJpZnkgZWFjaCBhbW91bnQgZWxlbWVudCBoYXMgcHJvZ3Jlc3NpdmUgZm9udCBzaXplIGNsYXNzZXNcclxuICAgICAgICAgICAgYW1vdW50cy5mb3JFYWNoKChlbGVtZW50KSA9PiB7XHJcbiAgICAgICAgICAgICAgY29uc3QgZm9udENsYXNzZXMgPSBleHRyYWN0Rm9udFNpemVDbGFzc2VzKGVsZW1lbnQpO1xyXG4gICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgIC8vIFNob3VsZCBoYXZlIGJhc2UsIHNtLCBhbmQgbWQgY2xhc3Nlc1xyXG4gICAgICAgICAgICAgIGV4cGVjdChmb250Q2xhc3Nlcy5iYXNlKS50b0JlKFwidGV4dC1zbVwiKTtcclxuICAgICAgICAgICAgICBleHBlY3QoZm9udENsYXNzZXMuc20pLnRvQmUoXCJ0ZXh0LWJhc2VcIik7XHJcbiAgICAgICAgICAgICAgZXhwZWN0KGZvbnRDbGFzc2VzLm1kKS50b0JlKFwidGV4dC14bFwiKTtcclxuICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAvLyBWZXJpZnkgcHJvZ3Jlc3NpdmUgaW5jcmVhc2U6IGJhc2UgPCBzbSA8IG1kXHJcbiAgICAgICAgICAgICAgY29uc3QgYmFzZVNpemUgPSBnZXRGb250U2l6ZUZyb21DbGFzcyhmb250Q2xhc3Nlcy5iYXNlKTtcclxuICAgICAgICAgICAgICBjb25zdCBzbVNpemUgPSBnZXRGb250U2l6ZUZyb21DbGFzcyhmb250Q2xhc3Nlcy5zbSk7XHJcbiAgICAgICAgICAgICAgY29uc3QgbWRTaXplID0gZ2V0Rm9udFNpemVGcm9tQ2xhc3MoZm9udENsYXNzZXMubWQpO1xyXG4gICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgIGV4cGVjdChiYXNlU2l6ZSkudG9CZSgxNCk7IC8vIHRleHQtc21cclxuICAgICAgICAgICAgICBleHBlY3Qoc21TaXplKS50b0JlKDE2KTsgICAvLyB0ZXh0LWJhc2VcclxuICAgICAgICAgICAgICBleHBlY3QobWRTaXplKS50b0JlKDIwKTsgICAvLyB0ZXh0LXhsXHJcbiAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgZXhwZWN0KHNtU2l6ZSkudG9CZUdyZWF0ZXJUaGFuKGJhc2VTaXplKTtcclxuICAgICAgICAgICAgICBleHBlY3QobWRTaXplKS50b0JlR3JlYXRlclRoYW4oc21TaXplKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgKSxcclxuICAgICAgICB7IG51bVJ1bnM6IGdldE51bVJ1bnMoXCJNRURJVU1cIikgfVxyXG4gICAgICApO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaXQoXCJzaG91bGQgcHJvZ3Jlc3NpdmVseSBpbmNyZWFzZSBmb250IHNpemUgYWNyb3NzIGJyZWFrcG9pbnRzXCIsICgpID0+IHtcclxuICAgICAgZmMuYXNzZXJ0KFxyXG4gICAgICAgIGZjLnByb3BlcnR5KFxyXG4gICAgICAgICAgZmMuaW50ZWdlcih7IG1pbjogMCwgbWF4OiAxMDAwMDAwIH0pLFxyXG4gICAgICAgICAgZmMuaW50ZWdlcih7IG1pbjogMCwgbWF4OiAxMDAwMDAwIH0pLFxyXG4gICAgICAgICAgKGluY29tZSwgZXhwZW5zZSkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBiYWxhbmNlID0gaW5jb21lIC0gZXhwZW5zZTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGNvbnN0IHsgY29udGFpbmVyIH0gPSByZW5kZXIoXHJcbiAgICAgICAgICAgICAgPEJhbGFuY2VDYXJkc1xyXG4gICAgICAgICAgICAgICAgdG90YWxJbmNvbWU9e2luY29tZX1cclxuICAgICAgICAgICAgICAgIHRvdGFsRXhwZW5zZT17ZXhwZW5zZX1cclxuICAgICAgICAgICAgICAgIGJhbGFuY2U9e2JhbGFuY2V9XHJcbiAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGNvbnN0IGFtb3VudHMgPSBjb250YWluZXIucXVlcnlTZWxlY3RvckFsbChcclxuICAgICAgICAgICAgICBcIi50ZXh0LXNtLnNtXFxcXDp0ZXh0LWJhc2UubWRcXFxcOnRleHQteGwubGdcXFxcOnRleHQtMnhsXCJcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGV4cGVjdChhbW91bnRzLmxlbmd0aCkudG9CZUdyZWF0ZXJUaGFuKDApO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgYW1vdW50cy5mb3JFYWNoKChlbGVtZW50KSA9PiB7XHJcbiAgICAgICAgICAgICAgY29uc3QgZm9udENsYXNzZXMgPSBleHRyYWN0Rm9udFNpemVDbGFzc2VzKGVsZW1lbnQpO1xyXG4gICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgIGNvbnN0IGJhc2VTaXplID0gZ2V0Rm9udFNpemVGcm9tQ2xhc3MoZm9udENsYXNzZXMuYmFzZSk7XHJcbiAgICAgICAgICAgICAgY29uc3Qgc21TaXplID0gZ2V0Rm9udFNpemVGcm9tQ2xhc3MoZm9udENsYXNzZXMuc20pO1xyXG4gICAgICAgICAgICAgIGNvbnN0IG1kU2l6ZSA9IGdldEZvbnRTaXplRnJvbUNsYXNzKGZvbnRDbGFzc2VzLm1kKTtcclxuICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAvLyBWZXJpZnkgcHJvZ3Jlc3NpdmUgaW5jcmVhc2U6IG1vYmlsZSA8IHRhYmxldCA8IGRlc2t0b3BcclxuICAgICAgICAgICAgICBleHBlY3QoYmFzZVNpemUpLnRvQmVHcmVhdGVyVGhhbigwKTtcclxuICAgICAgICAgICAgICBleHBlY3Qoc21TaXplKS50b0JlR3JlYXRlclRoYW4oMCk7XHJcbiAgICAgICAgICAgICAgZXhwZWN0KG1kU2l6ZSkudG9CZUdyZWF0ZXJUaGFuKDApO1xyXG4gICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgIGV4cGVjdChzbVNpemUpLnRvQmVHcmVhdGVyVGhhbihiYXNlU2l6ZSk7XHJcbiAgICAgICAgICAgICAgZXhwZWN0KG1kU2l6ZSkudG9CZUdyZWF0ZXJUaGFuKHNtU2l6ZSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICksXHJcbiAgICAgICAgeyBudW1SdW5zOiBnZXROdW1SdW5zKFwiTUVESVVNXCIpIH1cclxuICAgICAgKTtcclxuICAgIH0pO1xyXG4gIH0pO1xyXG5cclxuICBkZXNjcmliZShcIkdlbmVyYWwgYWRhcHRpdmUgZm9udCBzaXplIHByb3BlcnR5XCIsICgpID0+IHtcclxuICAgIGl0KFwic2hvdWxkIGVuc3VyZSBhbGwgZWxlbWVudHMgd2l0aCByZXNwb25zaXZlIGZvbnQgY2xhc3NlcyBoYXZlIHByb2dyZXNzaXZlIHNpemluZ1wiLCAoKSA9PiB7XHJcbiAgICAgIGZjLmFzc2VydChcclxuICAgICAgICBmYy5wcm9wZXJ0eShcclxuICAgICAgICAgIGZjLmludGVnZXIoeyBtaW46IDAsIG1heDogMTAwMDAwMCB9KSxcclxuICAgICAgICAgIGZjLmludGVnZXIoeyBtaW46IDAsIG1heDogMTAwMDAwMCB9KSxcclxuICAgICAgICAgIChpbmNvbWUsIGV4cGVuc2UpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgYmFsYW5jZSA9IGluY29tZSAtIGV4cGVuc2U7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBjb25zdCB7IGNvbnRhaW5lciB9ID0gcmVuZGVyKFxyXG4gICAgICAgICAgICAgIDxCYWxhbmNlQ2FyZHNcclxuICAgICAgICAgICAgICAgIHRvdGFsSW5jb21lPXtpbmNvbWV9XHJcbiAgICAgICAgICAgICAgICB0b3RhbEV4cGVuc2U9e2V4cGVuc2V9XHJcbiAgICAgICAgICAgICAgICBiYWxhbmNlPXtiYWxhbmNlfVxyXG4gICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAvLyBGaW5kIGFsbCBlbGVtZW50cyB3aXRoIGFkYXB0aXZlIGZvbnQgc2l6ZSBjbGFzc2VzXHJcbiAgICAgICAgICAgIGNvbnN0IGFkYXB0aXZlRWxlbWVudHMgPSBjb250YWluZXIucXVlcnlTZWxlY3RvckFsbChcclxuICAgICAgICAgICAgICBcIi50ZXh0LXNtLnNtXFxcXDp0ZXh0LWJhc2UubWRcXFxcOnRleHQteGwubGdcXFxcOnRleHQtMnhsXCJcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGFkYXB0aXZlRWxlbWVudHMuZm9yRWFjaCgoZWxlbWVudCkgPT4ge1xyXG4gICAgICAgICAgICAgIGNvbnN0IGZvbnRDbGFzc2VzID0gZXh0cmFjdEZvbnRTaXplQ2xhc3NlcyhlbGVtZW50KTtcclxuICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAvLyBWZXJpZnkgZWxlbWVudCBoYXMgYWRhcHRpdmUgY2xhc3Nlc1xyXG4gICAgICAgICAgICAgIGV4cGVjdChoYXNBZGFwdGl2ZUZvbnRDbGFzc2VzKGVsZW1lbnQpKS50b0JlKHRydWUpO1xyXG4gICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgIC8vIFZlcmlmeSBmb250IHNpemVzIGFyZSBpbiBhc2NlbmRpbmcgb3JkZXJcclxuICAgICAgICAgICAgICBjb25zdCBiYXNlU2l6ZSA9IGdldEZvbnRTaXplRnJvbUNsYXNzKGZvbnRDbGFzc2VzLmJhc2UpO1xyXG4gICAgICAgICAgICAgIGNvbnN0IHNtU2l6ZSA9IGdldEZvbnRTaXplRnJvbUNsYXNzKGZvbnRDbGFzc2VzLnNtKTtcclxuICAgICAgICAgICAgICBjb25zdCBtZFNpemUgPSBnZXRGb250U2l6ZUZyb21DbGFzcyhmb250Q2xhc3Nlcy5tZCk7XHJcbiAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgaWYgKHNtU2l6ZSA+IDApIHtcclxuICAgICAgICAgICAgICAgIGV4cGVjdChzbVNpemUpLnRvQmVHcmVhdGVyVGhhbk9yRXF1YWwoYmFzZVNpemUpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBpZiAobWRTaXplID4gMCkge1xyXG4gICAgICAgICAgICAgICAgZXhwZWN0KG1kU2l6ZSkudG9CZUdyZWF0ZXJUaGFuT3JFcXVhbChzbVNpemUgfHwgYmFzZVNpemUpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgKSxcclxuICAgICAgICB7IG51bVJ1bnM6IGdldE51bVJ1bnMoXCJNRURJVU1cIikgfVxyXG4gICAgICApO1xyXG4gICAgfSk7XHJcbiAgfSk7XHJcblxyXG4gIGRlc2NyaWJlKFwiRWRnZSBjYXNlc1wiLCAoKSA9PiB7XHJcbiAgICBpdChcInNob3VsZCBoYXZlIGNvbnNpc3RlbnQgYWRhcHRpdmUgY2xhc3NlcyByZWdhcmRsZXNzIG9mIGRhdGEgdmFsdWVzXCIsICgpID0+IHtcclxuICAgICAgY29uc3QgeyBjb250YWluZXIgfSA9IHJlbmRlcihcclxuICAgICAgICA8QmFsYW5jZUNhcmRzXHJcbiAgICAgICAgICB0b3RhbEluY29tZT17NTAwMDB9XHJcbiAgICAgICAgICB0b3RhbEV4cGVuc2U9ezMwMDAwfVxyXG4gICAgICAgICAgYmFsYW5jZT17MjAwMDB9XHJcbiAgICAgICAgLz5cclxuICAgICAgKTtcclxuICAgICAgXHJcbiAgICAgIGNvbnN0IGFtb3VudHMgPSBjb250YWluZXIucXVlcnlTZWxlY3RvckFsbChcclxuICAgICAgICBcIi50ZXh0LXNtLnNtXFxcXDp0ZXh0LWJhc2UubWRcXFxcOnRleHQteGwubGdcXFxcOnRleHQtMnhsXCJcclxuICAgICAgKTtcclxuICAgICAgXHJcbiAgICAgIGFtb3VudHMuZm9yRWFjaCgoZWxlbWVudCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGZvbnRDbGFzc2VzID0gZXh0cmFjdEZvbnRTaXplQ2xhc3NlcyhlbGVtZW50KTtcclxuICAgICAgICBcclxuICAgICAgICAvLyBTaG91bGQgdXNlIG1vYmlsZSBzaXplICh0ZXh0LXNtKSBhcyBiYXNlXHJcbiAgICAgICAgZXhwZWN0KGZvbnRDbGFzc2VzLmJhc2UpLnRvQmUoXCJ0ZXh0LXNtXCIpO1xyXG4gICAgICAgIGV4cGVjdChmb250Q2xhc3Nlcy5zbSkudG9CZShcInRleHQtYmFzZVwiKTtcclxuICAgICAgICBleHBlY3QoZm9udENsYXNzZXMubWQpLnRvQmUoXCJ0ZXh0LXhsXCIpO1xyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG5cclxuICAgIGl0KFwic2hvdWxkIG1haW50YWluIGFkYXB0aXZlIGZvbnQgY2xhc3NlcyB3aXRoIGV4dHJlbWUgdmFsdWVzXCIsICgpID0+IHtcclxuICAgICAgY29uc3QgZXh0cmVtZUNhc2VzID0gW1xyXG4gICAgICAgIHsgaW5jb21lOiAwLCBleHBlbnNlOiAwLCBiYWxhbmNlOiAwIH0sXHJcbiAgICAgICAgeyBpbmNvbWU6IDk5OTk5OTk5OSwgZXhwZW5zZTogMCwgYmFsYW5jZTogOTk5OTk5OTk5IH0sXHJcbiAgICAgICAgeyBpbmNvbWU6IDAsIGV4cGVuc2U6IDk5OTk5OTk5OSwgYmFsYW5jZTogLTk5OTk5OTk5OSB9LFxyXG4gICAgICBdO1xyXG4gICAgICBcclxuICAgICAgZXh0cmVtZUNhc2VzLmZvckVhY2goKHsgaW5jb21lLCBleHBlbnNlLCBiYWxhbmNlIH0pID0+IHtcclxuICAgICAgICBjb25zdCB7IGNvbnRhaW5lciB9ID0gcmVuZGVyKFxyXG4gICAgICAgICAgPEJhbGFuY2VDYXJkc1xyXG4gICAgICAgICAgICB0b3RhbEluY29tZT17aW5jb21lfVxyXG4gICAgICAgICAgICB0b3RhbEV4cGVuc2U9e2V4cGVuc2V9XHJcbiAgICAgICAgICAgIGJhbGFuY2U9e2JhbGFuY2V9XHJcbiAgICAgICAgICAvPlxyXG4gICAgICAgICk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgY29uc3QgYW1vdW50cyA9IGNvbnRhaW5lci5xdWVyeVNlbGVjdG9yQWxsKFxyXG4gICAgICAgICAgXCIudGV4dC1zbS5zbVxcXFw6dGV4dC1iYXNlLm1kXFxcXDp0ZXh0LXhsLmxnXFxcXDp0ZXh0LTJ4bFwiXHJcbiAgICAgICAgKTtcclxuICAgICAgICBcclxuICAgICAgICBleHBlY3QoYW1vdW50cy5sZW5ndGgpLnRvQmVHcmVhdGVyVGhhbigwKTtcclxuICAgICAgICBcclxuICAgICAgICBhbW91bnRzLmZvckVhY2goKGVsZW1lbnQpID0+IHtcclxuICAgICAgICAgIGNvbnN0IGZvbnRDbGFzc2VzID0gZXh0cmFjdEZvbnRTaXplQ2xhc3NlcyhlbGVtZW50KTtcclxuICAgICAgICAgIFxyXG4gICAgICAgICAgY29uc3QgYmFzZVNpemUgPSBnZXRGb250U2l6ZUZyb21DbGFzcyhmb250Q2xhc3Nlcy5iYXNlKTtcclxuICAgICAgICAgIGNvbnN0IHNtU2l6ZSA9IGdldEZvbnRTaXplRnJvbUNsYXNzKGZvbnRDbGFzc2VzLnNtKTtcclxuICAgICAgICAgIGNvbnN0IG1kU2l6ZSA9IGdldEZvbnRTaXplRnJvbUNsYXNzKGZvbnRDbGFzc2VzLm1kKTtcclxuICAgICAgICAgIFxyXG4gICAgICAgICAgLy8gVmVyaWZ5IHByb2dyZXNzaXZlIHNpemluZyBpcyBtYWludGFpbmVkXHJcbiAgICAgICAgICBleHBlY3QoYmFzZVNpemUpLnRvQmUoMTQpO1xyXG4gICAgICAgICAgZXhwZWN0KHNtU2l6ZSkudG9CZSgxNik7XHJcbiAgICAgICAgICBleHBlY3QobWRTaXplKS50b0JlKDIwKTtcclxuICAgICAgICAgIGV4cGVjdChzbVNpemUpLnRvQmVHcmVhdGVyVGhhbihiYXNlU2l6ZSk7XHJcbiAgICAgICAgICBleHBlY3QobWRTaXplKS50b0JlR3JlYXRlclRoYW4oc21TaXplKTtcclxuICAgICAgICB9KTtcclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBpdChcInNob3VsZCBhcHBseSBhZGFwdGl2ZSBmb250IGNsYXNzZXMgdG8gYWxsIHRocmVlIGJhbGFuY2UgY2FyZHNcIiwgKCkgPT4ge1xyXG4gICAgICBmYy5hc3NlcnQoXHJcbiAgICAgICAgZmMucHJvcGVydHkoXHJcbiAgICAgICAgICBmYy5pbnRlZ2VyKHsgbWluOiAwLCBtYXg6IDEwMDAwMDAgfSksXHJcbiAgICAgICAgICBmYy5pbnRlZ2VyKHsgbWluOiAwLCBtYXg6IDEwMDAwMDAgfSksXHJcbiAgICAgICAgICAoaW5jb21lLCBleHBlbnNlKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGJhbGFuY2UgPSBpbmNvbWUgLSBleHBlbnNlO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgY29uc3QgeyBjb250YWluZXIgfSA9IHJlbmRlcihcclxuICAgICAgICAgICAgICA8QmFsYW5jZUNhcmRzXHJcbiAgICAgICAgICAgICAgICB0b3RhbEluY29tZT17aW5jb21lfVxyXG4gICAgICAgICAgICAgICAgdG90YWxFeHBlbnNlPXtleHBlbnNlfVxyXG4gICAgICAgICAgICAgICAgYmFsYW5jZT17YmFsYW5jZX1cclxuICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgY29uc3QgYW1vdW50cyA9IGNvbnRhaW5lci5xdWVyeVNlbGVjdG9yQWxsKFxyXG4gICAgICAgICAgICAgIFwiLnRleHQtc20uc21cXFxcOnRleHQtYmFzZS5tZFxcXFw6dGV4dC14bC5sZ1xcXFw6dGV4dC0yeGxcIlxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgLy8gU2hvdWxkIGhhdmUgZXhhY3RseSAzIGFtb3VudCBlbGVtZW50cyAoaW5jb21lLCBleHBlbnNlLCBiYWxhbmNlKVxyXG4gICAgICAgICAgICBleHBlY3QoYW1vdW50cy5sZW5ndGgpLnRvQmUoMyk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAvLyBBbGwgdGhyZWUgc2hvdWxkIGhhdmUgdGhlIHNhbWUgYWRhcHRpdmUgZm9udCBjbGFzc2VzXHJcbiAgICAgICAgICAgIGFtb3VudHMuZm9yRWFjaCgoZWxlbWVudCkgPT4ge1xyXG4gICAgICAgICAgICAgIGV4cGVjdChlbGVtZW50KS50b0hhdmVDbGFzcyhcInRleHQtc21cIik7XHJcbiAgICAgICAgICAgICAgZXhwZWN0KGVsZW1lbnQpLnRvSGF2ZUNsYXNzKFwic206dGV4dC1iYXNlXCIpO1xyXG4gICAgICAgICAgICAgIGV4cGVjdChlbGVtZW50KS50b0hhdmVDbGFzcyhcIm1kOnRleHQteGxcIik7XHJcbiAgICAgICAgICAgICAgZXhwZWN0KGVsZW1lbnQpLnRvSGF2ZUNsYXNzKFwibGc6dGV4dC0yeGxcIik7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICksXHJcbiAgICAgICAgeyBudW1SdW5zOiBnZXROdW1SdW5zKFwiTUVESVVNXCIpIH1cclxuICAgICAgKTtcclxuICAgIH0pO1xyXG4gIH0pO1xyXG59KTtcclxuIl0sIm5hbWVzIjpbInRhaWx3aW5kRm9udFNpemVzIiwiaGFzQWRhcHRpdmVGb250Q2xhc3NlcyIsImVsZW1lbnQiLCJjbGFzc0xpc3QiLCJBcnJheSIsImZyb20iLCJoYXNCYXNlU2l6ZSIsInNvbWUiLCJjbHMiLCJzdGFydHNXaXRoIiwiaGFzU21Nb2RpZmllciIsImhhc01kTW9kaWZpZXIiLCJleHRyYWN0Rm9udFNpemVDbGFzc2VzIiwiYmFzZSIsImZpbmQiLCJ0ZXN0Iiwic20iLCJyZXBsYWNlIiwibWQiLCJnZXRGb250U2l6ZUZyb21DbGFzcyIsImNsYXNzTmFtZSIsImRlc2NyaWJlIiwiaXQiLCJmYyIsImFzc2VydCIsInByb3BlcnR5IiwiaW50ZWdlciIsIm1pbiIsIm1heCIsImluY29tZSIsImV4cGVuc2UiLCJiYWxhbmNlIiwiY29udGFpbmVyIiwicmVuZGVyIiwiQmFsYW5jZUNhcmRzIiwidG90YWxJbmNvbWUiLCJ0b3RhbEV4cGVuc2UiLCJhbW91bnRzIiwicXVlcnlTZWxlY3RvckFsbCIsImV4cGVjdCIsImxlbmd0aCIsInRvQmVHcmVhdGVyVGhhbiIsImZvckVhY2giLCJmb250Q2xhc3NlcyIsInRvQmUiLCJiYXNlU2l6ZSIsInNtU2l6ZSIsIm1kU2l6ZSIsIm51bVJ1bnMiLCJnZXROdW1SdW5zIiwiYWRhcHRpdmVFbGVtZW50cyIsInRvQmVHcmVhdGVyVGhhbk9yRXF1YWwiLCJleHRyZW1lQ2FzZXMiLCJ0b0hhdmVDbGFzcyJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7O0NBUUM7Ozs7OzhEQUVpQjt3QkFDSztrRUFDUjs4QkFDYztvQ0FDVTs7Ozs7O0FBRXZDLHVEQUF1RDtBQUN2RCxNQUFNQSxvQkFBb0I7SUFDeEIsV0FBVztJQUNYLFdBQVc7SUFDWCxhQUFhO0lBQ2IsV0FBVztJQUNYLFdBQVc7SUFDWCxZQUFZO0lBQ1osWUFBWTtJQUNaLFlBQVk7QUFDZDtBQUVBLHFFQUFxRTtBQUNyRSxNQUFNQyx5QkFBeUIsQ0FBQ0M7SUFDOUIsTUFBTUMsWUFBWUMsTUFBTUMsSUFBSSxDQUFDSCxRQUFRQyxTQUFTO0lBRTlDLHNEQUFzRDtJQUN0RCxNQUFNRyxjQUFjSCxVQUFVSSxJQUFJLENBQUNDLENBQUFBLE1BQU9BLElBQUlDLFVBQVUsQ0FBQztJQUN6RCxNQUFNQyxnQkFBZ0JQLFVBQVVJLElBQUksQ0FBQ0MsQ0FBQUEsTUFBT0EsSUFBSUMsVUFBVSxDQUFDO0lBQzNELE1BQU1FLGdCQUFnQlIsVUFBVUksSUFBSSxDQUFDQyxDQUFBQSxNQUFPQSxJQUFJQyxVQUFVLENBQUM7SUFFM0QsT0FBT0gsZUFBZ0JJLENBQUFBLGlCQUFpQkMsYUFBWTtBQUN0RDtBQUVBLG9EQUFvRDtBQUNwRCxNQUFNQyx5QkFBeUIsQ0FBQ1Y7SUFLOUIsTUFBTUMsWUFBWUMsTUFBTUMsSUFBSSxDQUFDSCxRQUFRQyxTQUFTO0lBRTlDLE1BQU1VLE9BQU9WLFVBQVVXLElBQUksQ0FBQ04sQ0FBQUEsTUFBTyx3Q0FBd0NPLElBQUksQ0FBQ1AsU0FBUztJQUN6RixNQUFNUSxLQUFLYixVQUFVVyxJQUFJLENBQUNOLENBQUFBLE1BQU8sMkNBQTJDTyxJQUFJLENBQUNQLE9BQU9TLFFBQVEsT0FBTyxPQUFPO0lBQzlHLE1B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