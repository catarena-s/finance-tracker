# Документ требований: Backend API для трекера личных финансов

## Введение

Backend API для Full-Stack приложения трекера личных финансов. Система предоставляет REST API для управления транзакциями, категориями и бюджетами с поддержкой аналитики, импорта/экспорта данных и мультивалютности. Реализация использует трёхслойную архитектуру (API routes → Services → Repositories → Database) на базе FastAPI, SQLAlchemy 2.0+ (async) и PostgreSQL 15+.

## Глоссарий

- **API**: Application Programming Interface - REST API эндпоинты для взаимодействия с системой
- **Transaction**: Финансовая транзакция (доход или расход)
- **Category**: Категория для классификации транзакций
- **Budget**: Бюджет, привязанный к категории на определённый период
- **Repository**: Слой доступа к данным, инкапсулирующий операции с БД
- **Service**: Слой бизнес-логики, координирующий операции между API и Repository
- **Analytics_Service**: Сервис для расчёта статистики и аналитики
- **Session**: SQLAlchemy async session для работы с БД
- **CSV_Importer**: Компонент для импорта транзакций из CSV файлов
- **CSV_Exporter**: Компонент для экспорта транзакций в CSV файлы

## Требования

### Требование 1: Управление транзакциями

**User Story:** Как пользователь, я хочу управлять своими финансовыми транзакциями, чтобы отслеживать доходы и расходы.

#### Критерии приёмки

1. WHEN пользователь создаёт транзакцию с валидными данными, THE API SHALL создать новую запись в БД и вернуть объект транзакции с HTTP 201
2. WHEN пользователь запрашивает список транзакций, THE API SHALL вернуть пагинированный список с HTTP 200
3. WHEN пользователь запрашивает транзакцию по ID, THE API SHALL вернуть объект транзакции с HTTP 200
4. WHEN пользователь обновляет транзакцию с валидными данными, THE API SHALL обновить запись и вернуть обновлённый объект с HTTP 200
5. WHEN пользователь удаляет транзакцию, THE API SHALL удалить запись и вернуть HTTP 204
6. WHEN пользователь создаёт транзакцию с отрицательной суммой, THE API SHALL вернуть ошибку валидации с HTTP 422
7. WHEN пользователь запрашивает несуществующую транзакцию, THE API SHALL вернуть ошибку с HTTP 404
8. THE Transaction SHALL содержать поля: id, amount, currency, category_id, description, transaction_date, type, is_recurring, recurring_pattern, created_at, updated_at

### Требование 2: Фильтрация и пагинация транзакций

**User Story:** Как пользователь, я хочу фильтровать и просматривать транзакции постранично, чтобы находить нужные записи.

#### Критерии приёмки

1. WHEN пользователь запрашивает транзакции с фильтром по дате начала и окончания, THE API SHALL вернуть только транзакции в указанном диапазоне
2. WHEN пользователь запрашивает транзакции с фильтром по категории, THE API SHALL вернуть только транзакции указанной категории
3. WHEN пользователь запрашивает транзакции с фильтром по типу (income/expense), THE API SHALL вернуть только транзакции указанного типа
4. WHEN пользователь запрашивает транзакции с фильтром по минимальной и максимальной сумме, THE API SHALL вернуть только транзакции в указанном диапазоне сумм
5. WHEN пользователь запрашивает транзакции с параметрами пагинации (page, page_size), THE API SHALL вернуть указанную страницу с метаданными (total, pages)
6. WHEN пользователь комбинирует несколько фильтров, THE API SHALL применить все фильтры одновременно

### Требование 3: Импорт и экспорт транзакций

**User Story:** Как пользователь, я хочу импортировать и экспортировать транзакции в формате CSV, чтобы переносить данные между системами.

#### Критерии приёмки

1. WHEN пользователь загружает валидный CSV файл с транзакциями, THE CSV_Importer SHALL парсить файл и создать транзакции в БД
2. WHEN пользователь загружает CSV файл с невалидными данными, THE CSV_Importer SHALL вернуть ошибку с описанием проблемных строк
3. WHEN пользователь запрашивает экспорт транзакций, THE CSV_Exporter SHALL сгенерировать CSV файл со всеми транзакциями
4. WHEN пользователь запрашивает экспорт с фильтрами, THE CSV_Exporter SHALL экспортировать только отфильтрованные транзакции
5. THE CSV_Importer SHALL поддерживать формат: amount, currency, category_name, description, transaction_date, type
6. THE CSV_Exporter SHALL генерировать файл в том же формате, что и импорт

### Требование 4: Управление категориями

**User Story:** Как пользователь, я хочу управлять категориями транзакций, чтобы классифицировать свои доходы и расходы.

#### Критерии приёмки

1. WHEN пользователь создаёт категорию с валидными данными, THE API SHALL создать новую запись и вернуть объект категории с HTTP 201
2. WHEN пользователь запрашивает список категорий, THE API SHALL вернуть все категории с HTTP 200
3. WHEN пользователь обновляет категорию, THE API SHALL обновить запись и вернуть обновлённый объект с HTTP 200
4. WHEN пользователь удаляет категорию без связанных транзакций, THE API SHALL удалить запись и вернуть HTTP 204
5. WHEN пользователь удаляет категорию со связанными транзакциями, THE API SHALL вернуть ошибку с HTTP 409
6. WHEN пользователь создаёт категорию с дублирующимся именем и типом, THE API SHALL вернуть ошибку с HTTP 409
7. THE Category SHALL содержать поля: id, name, icon, color, type, created_at, updated_at
8. THE Category SHALL валидировать цвет в формате hex (#RRGGBB)

### Требование 5: Управление бюджетами

**User Story:** Как пользователь, я хочу устанавливать бюджеты для категорий, чтобы контролировать свои расходы.

#### Критерии приёмки

1. WHEN пользователь создаёт бюджет с валидными данными, THE API SHALL создать новую запись и вернуть объект бюджета с HTTP 201
2. WHEN пользователь запрашивает список бюджетов, THE API SHALL вернуть все бюджеты с HTTP 200
3. WHEN пользователь обновляет бюджет, THE API SHALL обновить запись и вернуть обновлённый объект с HTTP 200
4. WHEN пользователь удаляет бюджет, THE API SHALL удалить запись и вернуть HTTP 204
5. WHEN пользователь создаёт бюджет с end_date <= start_date, THE API SHALL вернуть ошибку валидации с HTTP 422
6. WHEN пользователь создаёт бюджет с отрицательной суммой, THE API SHALL вернуть ошибку валидации с HTTP 422
7. WHEN пользователь создаёт дублирующийся бюджет (category_id, period, start_date), THE API SHALL вернуть ошибку с HTTP 409
8. THE Budget SHALL содержать поля: id, category_id, amount, period, start_date, end_date, created_at, updated_at

### Требование 6: Расчёт прогресса бюджета

**User Story:** Как пользователь, я хочу видеть прогресс выполнения бюджета, чтобы контролировать свои расходы.

#### Критерии приёмки

1. WHEN пользователь запрашивает прогресс бюджета, THE Analytics_Service SHALL рассчитать сумму потраченных средств за период бюджета
2. WHEN пользователь запрашивает прогресс бюджета, THE Analytics_Service SHALL рассчитать процент использования бюджета
3. WHEN пользователь запрашивает прогресс бюджета, THE Analytics_Service SHALL рассчитать оставшуюся сумму
4. WHEN сумма расходов превышает бюджет, THE Analytics_Service SHALL вернуть процент > 100
5. THE Analytics_Service SHALL учитывать только транзакции типа expense для расчёта прогресса
6. THE Analytics_Service SHALL учитывать только транзакции в диапазоне дат бюджета

### Требование 7: Аналитика и статистика

**User Story:** Как пользователь, я хочу видеть аналитику по своим финансам, чтобы принимать обоснованные решения.

#### Критерии приёмки

1. WHEN пользователь запрашивает summary статистику, THE Analytics_Service SHALL вернуть общий доход, общий расход и баланс за период
2. WHEN пользователь запрашивает trends, THE Analytics_Service SHALL вернуть динамику доходов и расходов по месяцам
3. WHEN пользователь запрашивает breakdown по категориям, THE Analytics_Service SHALL вернуть распределение расходов по категориям
4. WHEN пользователь запрашивает top категории, THE Analytics_Service SHALL вернуть категории с наибольшими расходами
5. THE Analytics_Service SHALL поддерживать фильтрацию по диапазону дат для всех аналитических запросов
6. THE Analytics_Service SHALL возвращать суммы в единой валюте (по умолчанию USD)

### Требование 8: Обработка ошибок

**User Story:** Как разработчик, я хочу получать понятные сообщения об ошибках, чтобы быстро диагностировать проблемы.

#### Критерии приёмки

1. WHEN происходит ошибка валидации, THE API SHALL вернуть HTTP 422 с детальным описанием ошибок валидации
2. WHEN запрашивается несуществующий ресурс, THE API SHALL вернуть HTTP 404 с сообщением "Resource not found"
3. WHEN происходит конфликт (duplicate, foreign key), THE API SHALL вернуть HTTP 409 с описанием конфликта
4. WHEN происходит внутренняя ошибка сервера, THE API SHALL вернуть HTTP 500 и залогировать детали ошибки
5. THE API SHALL возвращать ошибки в едином JSON формате: {error: string, detail: string, status_code: int}
6. THE API SHALL логировать все ошибки с уровнем ERROR или выше

### Требование 9: Модели данных SQLAlchemy

**User Story:** Как разработчик, я хочу иметь чёткие модели данных, чтобы обеспечить целостность данных в БД.

#### Критерии приёмки

1. THE Transaction SHALL иметь constraint для проверки amount > 0
2. THE Transaction SHALL иметь constraint для проверки type IN ('income', 'expense')
3. THE Transaction SHALL иметь foreign key на Category
4. THE Category SHALL иметь unique constraint на (name, type)
5. THE Category SHALL иметь constraint для проверки type IN ('income', 'expense')
6. THE Budget SHALL иметь constraint для проверки amount > 0
7. THE Budget SHALL иметь constraint для проверки end_date > start_date
8. THE Budget SHALL иметь unique constraint на (category_id, period, start_date)
9. THE Budget SHALL иметь foreign key на Category
10. THE Session SHALL использовать async режим для всех операций с БД

### Требование 10: Pydantic схемы валидации

**User Story:** Как разработчик, я хочу валидировать входные данные на уровне API, чтобы предотвратить некорректные данные.

#### Критерии приёмки

1. THE TransactionCreate SHALL валидировать amount > 0
2. THE TransactionCreate SHALL валидировать currency как 3-буквенный код (ISO 4217)
3. THE TransactionCreate SHALL валидировать type IN ('income', 'expense')
4. THE CategoryCreate SHALL валидировать color в формате hex (#RRGGBB)
5. THE CategoryCreate SHALL валидировать type IN ('income', 'expense')
6. THE BudgetCreate SHALL валидировать amount > 0
7. THE BudgetCreate SHALL валидировать period IN ('monthly', 'yearly')
8. THE BudgetCreate SHALL валидировать end_date > start_date
9. THE API SHALL использовать Pydantic v2 для всех схем валидации

### Требование 11: Архитектура слоёв

**User Story:** Как разработчик, я хочу иметь чёткое разделение ответственности, чтобы код был поддерживаемым и тестируемым.

#### Критерии приёмки

1. THE Repository SHALL инкапсулировать все операции с БД (CRUD, queries)
2. THE Service SHALL содержать бизнес-логику и координировать вызовы Repository
3. THE API_Route SHALL обрабатывать HTTP запросы и вызывать Service
4. THE API_Route SHALL НЕ содержать бизнес-логику
5. THE Service SHALL НЕ содержать SQL запросы напрямую
6. THE Repository SHALL возвращать модели SQLAlchemy
7. THE Service SHALL преобразовывать модели SQLAlchemy в Pydantic схемы
8. THE API_Route SHALL принимать и возвращать только Pydantic схемы

### Требование 12: Мультивалютность

**User Story:** Как пользователь, я хочу работать с разными валютами, чтобы отслеживать транзакции в различных валютах.

#### Критерии приёмки

1. THE Transaction SHALL поддерживать поле currency с кодом валюты (ISO 4217)
2. WHEN пользователь создаёт транзакцию без указания валюты, THE API SHALL использовать USD по умолчанию
3. THE Analytics_Service SHALL конвертировать все суммы в единую валюту для расчёта статистики
4. THE API SHALL валидировать currency как 3-буквенный код в верхнем регистре

### Требование 13: Повторяющиеся транзакции

**User Story:** Как пользователь, я хочу отмечать повторяющиеся транзакции, чтобы отслеживать регулярные платежи.

#### Критерии приёмки

1. THE Transaction SHALL поддерживать поле is_recurring (boolean)
2. THE Transaction SHALL поддерживать поле recurring_pattern (JSONB) для хранения паттерна повторения
3. WHEN пользователь создаёт транзакцию с is_recurring=true, THE API SHALL требовать наличие recurring_pattern
4. THE recurring_pattern SHALL содержать поля: frequency (daily/weekly/monthly/yearly), interval (int)

### Требование 14: OpenAPI документация

**User Story:** Как разработчик, я хочу иметь автоматически генерируемую документацию API, чтобы легко интегрироваться с системой.

#### Критерии приёмки

1. THE API SHALL генерировать OpenAPI (Swagger) документацию автоматически
2. THE API SHALL предоставлять интерактивную документацию по адресу /docs
3. THE API SHALL предоставлять ReDoc документацию по адресу /redoc
4. THE API SHALL документировать все эндпоинты с описаниями, параметрами и примерами ответов
5. THE API SHALL документировать все схемы данных (Pydantic models)
6. THE API SHALL документировать все коды ответов (200, 201, 204, 400, 404, 409, 422, 500)

### Требование 15: Тестирование

**User Story:** Как разработчик, я хочу иметь комплексное покрытие тестами, чтобы обеспечить надёжность системы.

#### Критерии приёмки

1. THE Repository SHALL иметь unit тесты для всех CRUD операций
2. THE Service SHALL иметь unit тесты для всей бизнес-логики
3. THE API_Route SHALL иметь integration тесты для всех эндпоинтов
4. THE System SHALL использовать pytest + pytest-asyncio для async тестов
5. THE System SHALL использовать httpx для тестирования API эндпоинтов
6. THE System SHALL использовать Hypothesis для property-based тестов валидации
7. THE System SHALL иметь минимум 10 property-based тестов для критичной логики
8. THE System SHALL использовать test database для изоляции тестов
