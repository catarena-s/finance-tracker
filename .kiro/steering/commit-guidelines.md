---
inclusion: auto
---

# Правила коммитов

## ⚠️ КРИТИЧЕСКОЕ ПРАВИЛО

**НИКОГДА НЕ КОММИТИТЬ НАПРЯМУЮ В ВЕТКУ MAIN!**

Все изменения должны идти через feature-ветки и Pull Request.

## Подготовка к новому этапу

**Перед началом работы над новым этапом всегда актуализируйте main:**

```bash
# 1. Переключиться на main
git checkout main

# 2. Получить изменения из upstream (original репозиторий)
git fetch upstream
git merge upstream/main

# 3. Отправить в свой fork
git push origin main

# 4. Создать новую ветку для этапа
git checkout -b feature/название-этапа
```

**Важно:** 
- Каждый новый этап начинается с актуальной ветки main
- Все коммиты делаются только в feature-ветки
- Main обновляется только через Pull Request

## Язык

**Все коммиты должны быть на русском языке.**

## Автор коммитов

**Важно**: Используйте правильного автора для всех коммитов.

Настройки автора хранятся в `.kiro/local/git-author.conf` (файл игнорируется git).

### Настройка автора

**Вариант 1: Глобальная настройка (рекомендуется)**
```bash
git config --global user.name "Ваше Имя"
git config --global user.email "your.email@example.com"
```

**Вариант 2: Для конкретного коммита**
```bash
git commit --author="Ваше Имя <your.email@example.com>" -m "сообщение"
```

**Вариант 3: Для текущего репозитория**
```bash
git config user.name "Ваше Имя"
git config user.email "your.email@example.com"
```

Конкретные данные автора смотрите в `.kiro/local/git-author.conf`

## Формат коммита

```
<тип>(<область>): <краткое описание>

<подробное описание (опционально)>

<footer (опционально)>
```

### Типы коммитов

- `feat` - новая функциональность
- `fix` - исправление бага
- `docs` - изменения в документации
- `style` - форматирование, отсутствующие точки с запятой и т.д.
- `refactor` - рефакторинг кода
- `test` - добавление или исправление тестов
- `chore` - обновление зависимостей, конфигурации и т.д.

### Примеры

```bash
feat(frontend): добавить интеграционные тесты для пользовательских сценариев

fix(backend): исправить ошибку валидации в analytics API

test(frontend): добавить тесты для оптимистичных обновлений
```

## Когда делать коммит

✅ **Делайте коммит когда:**
- Завершен логически целостный блок работы
- Все тесты проходят успешно
- Код скомпилирован без ошибок
- Выполнена задача или подзадача из tasks.md

❌ **Не делайте коммит когда:**
- Код не компилируется
- Тесты падают
- Работа не завершена (используйте stash)

## CHANGELOG.md

**ВАЖНО: CHANGELOG.md обновляется в конце работы в ветке, перед созданием PR!**

### Правила обновления CHANGELOG:

1. **Когда обновлять:**
   - В конце работы над веткой
   - Перед созданием Pull Request
   - После завершения всех коммитов в ветке

2. **Что включать:**
   - Краткое описание ключевых изменений
   - Группировка по категориям (Frontend, Backend, Документация и т.д.)
   - Упоминание важных исправлений и новых функций

3. **Формат записи (компактный стиль):**
   ```markdown
   ## X.X.X - ГГГГ-ММ-ДД

   ### Ключевые изменения (Краткое описание области)

   - **Категория:** описание изменений через точку с запятой; еще изменения; и еще.
   - **Категория:** описание изменений через точку с запятой; еще изменения.
   ```

   **Стиль:**
   - Одна строка на категорию
   - Пункты внутри категории разделены точкой с запятой
   - Компактно, без лишних деталей
   - Смотри версию 0.0.9 как пример

4. **Коммит CHANGELOG:**
   - **ВАЖНО: CHANGELOG.md коммитится ТОЛЬКО после утверждения пользователем!**
   - Создается отдельный коммит с типом `docs`
   - Пример: `docs: обновлен CHANGELOG для версии 0.0.8`
   - Этот коммит должен быть последним перед созданием PR
   - **ВАЖНО: CHANGELOG.md можно коммитить ТОЛЬКО после утверждения пользователем!**

**Примечание:** Не обновляйте CHANGELOG в каждом коммите - это создает конфликты и засоряет историю.

## Размер коммита

- **Один коммит = одна задача/подзадача**
- Избегайте слишком больших коммитов (>500 строк)
- Разбивайте большие изменения на логические части

## Сообщение коммита

### Краткое описание (обязательно)
- Максимум 72 символа
- Начинается с маленькой буквы
- Без точки в конце
- Описывает ЧТО сделано, а не КАК

### Подробное описание (опционально)
- Объясняет ПОЧЕМУ и КАК
- Перечисляет ключевые изменения
- Ссылается на требования или задачи

### Footer (опционально)
- `Fixes #123` - закрывает issue
- `Refs #456` - ссылается на issue
- `BREAKING CHANGE:` - breaking changes

## Проверка перед коммитом

**ОБЯЗАТЕЛЬНО запускайте проверки перед каждым коммитом!**

### Frontend

```bash
cd frontend

# Проверка типов
npm run type-check

# Линтинг
npm run lint

# Форматирование
npm run format:check

# Запуск тестов
npm test -- --watchAll=false
```

### Backend

**ВАЖНО: Backend тесты ВСЕГДА запускаются в Docker контейнере!**

```bash
# Линтинг (Ruff) - можно локально
cd backend
ruff check .

# Форматирование (Black) - можно локально
black --check .

# Если Black находит проблемы, исправьте их:
black .

# Запуск тестов - ОБЯЗАТЕЛЬНО в Docker!
cd ..
docker-compose exec backend pytest
```

**Критерий успеха:**
- ВСЕ тесты проходят (103/103 passed)
- НЕТ пропущенных тестов (0 skipped)
- Если видишь "X skipped" - это ОШИБКА, нужно запустить в Docker

### Быстрая проверка всего проекта

```bash
# Backend (линтинг локально, тесты в Docker)
cd backend && ruff check . && black --check . && cd .. && docker-compose exec backend pytest

# Frontend
cd frontend && npm run type-check && npm run lint && npm run format:check && npm test -- --watchAll=false && cd ..
```

**ВАЖНО:** Backend тесты ВСЕГДА запускаются в Docker (`docker-compose exec backend pytest`), не локально!

## Автоматизация проверок (рекомендуется)

Для автоматического запуска проверок перед коммитом используйте pre-commit hooks или создайте hook в Kiro:

```bash
# Создать hook для проверки перед коммитом
# Откройте Kiro Hook UI через Command Palette
```

**Важно:** CI будет проверять те же правила. Если проверки не пройдут локально, они не пройдут и в CI.
